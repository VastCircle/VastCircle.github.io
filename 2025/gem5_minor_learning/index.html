<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="MinorCPU --- Pipeline - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism. --- --- Fetch1 - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface). --- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1. --- --- Fetch2 - line to instruction decomposition. --- --- Decode - instruction to micro-op decomposition. --- --- Execute - instruction execution and data memory interface. --- --- --- LSQ - load store queue for memory ref. instructions. --- --- --- LSQ::DcachePort - interface to the D-ache from Execute. "><title>Gem5_minor_learning</title>
<link rel=canonical href=https://VastCircle.github.io/2025/gem5_minor_learning/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='Gem5_minor_learning'><meta property='og:description' content="MinorCPU --- Pipeline - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism. --- --- Fetch1 - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface). --- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1. --- --- Fetch2 - line to instruction decomposition. --- --- Decode - instruction to micro-op decomposition. --- --- Execute - instruction execution and data memory interface. --- --- --- LSQ - load store queue for memory ref. instructions. --- --- --- LSQ::DcachePort - interface to the D-ache from Execute. "><meta property='og:url' content='https://VastCircle.github.io/2025/gem5_minor_learning/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-03-11T21:20:03+08:00'><meta property='article:modified_time' content='2025-03-11T21:20:03+08:00'><meta name=twitter:title content="Gem5_minor_learning"><meta name=twitter:description content="MinorCPU --- Pipeline - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism. --- --- Fetch1 - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface). --- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1. --- --- Fetch2 - line to instruction decomposition. --- --- Decode - instruction to micro-op decomposition. --- --- Execute - instruction execution and data memory interface. --- --- --- LSQ - load store queue for memory ref. instructions. --- --- --- LSQ::DcachePort - interface to the D-ache from Execute. "><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/gem5/>Gem5</a></header><h2 class=article-title><a href=/2025/gem5_minor_learning/>Gem5_minor_learning</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 11, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>17510字</time></div></footer></div></header><section class=article-content><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>MinorCPU
</span></span><span style=display:flex><span>--- Pipeline - container <span style=color:#c678dd>for</span> the pipeline, owns the cyclic <span style=color:#98c379>&#39;tick&#39;</span> event mechanism and the idling <span style=color:#56b6c2>(</span>cycle skipping<span style=color:#56b6c2>)</span> mechanism.
</span></span><span style=display:flex><span>--- --- Fetch1 - instruction fetch unit responsible <span style=color:#c678dd>for</span> fetching cache lines <span style=color:#56b6c2>(</span>or parts of lines from the I-cache interface<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span>--- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1.
</span></span><span style=display:flex><span>--- --- Fetch2 - line to instruction decomposition.
</span></span><span style=display:flex><span>--- --- Decode - instruction to micro-op decomposition.
</span></span><span style=display:flex><span>--- --- Execute - instruction execution and data memory interface.
</span></span><span style=display:flex><span>--- --- --- LSQ - load store queue <span style=color:#c678dd>for</span> memory ref. instructions.
</span></span><span style=display:flex><span>--- --- --- LSQ::DcachePort - interface to the D-ache from Execute.
</span></span></code></pre></div><h2 id=温习修改gem5-源码的方法创建自己的simobject>温习修改gem5 源码的方法（创建自己的simobject)</h2><ol><li>创建一个python 文件 ， 这个py类需要继承SimObject , 其中需要声明 cxx_header 和cxx_class ,</li></ol><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>from</span> <span style=color:#e06c75>m5</span>.<span style=color:#e06c75>params</span> <span style=color:#e06c75>import</span> <span style=color:#56b6c2>*</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>from</span> <span style=color:#e06c75>m5</span>.<span style=color:#e06c75>SimObject</span> <span style=color:#e06c75>import</span> <span style=color:#e06c75>SimObject</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>HelloObject</span>(<span style=color:#e06c75>SimObject</span>)<span style=color:#56b6c2>:</span> 
</span></span><span style=display:flex><span>	<span style=color:#e06c75>type</span> <span style=color:#56b6c2>=</span> &#39;<span style=color:#e06c75>HelloObject</span>&#39;
</span></span><span style=display:flex><span>	<span style=color:#e06c75>cxx_header</span> <span style=color:#56b6c2>=</span> <span style=color:#98c379>&#34;learning_gem5/part2/hello_object.hh&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>cxx_class</span> <span style=color:#56b6c2>=</span> <span style=color:#98c379>&#34;gem5::HelloObject&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e># 其它自定义参数，可以在c++端使用
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>	<span style=color:#e06c75>time_to_wait</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>Param</span>.<span style=color:#e06c75>Latency</span>(<span style=color:#98c379>&#34;Time before firing the event&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>foo</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>Param</span>.<span style=color:#e06c75>Int</span>(<span style=color:#d19a66>114514</span>, <span style=color:#98c379>&#34;test&#34;</span>)
</span></span></code></pre></div><ol start=2><li>编写simObject的c++ 文件</li></ol><p>包含头文件（cxx_header)和源文件（cxx_class) , 可以访问相应的param</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>HelloObject</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>HelloObject</span>(<span style=color:#c678dd>const</span> <span style=color:#e06c75>HelloObjectParams</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>params</span>) <span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>SimObject</span>(<span style=color:#e06c75>params</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>params</span>.<span style=color:#e06c75>foo</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>向编译系统注册py和c++文件</li></ol><p>主要是通过Sconscript 来吧相应的源文件 ， py 文件都加入进来</p><h2 id=代码分析>代码分析</h2><p>以下的堆栈是到</p><p><figure class=gallery-image style=flex-grow:165;flex-basis:396px><a href=/2025/gem5_minor_learning/image-20250311235716377.png data-size=609x369><img src=/2025/gem5_minor_learning/image-20250311235716377.png width=609 height=369 srcset="/2025/gem5_minor_learning/image-20250311235716377_hu6937501589174305945.png 480w, /2025/gem5_minor_learning/image-20250311235716377_hu14359312087631442923.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:191;flex-basis:459px><a href=/2025/gem5_minor_learning/image-20250312005850444.png data-size=685x358><img src=/2025/gem5_minor_learning/image-20250312005850444.png width=685 height=358 srcset="/2025/gem5_minor_learning/image-20250312005850444_hu3726841674560749055.png 480w, /2025/gem5_minor_learning/image-20250312005850444_hu7856314020256738859.png 1024w" loading=lazy></a></figure></p><p>如果要模拟流水线的行为 ， 首先在某个周期每个流水段应该同时进行 ， 因为后一段流水会依赖前一段流水前面的状态，所以说应该先去执行后一段流水，即倒着执行 。 倒着执行的话后一段流水得到的就是前一段流水上一个周期的状态。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#e06c75>execute</span>.<span style=color:#e06c75>evaluate</span>();
</span></span><span style=display:flex><span>    <span style=color:#e06c75>decode</span>.<span style=color:#e06c75>evaluate</span>();
</span></span><span style=display:flex><span>    <span style=color:#e06c75>fetch2</span>.<span style=color:#e06c75>evaluate</span>();
</span></span><span style=display:flex><span>    <span style=color:#e06c75>fetch1</span>.<span style=color:#e06c75>evaluate</span>();
</span></span></code></pre></div><h2 id=instid>InstId</h2><p>用于标识流水线和指令的信息。这包括所有执行阶段的相关序列号和线程 ID。</p><div class=table-wrapper><table><thead><tr><th style=text-align:center>field</th><th style=text-align:center>symbol</th><th style=text-align:center>generated by</th><th style=text-align:center>checked by</th><th style=text-align:center>function</th></tr></thead><tbody><tr><td style=text-align:center>threadid</td><td style=text-align:center>T</td><td style=text-align:center>fetch1</td><td style=text-align:center>需要线程数的地方</td><td style=text-align:center>指令或流水线所属的线程id</td></tr><tr><td style=text-align:center>streamseqnum</td><td style=text-align:center>S</td><td style=text-align:center>execute</td><td style=text-align:center>Fetch1、Fetch2、Execute（丢弃行/实例）</td><td style=text-align:center>Execute 选择的流序列号。流序列号在 Execue 中的 PC（分支、异常）发生变化后发生变化，用于区分分支前和分支后指令流。</td></tr><tr><td style=text-align:center>predictonseqnum</td><td style=text-align:center>fetch2</td><td style=text-align:center>fetch2(预测后丢弃行)</td><td style=text-align:center>predictonseqnum表示分支预测决策。Fetch2 会根据其最后遵循的分支预测来标记行/指令/。Fetch2 可以向 Fetch1 发出信号，告知它应更改其提取地址并使用新的预测序列号标记行（只有当 Fetch1 预期的流序列号与请求的序列号匹配时，它才会这样做）</td><td style=text-align:center>用于标识预测的指令流,由fetch2在分支预测的影响下附加</td></tr><tr><td style=text-align:center>lineseqnum</td><td style=text-align:center>fetch1</td><td style=text-align:center>debug</td><td style=text-align:center>该缓存行或提取该指令的行的行提取序列号。</td><td style=text-align:center>该指令所在代码行的序列号，即从该行获取的指令的序列号</td></tr><tr><td style=text-align:center>fetchseqnum</td><td style=text-align:center>fetch2</td><td style=text-align:center>fetch2 ( 作为分支的实例序列号)</td><td style=text-align:center>当行分解为指令时，Fetch2 指定的指令获取顺序。</td><td style=text-align:center>对于bubbles 指令，该值为0,对于指令流，该值按递增顺序分配</td></tr><tr><td style=text-align:center>execseqnum</td><td style=text-align:center>decode</td><td style=text-align:center>execute(j检查指令标示in queues / FU/LSQ)</td><td style=text-align:center>微操作分解后的指令顺序</td><td style=text-align:center>在micro-op分解之后，该序列号按照递增顺序分配给分解后的指令</td></tr></tbody></table></div><p>streamSeqnum的存在就是为了在分支预测失败之后可以把整条分支预测失败的路全部都冲刷掉 ，</p><p>每遇到一条分支 ， streamSeqnum都会进行+1 ， 然后赋值</p><p>predictionseqnum在分支预测为跳转的时候+1</p><p>streamseqnum在execute 阶段检测到stream change 的时候 + 1</p><p>fetchseqnum在得到dyninst 的时候都会+1</p><h3 id=minordyninst>MinorDynInst</h3><p>该类用于 <strong>Minor</strong> 核心的动态指令（Dynamic Instruction）。
<code>MinorDynInst</code> 实现了 <strong>BubbleIF</strong> 接口，并维护两种不同的序列号：</p><ul><li><code>fetchSeqNum</code>（指令获取序列号）</li><li><code>execSeqNum</code>（执行序列号），分别表示微操作分解前后的序列编号。</li></ul><p>一条指令的3种形式</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>Things</th><th style=text-align:left>Predicate</th><th style=text-align:left>Explanation</th></tr></thead><tbody><tr><td style=text-align:left>A bubble</td><td style=text-align:left>isBubble()</td><td style=text-align:left>no instruction at all, just a space-filler</td></tr><tr><td style=text-align:left>A fault</td><td style=text-align:left>isFault()</td><td style=text-align:left>a fault to pass down the pipeline in an insturction’s clothing</td></tr><tr><td style=text-align:left>A decoded instruction</td><td style=text-align:left>MinorDynInst::isInst()</td><td style=text-align:left>指令实际上在 Fetch2 中传递到 gem5 解码器，因此是完全解码的。MinorDynInst::staticInst 是解码后的指令形式。</td></tr></tbody></table></div><p><code>MinorDynInst</code> 主要用于 <strong>Minor 核心</strong> 的 <strong>动态指令管理</strong>，其功能包括：</p><ol><li>维护 <strong>流水线阶段的指令序列号</strong>（fetchSeqNum 和 execSeqNum）。</li><li>记录 <strong>指令的基本信息</strong>（ID、PC 地址、静态指令）。</li><li>处理 <strong>分支预测</strong>（目标地址、是否改变控制流）。</li><li>追踪 <strong>指令的执行状态</strong>（是否在 LSQ、功能单元索引、内存访问翻译异常）。</li><li>控制 <strong>乱序执行</strong> 和 <strong>条件执行</strong>。</li><li>记录 <strong>指令的提交延迟</strong> 和 <strong>寄存器相关信息</strong>。</li></ol><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>主要成员变量解析
</span></span><span style=display:flex><span>静态变量
</span></span><span style=display:flex><span>bubbleInst：
</span></span><span style=display:flex><span>这是一个原型 bubble 指令（气泡指令）。
</span></span><span style=display:flex><span>必须调用 MinorDynInst::init 进行初始化。
</span></span><span style=display:flex><span>指令基本信息
</span></span><span style=display:flex><span>staticInst：指向该指令的静态指令对象（StaticInstPtr）。
</span></span><span style=display:flex><span>id：指令 ID（InstId）。
</span></span><span style=display:flex><span>traceData：该指令的执行追踪信息（trace::InstRecord*）。
</span></span><span style=display:flex><span>pc：指令的获取（fetch）地址，存储为 PCStateBase 的智能指针。
</span></span><span style=display:flex><span>fault：如果该指令是一个伪装成指令的错误（fault），则该变量存储该错误信息。
</span></span><span style=display:flex><span>分支预测相关
</span></span><span style=display:flex><span>triedToPredict：
</span></span><span style=display:flex><span>如果该指令是控制指令或系统调用（sys call），是否尝试预测其目标地址。
</span></span><span style=display:flex><span>predictedTaken：
</span></span><span style=display:flex><span>该指令是否被预测为改变控制流。
</span></span><span style=display:flex><span>如果是，则后续指令将具有更新的 predictionSeqNum。
</span></span><span style=display:flex><span>predictedTarget：
</span></span><span style=display:flex><span>预测的 分支目标地址（智能指针）。
</span></span><span style=display:flex><span>执行阶段相关
</span></span><span style=display:flex><span>fuIndex：该指令分派到的功能单元（Functional Unit, FU）索引。
</span></span><span style=display:flex><span>inLSQ：该指令是否在 Load/Store Queue（LSQ） 中，而不是在功能单元中执行。
</span></span><span style=display:flex><span>translationFault：如果该指令涉及 内存访问，存储翻译异常信息。
</span></span><span style=display:flex><span>inStoreBuffer：该指令是否已发送到存储缓冲区（store buffer）。
</span></span><span style=display:flex><span>canEarlyIssue：
</span></span><span style=display:flex><span>是否可以乱序执行该指令。
</span></span><span style=display:flex><span>在本模型中，仅当 内存访问指令 需要提前发射，以便填补 指令获取延迟（fetch delay） 时才会发生。
</span></span><span style=display:flex><span>predicate：
</span></span><span style=display:flex><span>该指令是否 满足条件执行。
</span></span><span style=display:flex><span>memAccPredicate：
</span></span><span style=display:flex><span>该指令的 内存访问 是否满足条件执行（仅对 load/store 指令有意义）。
</span></span><span style=display:flex><span>数据依赖管理
</span></span><span style=display:flex><span>instToWaitFor：
</span></span><span style=display:flex><span>该指令依赖的最新指令的 execSeqNum（执行序列号）。
</span></span><span style=display:flex><span>主要用于 乱序执行 依赖关系的检查，例如 内存操作（memory ops） 的 initiateAcc（初始化访问）。
</span></span><span style=display:flex><span>流水线相关
</span></span><span style=display:flex><span>extraCommitDelay：该指令在流水线 提交阶段 的额外延迟。
</span></span><span style=display:flex><span>extraCommitDelayExpr：额外提交延迟的时间表达式（TimingExpr*）。
</span></span><span style=display:flex><span>minimumCommitCycle：
</span></span><span style=display:flex><span>指令一旦发射，extraCommitDelay 变为 最小提交周期（minimumCommitCycle）。
</span></span><span style=display:flex><span>该值用于 计算绝对时间内的提交延迟。
</span></span><span style=display:flex><span>寄存器相关
</span></span><span style=display:flex><span>flatDestRegIdx：
</span></span><span style=display:flex><span>展平后的目标寄存器索引。
</span></span><span style=display:flex><span>这样在 清除 scoreboard（记分板）时，可以使用和标记该指令时相同的寄存器索引。
</span></span></code></pre></div><h2 id=forwardlinedata>forwardlinedata</h2><p>ForwardLineData 用于将缓存行从 Fetch1 传递到 Fetch2。与 MinorDynInsts 一样，它们可以是气泡（<a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1ForwardLineData.html#a46789690719acf167be0a57c9d7d4f8f target=_blank rel=noopener>ForwardLineData::isBubble()</a>）、携带故障或可以包含由 Fetch1 获取的行（部分行）。ForwardLineData 携带的数据归从内存返回的 Packet 对象所有，并且明确进行内存管理，处理后必须删除（由 Fetch2 删除 Packet）。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ForwardLineData 类用于表示流水线前向传输的数据行（可能是完整的缓存行或其片段）。它包含地址信息、数据存储、故障标记等，支持深拷贝、数据分配和复用。以下是主要成员变量的作用：
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 基本标志</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bubbleFlag：标记该数据行是否为空（气泡），默认 true，表示没有有效数据。
</span></span><span style=display:flex><span>地址与指令信息
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lineBaseAddr：该缓存行的起始字节地址，可能小于等于 pc.instAddr<span style=color:#56b6c2>()</span>。
</span></span><span style=display:flex><span>pc：指向该行内第一条指令的 PC（程序计数器）。
</span></span><span style=display:flex><span>fetchAddr：该数据行的具体地址。
</span></span><span style=display:flex><span>lineWidth：该数据行的宽度，不依赖 data.size，显式指定。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 故障处理</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fault：表示该行数据是否存在故障。如果 <span style=color:#e06c75>bubbleFlag</span> <span style=color:#56b6c2>==</span> false，seqNums 仍然有效，但 data 无效。
</span></span><span style=display:flex><span><span style=color:#7f848e>##数据与存储信息</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>id：数据行的唯一标识，包含线程 ID、流 ID、预测 ID 等。
</span></span><span style=display:flex><span>line：指向存储该行数据的 uint8_t* 数组（line<span style=color:#56b6c2>[</span>0<span style=color:#56b6c2>]</span> 对应 pc.instAddr<span style=color:#56b6c2>()</span> 位置的数据）。
</span></span><span style=display:flex><span>packet：指向该数据行所属的数据包（Packet*）。
</span></span><span style=display:flex><span><span style=color:#7f848e>##构造与复制</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>默认构造函数 ForwardLineData<span style=color:#56b6c2>()</span> 创建一个空的数据行。
</span></span><span style=display:flex><span>复制构造函数 ForwardLineData<span style=color:#56b6c2>(</span>const ForwardLineData &amp;other<span style=color:#56b6c2>)</span> 允许深拷贝，包括 pc 克隆。
</span></span><span style=display:flex><span>赋值运算符 <span style=color:#e06c75>operator</span><span style=color:#56b6c2>=</span> 进行成员变量的逐一复制，并重新分配 pc。
</span></span><span style=display:flex><span>析构函数 ~ForwardLineData<span style=color:#56b6c2>()</span> 释放 line 指针。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 辅助方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>isFault<span style=color:#56b6c2>()</span>：判断该行数据是否发生故障（fault !<span style=color:#56b6c2>=</span> NoFault）。
</span></span><span style=display:flex><span>setFault<span style=color:#56b6c2>(</span>Fault fault_<span style=color:#56b6c2>)</span>：设置故障，并可能清除 bubbleFlag。
</span></span><span style=display:flex><span>allocateLine<span style=color:#56b6c2>(</span>unsigned int width_<span style=color:#56b6c2>)</span>：为数据行分配指定宽度的存储空间。
</span></span><span style=display:flex><span>adoptPacketData<span style=color:#56b6c2>(</span>Packet *packet<span style=color:#56b6c2>)</span>：直接使用 packet 内的数据，而不重新分配存储空间。
</span></span><span style=display:flex><span>freeLine<span style=color:#56b6c2>()</span>：释放 line 数据，注意 line 可能被多个 ForwardLineData 实例共享。
</span></span><span style=display:flex><span>bubble<span style=color:#56b6c2>()</span>：创建一个气泡数据行（默认无效数据）。
</span></span><span style=display:flex><span>isBubble<span style=color:#56b6c2>()</span>：检查当前数据行是否是气泡（bubbleFlag <span style=color:#56b6c2>==</span> true）。
</span></span><span style=display:flex><span>reportData<span style=color:#56b6c2>(</span>std::ostream &amp;os<span style=color:#56b6c2>)</span> const：输出数据行的详细信息（用于调试或日志记录）。
</span></span></code></pre></div><h3 id=forwardinstdata>forwardInstData</h3><p><a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1ForwardInstData.html#ab54a61c683376aaf5a12ea19ab758340 target=_blank rel=noopener>ForwardInstData 的 ForwardInstData:: insts</a>向量 中最多可包含<a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1ForwardInstData.html#ad5db21f655f2f1dfff69e6f6d5cc606e target=_blank rel=noopener>ForwardInstData::width()</a>指令 。此结构用于在 Fetch2、Decode 和 Execute 之间传送指令，以及在 Decode 和 Execute 中存储输入缓冲区向量。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ForwardInstData 类用于流水线级指令数据的前向传输，主要在 Fetch2、Decode 和 Execute 阶段之间传递指令。该类支持指令批处理，并包含异常处理信息。以下是其核心成员及功能：
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>##指令存储</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>insts<span style=color:#56b6c2>[</span>MAX_FORWARD_INSTS<span style=color:#56b6c2>]</span>：存储传输的指令，使用 MinorDynInstPtr 进行引用计数管理。
</span></span><span style=display:flex><span>numInsts：当前有效指令的数量，决定 insts 数组中哪些位置包含有效指令。
</span></span><span style=display:flex><span><span style=color:#7f848e>##线程信息</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>threadId：与这些指令关联的线程 ID。
</span></span><span style=display:flex><span><span style=color:#7f848e>##构造与复制</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ForwardInstData<span style=color:#56b6c2>(</span>unsigned int <span style=color:#e06c75>width</span> <span style=color:#56b6c2>=</span> 0, ThreadID <span style=color:#e06c75>tid</span> <span style=color:#56b6c2>=</span> InvalidThreadID<span style=color:#56b6c2>)</span>：构造指定宽度 width 和线程 ID tid 的 ForwardInstData 对象。
</span></span><span style=display:flex><span>ForwardInstData<span style=color:#56b6c2>(</span>const ForwardInstData &amp;src<span style=color:#56b6c2>)</span>：拷贝构造函数，复制 src 对象的指令数组及相关信息。
</span></span><span style=display:flex><span><span style=color:#e06c75>operator</span> <span style=color:#56b6c2>=(</span>const ForwardInstData &amp;src<span style=color:#56b6c2>)</span>：重载赋值运算符，仅复制 numInsts 指定的有效指令。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 辅助方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>width<span style=color:#56b6c2>()</span>：返回当前 ForwardInstData 对象携带的有效指令数量（即 numInsts）。
</span></span><span style=display:flex><span>resize<span style=color:#56b6c2>(</span>unsigned int width<span style=color:#56b6c2>)</span>：调整 ForwardInstData 的指令存储大小，并用“气泡”填充。
</span></span><span style=display:flex><span>bubbleFill<span style=color:#56b6c2>()</span>：将 insts 数组从索引 <span style=color:#d19a66>0</span> 到 width<span style=color:#56b6c2>()</span> - <span style=color:#d19a66>1</span> 位置填充为“气泡”（无效指令）。
</span></span><span style=display:flex><span>isBubble<span style=color:#56b6c2>()</span>：判断 ForwardInstData 是否为空（即所有指令都是“气泡”）。
</span></span><span style=display:flex><span>reportData<span style=color:#56b6c2>(</span>std::ostream &amp;os<span style=color:#56b6c2>)</span> const：输出当前对象的详细信息（用于调试或日志记录）。
</span></span></code></pre></div><h3 id=branchdata>BranchData</h3><p><code>BranchData</code> 是一个用于在 <strong>Execute</strong> 和 <strong>Fetch1</strong> 阶段之间传递分支信息的数据结构。它主要用于处理地址流（stream）的改变，例如分支预测、中断、暂停线程等场景</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#7f848e>## 1. 类的核心功能</span>
</span></span><span style=display:flex><span>BranchData 类的主要作用是：
</span></span><span style=display:flex><span>传递分支信息，包括分支的原因、目标地址、线程 ID 等。
</span></span><span style=display:flex><span>判断分支是否是流改变（isStreamChange）或真正的分支（isBranch）。
</span></span><span style=display:flex><span>提供气泡（bubble）接口，用于表示无效或空的分支信息。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 2. 枚举类型 Reason</span>
</span></span><span style=display:flex><span>Reason 枚举定义了分支的原因，分为两类：
</span></span><span style=display:flex><span>不改变流的分支：
</span></span><span style=display:flex><span>NoBranch：无分支（气泡）。
</span></span><span style=display:flex><span>CorrectlyPredictedBranch：正确预测的分支，仅用于传递信息。
</span></span><span style=display:flex><span>改变流的分支：
</span></span><span style=display:flex><span>UnpredictedBranch：未预测的分支。
</span></span><span style=display:flex><span>BranchPrediction：基于 Fetch2 的分支预测。
</span></span><span style=display:flex><span>BadlyPredictedBranchTarget：预测的目标地址错误。
</span></span><span style=display:flex><span>BadlyPredictedBranch：错误的分支预测（实际未分支）。
</span></span><span style=display:flex><span>SuspendThread：暂停线程的取指。
</span></span><span style=display:flex><span>Interrupt：中断引起的分支。
</span></span><span style=display:flex><span>HaltFetch：停止取指（通常用于流水线排空）。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 3. 静态方法</span>
</span></span><span style=display:flex><span>isStreamChange：
</span></span><span style=display:flex><span>判断某个 Reason 是否会导致流的改变。例如，UnpredictedBranch、BranchPrediction 等会改变流，而 NoBranch 不会。
</span></span><span style=display:flex><span>isBranch：
</span></span><span style=display:flex><span>判断某个 Reason 是否是一个“真正的”分支（即改变流且不是暂停或唤醒操作）。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>##4. 成员变量</span>
</span></span><span style=display:flex><span>reason：
</span></span><span style=display:flex><span>分支的原因，类型为 Reason 枚举。
</span></span><span style=display:flex><span>threadId：
</span></span><span style=display:flex><span>与分支关联的线程 ID。如果无效，则为 InvalidThreadID。
</span></span><span style=display:flex><span>newStreamSeqNum 和 newPredictionSeqNum：
</span></span><span style=display:flex><span>新流的序列号和新预测的序列号，用于标识分支的目标流。
</span></span><span style=display:flex><span>target：
</span></span><span style=display:flex><span>分支的目标地址，类型为 std::unique_ptr&lt;PCStateBase&gt;，表示程序计数器（PC）状态。
</span></span><span style=display:flex><span>inst：
</span></span><span style=display:flex><span>导致分支的指令，类型为 MinorDynInstPtr。如果是气泡，则表示没有指令。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 5. 构造函数和拷贝控制</span>
</span></span><span style=display:flex><span>默认构造函数：
</span></span><span style=display:flex><span>创建一个气泡（NoBranch）的 BranchData 对象。
</span></span><span style=display:flex><span>带参构造函数：
</span></span><span style=display:flex><span>初始化所有成员变量，包括分支原因、线程 ID、流序列号、目标地址和指令。
</span></span><span style=display:flex><span>拷贝构造函数和赋值运算符：
</span></span><span style=display:flex><span>支持深拷贝，特别是对 target 的拷贝。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 6. 气泡接口</span>
</span></span><span style=display:flex><span>bubble<span style=color:#56b6c2>()</span>：
</span></span><span style=display:flex><span>返回一个表示气泡的 BranchData 对象（reason <span style=color:#56b6c2>==</span> NoBranch）。
</span></span><span style=display:flex><span>isBubble<span style=color:#56b6c2>()</span>：
</span></span><span style=display:flex><span>判断当前对象是否是气泡。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 7. 流改变和分支判断</span>
</span></span><span style=display:flex><span>isStreamChange<span style=color:#56b6c2>()</span>：
</span></span><span style=display:flex><span>判断当前分支是否会导致流的改变。
</span></span><span style=display:flex><span>isBranch<span style=color:#56b6c2>()</span>：
</span></span><span style=display:flex><span>判断当前分支是否是一个“真正的”分支。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 8. 调试和报告接口</span>
</span></span><span style=display:flex><span>reportData<span style=color:#56b6c2>()</span>：
</span></span><span style=display:flex><span>将分支信息输出到指定的输出流（std::ostream），用于调试或日志记录。
</span></span><span style=display:flex><span>operator&lt;&lt;：
</span></span><span style=display:flex><span>重载了 &lt;&lt; 运算符，用于打印 BranchData 的内容，方便调试。
</span></span></code></pre></div><h3 id=fetch1fetchrequest>fetch1::fetchRequest</h3><p>FetchRequests 表示 I-cache 行提取请求。它们用于 Fetch1 的内存队列，并 在遍历内存系统时被推送到Packet::senderState或从中弹出。</p><p>FetchRequests 包含一个用于该获取访问的内存系统请求（mem/request.hh ）、一个数据包（Packet， mem/packet.hh）（如果请求到达内存）和一个可以用 TLB 源预取故障（如果有）填充的故障字段。</p><p><code>FetchRequest</code> 负责管理取指请求的队列和状态转换，涵盖从 TLB 查询到内存访问的整个过程。它继承了 <code>BaseMMU::Translation</code>（用于 TLB 查询）和 <code>Packet::SenderState</code>（用于封装成 <code>Packet</code>），以支持多阶段的取指请求处理。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#7f848e>## 1. 主要成员变量</span>
</span></span><span style=display:flex><span>状态管理
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FetchRequestState state：表示当前取指请求的状态，包括：
</span></span><span style=display:flex><span>NotIssued（未发出）
</span></span><span style=display:flex><span>InTranslation（正在翻译，已提交到 ITLB）
</span></span><span style=display:flex><span>Translated（翻译完成）
</span></span><span style=display:flex><span>RequestIssuing（请求已发往内存）
</span></span><span style=display:flex><span>Complete（完成，可能是成功取回指令或发生错误）
</span></span><span style=display:flex><span>标识与指令信息
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>InstId id：该取指请求对应的指令 ID。
</span></span><span style=display:flex><span>Addr pc：要取指的 PC 地址。
</span></span><span style=display:flex><span>数据包与请求
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PacketPtr packet：存储当前请求的 Packet，在内存系统返回数据后可能会被更新。
</span></span><span style=display:flex><span>RequestPtr request：底层的请求对象，表示当前 FetchRequest 的内存请求。
</span></span><span style=display:flex><span>错误信息
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fault fault：如果取指过程中发生错误（例如缺页），会存储在这里。
</span></span><span style=display:flex><span>关联的 Fetch1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fetch1 &amp;fetch：该请求归属于的 Fetch1 取指单元。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 2. 主要方法</span>
</span></span><span style=display:flex><span>请求管理
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void makePacket<span style=color:#56b6c2>()</span>：创建用于内存事务的 Packet。
</span></span><span style=display:flex><span>bool isComplete<span style=color:#56b6c2>()</span> const：判断该取指请求是否已完成，即 <span style=color:#e06c75>state</span> <span style=color:#56b6c2>==</span> Complete。
</span></span><span style=display:flex><span>bool isDiscardable<span style=color:#56b6c2>()</span> const：判断该请求是否可以丢弃，而不会影响 TLB 查询或内存访问的执行。
</span></span><span style=display:flex><span>MMU 相关（TLB 处理）
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void markDelayed<span style=color:#56b6c2>()</span>：表示 TLB 响应被延迟（但不做实际处理）。
</span></span><span style=display:flex><span>void finish<span style=color:#56b6c2>(</span>const Fault &amp;fault_, const RequestPtr &amp;request_, ThreadContext *tc, BaseMMU::Mode mode<span style=color:#56b6c2>)</span>：
</span></span><span style=display:flex><span>当 ITLB 响应返回后，该方法被调用，更新 fault 和 request，然后将请求传递到下一级端口进行内存访问。
</span></span><span style=display:flex><span>调试与日志
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void reportData<span style=color:#56b6c2>(</span>std::ostream &amp;os<span style=color:#56b6c2>)</span> const：输出该 FetchRequest 对象的详细信息（用于日志记录和调试）。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 3. 生命周期管理</span>
</span></span><span style=display:flex><span>构造函数 FetchRequest<span style=color:#56b6c2>(</span>Fetch1 &amp;fetch_, InstId id_, Addr pc_<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span>初始化 fetch、id、pc，状态设为 NotIssued。
</span></span><span style=display:flex><span>创建 Request 对象并赋值给 request。
</span></span><span style=display:flex><span>析构函数 ~FetchRequest<span style=color:#56b6c2>()</span>
</span></span><span style=display:flex><span>负责清理 FetchRequest 相关的资源（如 packet 和 request）。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 4. 取指请求处理流程</span>
</span></span><span style=display:flex><span>请求创建
</span></span><span style=display:flex><span>FetchRequest 对象被创建，初始状态为 NotIssued。
</span></span><span style=display:flex><span>TLB 查询
</span></span><span style=display:flex><span>请求进入 ITLB，状态变为 InTranslation。
</span></span><span style=display:flex><span>地址翻译完成
</span></span><span style=display:flex><span>ITLB 返回结果，调用 finish<span style=color:#56b6c2>()</span> 方法，状态变为 Translated。
</span></span><span style=display:flex><span>发送到内存
</span></span><span style=display:flex><span>取指请求被封装成 Packet 并提交到内存，状态变为 RequestIssuing。
</span></span><span style=display:flex><span>等待内存响应
</span></span><span style=display:flex><span>若请求需要重试（如 IcacheNeedsRetry），则保持在队列中。
</span></span><span style=display:flex><span>请求完成
</span></span><span style=display:flex><span>当数据返回后，FetchRequest 被更新，状态变为 Complete，可以传递到 Fetch2 处理阶段。
</span></span></code></pre></div><h2 id=pipline>pipline</h2><pre tabindex=0><code>------------------------------------------------------------------------------
    Key:

    [] : inter-stage BufferBuffer
    ,--.
    |  | : pipeline stage
    `--&#39;
    ---&gt; : forward communication
    &lt;--- : backward communication

    rv : reservation information for input buffers

                ,------.     ,------.     ,------.     ,-------.
 (from  --[]-v-&gt;|Fetch1|-[]-&gt;|Fetch2|-[]-&gt;|Decode|-[]-&gt;|Execute|--&gt; (to Fetch1
 Execute)    |  |      |&lt;-[]-|      |&lt;-rv-|      |&lt;-rv-|       |     &amp; Fetch2)
             |  `------&#39;&lt;-rv-|      |     |      |     |       |
             `--------------&gt;|      |     |      |     |       |
                             `------&#39;     `------&#39;     `-------&#39;
------------------------------------------------------------------------------
</code></pre><p>四个流水线阶段通过MinorBuffer FIFO（buffer.hh，最终源自TimeBuffer）结构连接在一起，该结构允许对阶段间延迟进行建模。在前向相邻阶段之间有一个MinorBuffers（例如：从 Fetch1 到 Fetch2 的线路），而在 Fetch2 和 Fetch1 之间，在后向有一个缓冲区，用于承载分支预测。</p><p>Fetch2、Decode 和 Execute 阶段具有输入缓冲区，每个周期都可以接受来自上一阶段的输入数据，如果该阶段尚未准备好处理该数据，则可以保留该数据。输入缓冲区以与接收时相同的形式存储数据，因此 Decode 和 Execute 的输入缓冲区包含来自其前一阶段的输出指令向量（ForwardInstData( pipe_data.hh )），其中指令和气泡位于与单个缓冲区条目相同的位置。</p><p>阶段输入缓冲区为其前一阶段提供了一个可保留（buffer.hh）接口，以允许在其输入缓冲区中保留插槽，并向后传达其输入缓冲区占用情况，以允许前一阶段计划是否应该在给定的周期内进行输出。</p><h3 id=event-handling-minoractivityrecorder>Event handling: MinorActivityRecorder</h3><p>Minor 本质上是一个可循环调用的模型，具有根据管道活动跳过循环的能力。外部事件主要由回调接收（例如Fetch1::IcachePort::recvTimingResp），并导致管道被唤醒以服务推进请求队列。</p><p>Ticked (sim/ticked.hh) 是一个基类，它将评估成员函数和提供的SimObject结合在一起。它提供了一个Ticked::start /stop接口来启动和暂停定期发出的时钟事件。Pipeline 是 Ticked 的派生类。</p><p>在评估调用期间(evaluate call)，阶段可以通过调用MinorCPU::activityRecorder ->activity()（针对不可调用的相关活动）或 MinorCPU::wakeupOnEvent() （用于阶段回调相关的‘唤醒’活动）。</p><p>Pipeline::evaluate包含对每个单元进行评估的调用以及对管道空闲的测试，如果没有单元发出信号表示它可能在下一个周期变为活动状态，则可以关闭时钟滴答。</p><p>在管道 ( pipeline.hh) 中，阶段以相反的顺序进行评估（因此 ::evaluate 也将以相反的顺序进行评估），并且它们的反向数据可以在每个周期写入后立即读取，从而使输出决策“完美”（允许同步停止整个管道）。从 Fetch2 到 Fetch1 的分支预测也可以在 0 个周期内传输，从而使 fetch1ToFetch2BackwardDelay 成为唯一可以设置为低至 0 个周期的可配置延迟。</p><p>可以调用MinorCPU ::activateContext和MinorCPU::suspendContext接口来启动和暂停线程（MT 意义上的线程）以及启动和暂停管道。执行指令可以调用此接口（间接通过 ThreadContext）来闲置 CPU/其线程。</p><h2 id=cpucc>cpu.cc</h2><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>MinorCPU 是一个顺序执行（in-order）的 CPU 模型，包含四个固定的流水线阶段：
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fetch1：从内存取指令行
</span></span><span style=display:flex><span>Fetch2：将指令行分解为宏操作（macro-ops）
</span></span><span style=display:flex><span>Decode：将宏操作进一步分解为微操作（micro-ops）
</span></span><span style=display:flex><span>Execute：执行微操作
</span></span><span style=display:flex><span>整个流水线由 minor::Pipeline 进行管理，MinorCPU 继承自 BaseCPU，但它本身不直接持有 exec_context，而是由 minor::ExecContext 负责维护执行上下文。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 1. 主要成员变量</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## pipeline </span>
</span></span><span style=display:flex><span>minor::Pipeline *pipeline：管理 CPU 的流水线，协调四个阶段的执行。
</span></span><span style=display:flex><span>minor::MinorActivityRecorder *activityRecorder：记录流水线的活动状态，CPU 通过它管理空闲行为。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 线程管理</span>
</span></span><span style=display:flex><span>std::vector&lt;minor::MinorThread *&gt; threads：存储 CPU 运行的线程，每个线程都有自己的 ThreadContext。
</span></span><span style=display:flex><span>enums::ThreadPolicy threadPolicy：线程调度策略，如 RoundRobin（轮询调度）、Random（随机调度）等。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 端口</span>
</span></span><span style=display:flex><span>MinorCPUPort：MinorCPU 的请求端口基类，由 Fetch1 和 Execute 创建派生类用于指令/数据访问。
</span></span><span style=display:flex><span>Port &amp;getDataPort<span style=color:#56b6c2>()</span> override：获取数据端口的引用。
</span></span><span style=display:flex><span>Port &amp;getInstPort<span style=color:#56b6c2>()</span> override：获取指令端口的引用。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 调度与随机数生成</span>
</span></span><span style=display:flex><span>Random::RandomPtr <span style=color:#e06c75>rng</span> <span style=color:#56b6c2>=</span> Random::genRandom<span style=color:#56b6c2>()</span>;：用于生成随机数（如随机调度线程）。
</span></span><span style=display:flex><span>std::vector&lt;ThreadID&gt; roundRobinPriority<span style=color:#56b6c2>(</span>ThreadID priority<span style=color:#56b6c2>)</span>：基于轮询方式生成线程优先级队列。
</span></span><span style=display:flex><span>std::vector&lt;ThreadID&gt; randomPriority<span style=color:#56b6c2>()</span>：基于随机方式生成线程优先级队列。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 模拟相关</span>
</span></span><span style=display:flex><span>minor::MinorStats stats：存储 CPU 的统计信息。
</span></span><span style=display:flex><span>Counter totalInsts<span style=color:#56b6c2>()</span> const override;：返回指令执行总数。
</span></span><span style=display:flex><span>Counter totalOps<span style=color:#56b6c2>()</span> const override;：返回操作数总数。
</span></span><span style=display:flex><span>void tick<span style=color:#56b6c2>()</span>：更新 CPU 的周期计数，流水线的时钟管理由 Pipeline 处理。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>## 2. 主要方法</span>
</span></span><span style=display:flex><span>（1）初始化 &amp; 状态管理
</span></span><span style=display:flex><span>void init<span style=color:#56b6c2>()</span> override;：CPU 初始化。
</span></span><span style=display:flex><span>void startup<span style=color:#56b6c2>()</span> override;：CPU 启动时调用。
</span></span><span style=display:flex><span>void wakeup<span style=color:#56b6c2>(</span>ThreadID tid<span style=color:#56b6c2>)</span> override;：激活指定线程。
</span></span><span style=display:flex><span>（2）线程控制
</span></span><span style=display:flex><span>void activateContext<span style=color:#56b6c2>(</span>ThreadID thread_id<span style=color:#56b6c2>)</span> override;：激活指定线程。
</span></span><span style=display:flex><span>void suspendContext<span style=color:#56b6c2>(</span>ThreadID thread_id<span style=color:#56b6c2>)</span> override;：暂停指定线程。
</span></span><span style=display:flex><span>（3）序列化
</span></span><span style=display:flex><span>void serializeThread<span style=color:#56b6c2>(</span>CheckpointOut &amp;cp, ThreadID tid<span style=color:#56b6c2>)</span> const override;
</span></span><span style=display:flex><span>void unserializeThread<span style=color:#56b6c2>(</span>CheckpointIn &amp;cp, ThreadID tid<span style=color:#56b6c2>)</span> override;
</span></span><span style=display:flex><span>void serialize<span style=color:#56b6c2>(</span>CheckpointOut &amp;cp<span style=color:#56b6c2>)</span> const override;
</span></span><span style=display:flex><span>void unserialize<span style=color:#56b6c2>(</span>CheckpointIn &amp;cp<span style=color:#56b6c2>)</span> override;
</span></span><span style=display:flex><span>（4）切换 CPU 上下文
</span></span><span style=display:flex><span>void switchOut<span style=color:#56b6c2>()</span> override;：CPU 切换出当前状态。
</span></span><span style=display:flex><span>void takeOverFrom<span style=color:#56b6c2>(</span>BaseCPU *old_cpu<span style=color:#56b6c2>)</span> override;：从 old_cpu 继承状态。
</span></span><span style=display:flex><span>（5）流水线控制
</span></span><span style=display:flex><span>DrainState drain<span style=color:#56b6c2>()</span> override;：CPU 进入 drain（排空）状态。
</span></span><span style=display:flex><span>void drainResume<span style=color:#56b6c2>()</span> override;：恢复 CPU 运行状态。
</span></span><span style=display:flex><span>void signalDrainDone<span style=color:#56b6c2>()</span>;：通知 Pipeline 触发 drain 完成事件。
</span></span><span style=display:flex><span>void wakeupOnEvent<span style=color:#56b6c2>(</span>unsigned int stage_id<span style=color:#56b6c2>)</span>;：当流水线阶段因事件重新激活时调用。
</span></span><span style=display:flex><span><span style=color:#7f848e>## 3. 执行流程</span>
</span></span><span style=display:flex><span>初始化
</span></span><span style=display:flex><span>MinorCPU 通过 init<span style=color:#56b6c2>()</span> 和 startup<span style=color:#56b6c2>()</span> 进行初始化，创建 Pipeline 并设置活动记录器。
</span></span><span style=display:flex><span>线程状态 threads 被创建，每个线程都有 ThreadContext。
</span></span><span style=display:flex><span>取指
</span></span><span style=display:flex><span>Fetch1 通过 getInstPort<span style=color:#56b6c2>()</span> 访问指令存储器，从 ITLB 进行地址翻译。
</span></span><span style=display:flex><span>指令行被 Fetch2 解析成宏操作，进入 Decode 阶段。
</span></span><span style=display:flex><span>解码
</span></span><span style=display:flex><span>Decode 将宏操作拆分为微操作（micro-ops），推送到 Execute。
</span></span><span style=display:flex><span>执行
</span></span><span style=display:flex><span>Execute 执行微操作，可能涉及访存（getDataPort<span style=color:#56b6c2>()</span>）。
</span></span><span style=display:flex><span>若发生访存重试，则 Pipeline 处理重试逻辑。
</span></span><span style=display:flex><span>线程调度
</span></span><span style=display:flex><span>采用 roundRobinPriority<span style=color:#56b6c2>()</span> 或 randomPriority<span style=color:#56b6c2>()</span> 选择下一个线程执行。
</span></span><span style=display:flex><span>流水线控制
</span></span><span style=display:flex><span>wakeupOnEvent<span style=color:#56b6c2>(</span>stage_id<span style=color:#56b6c2>)</span>：当某个流水线阶段因事件重新激活时触发。
</span></span><span style=display:flex><span>signalDrainDone<span style=color:#56b6c2>()</span>：在 DrainState 变为 Complete 时通知 Pipeline。
</span></span><span style=display:flex><span>4. 关键特性
</span></span><span style=display:flex><span>顺序执行
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>固定四级流水线，确保执行顺序严格按照 取指 -&gt; 译码 -&gt; 执行 的顺序进行。
</span></span><span style=display:flex><span>线程调度
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>支持 Round Robin 和 Random 调度策略，适用于多线程环境。
</span></span><span style=display:flex><span>可扩展流水线
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>采用 minor::Pipeline 进行流水线管理，可在 Fetch1、Fetch2、Decode 和 Execute 之间添加自定义处理逻辑。
</span></span><span style=display:flex><span>支持 Checkpoint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>通过 serialize<span style=color:#56b6c2>()</span> 和 unserialize<span style=color:#56b6c2>()</span> 进行状态快照存储和恢复。
</span></span></code></pre></div><h2 id=fetch1>fetch1</h2><p>Fetch1负责从 I-cache 中获取缓存行或部分缓存行，并将它们传递给Fetch2以分解为指令。它可以从 Execute和 Fetch2接收“流更改”指示，以发出信号指示它应更改其内部获取地址，并使用新的流或预测序列号标记新获取的行。当 Execute 和 Fetch2同时发出流更改信号时，Fetch1将接受 Execute的更改。</p><p>Fetch1发出的每一行都会带有唯一的行序列号，可用于调试流变化。</p><p>从 I-cache 提取数据时，Fetch1 会请求从当前提取地址 (Fetch1::pc) 到参数 fetch1LineSnapWidth 中设置的“数据快照”大小末尾的数据。后续的自主行提取将在快照边界提取整行，大小为 fetch1LineWidth。</p><p>Fetch1仅在Fetch2输入缓冲区中预留空间时才会启动内存提取。该输入缓冲区为系统提供提取队列/LFL。</p><p>Fetch1 包含两个队列：请求和传输，用于处理转换行提取地址（通过 TLB）的阶段以及适应对内存的提取请求/响应。</p><p>一旦通过调用 itb->translateTiming 将来自Fetch1的获取请求发送到 ITLB，它们就会作为新分配的 FetchRequest 对象推送到请求队列中。</p><p>TLB 的响应将请求从请求队列移至传输队列。如果每个队列中有多个条目，则可能会获得不在请求队列头部的请求的 TLB 响应。在这种情况下，TLB 响应在请求对象中被标记为状态更改为已翻译，而将请求推进到传输（和内存系统）则留给对Fetch1::stepQueues 的调用 ，该调用在收到任何事件后的循环中调用。</p><p>Fetch1::tryToSendToTransfers — 布局：文档标题：执行基础文档：gem5 文档父级：cpu_models 永久链接：/documentation/general_docs/cpu_models/execution_basics —</p><p>负责在两个队列之间移动请求并将请求发送到内存。失败的 TLB 查找（预取中止）将继续占用队列中的空间，直到它们在传输的开头被恢复。</p><p>来自内存的响应将请求对象状态更改为“Complete”，并且 Fetch1::evaluate 可以获取响应数据，将其打包在ForwardLineData对象中，并将其转发到Fetch2的输入缓冲区。</p><p>由于Fetch2::inputBuffer中始终保留空间，将输入缓冲区的大小设置为 1 会导致非预取行为。</p><p>当发生流的改变时，已翻译的请求队列成员和已完成的传输队列成员可以被无条件丢弃，为新的传输让路。</p><h3 id=fetch1evaluate>fetch1::evaluate</h3><ul><li><strong>功能</strong>：<ul><li>这是 Fetch1 阶段的核心函数，负责处理分支信息、取指操作以及缓存队列的管理。</li><li>根据来自 <strong>Execute</strong> 和 <strong>Fetch2</strong> 的分支信息调整指令流。</li><li>在未达到取指限制时，选择一个线程进行取指操作。</li><li>处理缓存队列中的请求，并将完成的取指结果传递给下一阶段。</li></ul></li><li><strong>关键逻辑</strong>：<ul><li>检查每个线程是否被阻塞。</li><li>处理来自 Execute 和 Fetch2 的分支信息，决定是否改变指令流。execute的改变优先</li><li>调用 <code>fetchLine()</code> 生成取指请求。 具体需要检测当前在in-flight 的请求数量是否为达到取指限制，如果未达到，调用fetchLine ,并获取nextStageReserve的一个槽位</li><li>调用 <code>stepQueues()</code> 处理缓存队列中的请求。</li><li>处理完成的取指请求，并将结果传递给下一阶段。具体就是先判断指令是否会被丢弃 ， 然后进行相应的处理 。</li><li>标记流水线为活动状态</li></ul></li></ul><h3 id=fetch1changestream>fetch1::changeStream</h3><p>根据分支信息更新线程的PC, streamSeqNum 和 predictionSeqnum ， 更新线程状态， 更新取指地址</p><p>streamSeqNum在changeStream 要么不变，要么增加 ，predictionSeqnum 可以减少</p><h3 id=fetch1fetchline>fetch1::fetchLine</h3><ul><li>为选中的线程生成取指请求。</li><li>具体操作包括：<ol><li>计算对齐的取指地址。</li><li>创建 <code>FetchRequest</code> 对象，表示一个取指请求。</li><li>提交地址翻译请求到 ITLB。</li><li>将请求放入 <code>requests</code> 队列。</li></ol></li></ul><p>每fetchLine 一次， lineSeqNum 都会 + 1 ，</p><p>具体request 再说</p><h3 id=fetch1stepqueues>fetch1::stepQueues</h3><ul><li><strong>功能</strong>：<ul><li>推进缓存队列中的请求，处理内存系统中的取指请求。</li><li>将已翻译的请求从 <code>requests</code> 队列移动到 <code>transfers</code> 队列。</li></ul></li><li><strong>关键逻辑</strong>：<ul><li>检查 <code>requests</code> 队列中的请求是否已完成翻译。</li><li>调用 <code>tryToSendToTransfers()</code> 将请求移动到 <code>transfers</code> 队列。</li></ul></li></ul><h3 id=fetch1requestisdiscardable>fetch1::request::isDiscardable</h3><ul><li>判断请求是否需要丢弃。</li><li>如果请求的流序列号或预测序列号与当前线程的状态不匹配，则请求属于旧的指令流，需要丢弃。</li></ul><h3 id=fetch1processresponse>fetch1::processResponse</h3><p>处理取指响应，将取指结果封装为 <code>ForwardLineData</code>，并传递给下一阶段（Fetch2）</p><h3 id=fetch1popanddiscard>fetch1::popanddiscard</h3><p>从队列中移除并释放已处理的请求 ，就是吧transfers 的第一个移除了</p><h3 id=fetch1transfers>fetch1::transfers</h3><p><code>transfers</code> 队列是 <strong>Fetch1</strong> 阶段中的一个关键数据结构，用于存放已经完成地址翻译（ITLB 翻译）并准备发送到内存系统的取指请求，或者已经从内存系统返回的取指响应。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>FetchRequest</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>BaseMMU</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>Translation</span>, <span style=color:#c678dd>public</span> <span style=color:#e06c75>Packet</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>SenderState</span> {
</span></span><span style=display:flex><span>  <span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>enum</span> <span style=color:#e5c07b>FetchRequestState</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>NotIssued</span>,       <span style=color:#7f848e>// 未发出
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>InTranslation</span>,   <span style=color:#7f848e>// 正在翻译
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>Translated</span>,      <span style=color:#7f848e>// 翻译完成
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>RequestIssuing</span>,  <span style=color:#7f848e>// 正在发出
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>Complete</span>         <span style=color:#7f848e>// 完成
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>FetchRequestState</span> <span style=color:#e06c75>state</span>;  <span style=color:#7f848e>// 请求状态
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>InstId</span> <span style=color:#e06c75>id</span>;                <span style=color:#7f848e>// 请求 ID
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>PacketPtr</span> <span style=color:#e06c75>packet</span>;         <span style=color:#7f848e>// 内存请求包
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>RequestPtr</span> <span style=color:#e06c75>request</span>;       <span style=color:#7f848e>// 内存请求
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>Addr</span> <span style=color:#e06c75>pc</span>;                  <span style=color:#7f848e>// 取指地址
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>Fault</span> <span style=color:#e06c75>fault</span>;              <span style=color:#7f848e>// 错误信息
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>transfers 队列的生命周期
</span></span><span style=display:flex><span><span style=color:#7f848e>##（1）请求进入 transfers 队列</span>
</span></span><span style=display:flex><span>条件：
</span></span><span style=display:flex><span>取指请求完成地址翻译（ITLB 翻译）。
</span></span><span style=display:flex><span>取指请求准备好发送到内存系统。
</span></span><span style=display:flex><span>操作：
</span></span><span style=display:flex><span>将请求从 requests 队列移动到 transfers 队列。
</span></span><span style=display:flex><span><span style=color:#7f848e>##（2）请求发送到内存系统</span>
</span></span><span style=display:flex><span>条件：
</span></span><span style=display:flex><span>取指请求在 transfers 队列中。
</span></span><span style=display:flex><span>内存系统可以接受新的请求。
</span></span><span style=display:flex><span>操作：
</span></span><span style=display:flex><span>将请求发送到内存系统。
</span></span><span style=display:flex><span><span style=color:#7f848e>##（3）取指响应返回</span>
</span></span><span style=display:flex><span>条件：
</span></span><span style=display:flex><span>内存系统返回取指响应。
</span></span><span style=display:flex><span>操作：
</span></span><span style=display:flex><span>将响应放入 transfers 队列。
</span></span><span style=display:flex><span><span style=color:#7f848e>##（4）处理取指响应</span>
</span></span><span style=display:flex><span>条件：
</span></span><span style=display:flex><span>取指响应在 transfers 队列中。
</span></span><span style=display:flex><span>响应已完成（state <span style=color:#56b6c2>==</span> Complete）。
</span></span><span style=display:flex><span>操作：
</span></span><span style=display:flex><span>判断响应是否需要丢弃（如属于旧的指令流）。
</span></span><span style=display:flex><span>如果不需要丢弃，则将取指结果传递给下一阶段（Fetch2）。
</span></span><span style=display:flex><span>从 transfers 队列中移除已处理的响应。
</span></span></code></pre></div><h2 id=fetch2>fetch2</h2><p>Fetch2 将 Fetch1 的一行接收到其输入缓冲区中。该缓冲区头行中的数据被迭代并分离成单独的指令，这些指令被打包成可以传递给Decode 的指令向量。如果在整个输入行或分解的指令中发现错误，则可以提前中止打包指令。</p><h3 id=branch-predictor>branch predictor</h3><p>Fetch2 包含分支预测机制。这是 gem5 (cpu/pred/…) 提供的分支预测器接口的包装器。</p><p>预测找到的任何控制指令的分支。如果尝试预测某条指令，则 在该指令上设置MinorDynInst::triedToPredict标志。</p><p>当预测分支将执行时，MinorDynInst::predictedTaken标志将被设置，MinorDynInst::predictedTarget将被设置为预测的目标 PC 值。然后，预测的分支指令将被打包到 Fetch2 的输出向量中，预测序列号将递增，并将分支传送给 Fetch1。</p><p>在发出预测信号后，Fetch2 将丢弃其输入缓冲区内容，并拒绝任何具有与该分支相同的流序列号但具有不同预测序列号的新行。这样就可以拒绝后续顺序获取的行，而不会忽略由 Execute 的“真实”分支指示的流更改生成的新行（它将具有新的流序列号）。</p><p>Fetch1 数据包提供给 Fetch2 的程序计数器值仅在流发生变化时更新。Fetch2::havePC 指示是否将从下一个处理的输入行中获取 PC。Fetch2::havePC 是必需的，以便通过解码跟踪换行指令。</p><p>Execute 处理的分支（以及预测会分支的指令）将生成 BranchData ( pipe_data.hh ) 数据，解释分支的结果，该数据将转发给 Fetch1 和 Fetch2。Fetch1 使用此数据更改流（并更新其流序列号和新行的地址）。Fetch2 使用它来更新分支预测器。Minor 不会将提交途中丢弃的指令的分支数据传达给分支预测器。</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>Branch enum val.</th><th style=text-align:left>In Execute</th><th style=text-align:left>Fetch1 reaction</th><th style=text-align:left>Fetch2 reaction</th></tr></thead><tbody><tr><td style=text-align:left>No Branch(无分支)</td><td style=text-align:left>(output bubble data)</td><td style=text-align:left>-</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left>CorrectlyPredictedBranch（预测正确）</td><td style=text-align:left>Predicted, taken</td><td style=text-align:left>-</td><td style=text-align:left>Update BP as taken branch</td></tr><tr><td style=text-align:left>UnpredictedBranch（未预测的分支）</td><td style=text-align:left>Not predicted, taken and was taken</td><td style=text-align:left>New stream</td><td style=text-align:left>Update BP as taken branch</td></tr><tr><td style=text-align:left>BadlyPredictedBranch（预测的跳转错误）</td><td style=text-align:left>Predicted, not taken</td><td style=text-align:left>New stream to restore to old Inst. source</td><td style=text-align:left>Update BP as not taken branch</td></tr><tr><td style=text-align:left>BadlyPredictedBranchTarget（预测的目标地址错误）</td><td style=text-align:left>Predicted, taken, but to a different target than predicted one</td><td style=text-align:left>New stream</td><td style=text-align:left>Update BTB to new target</td></tr><tr><td style=text-align:left>SuspendThread（暂停取指）</td><td style=text-align:left>Hint to suspend fetch</td><td style=text-align:left>Suspend fetch for this thread (branch to next inst. as wakeup fetch addr</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left>Interrupt（中断）</td><td style=text-align:left>Interrupt detected</td><td style=text-align:left>New stream</td><td style=text-align:left>-</td></tr></tbody></table></div><h3 id=fetch2-阶段的核心功能><strong>Fetch2 阶段的核心功能</strong></h3><ul><li><strong>输入</strong>：<ul><li>从 Fetch1 阶段接收指令行数据（<code>ForwardLineData</code>）。</li><li>从 Execute 阶段接收分支信息（<code>BranchData</code>），用于更新分支预测器。</li></ul></li><li><strong>输出</strong>：<ul><li>将分解后的指令（<code>ForwardInstData</code>）传递给 Decode 阶段。</li><li>将分支预测结果（<code>BranchData</code>）传递给 Fetch1 阶段。</li></ul></li><li><strong>主要任务</strong>：<ul><li>从指令行数据中提取指令。</li><li>进行分支预测。</li><li>更新分支预测器。</li><li>管理线程的取指状态，fetchinfo</li></ul></li></ul><p>fetchinfo.inputIndex 是 相对于cache line 的 偏移,</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>            <span style=color:#7f848e>// 102a4
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>// 10280
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>// 10 0100
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>// 24
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>// 36 , 所以偏移是36
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>// icache 64 Byte 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>            <span style=color:#7f848e>//      1010 0100
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#c678dd>struct</span> <span style=color:#e5c07b>Fetch2ThreadInfo</span> {
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>unsigned</span> <span style=color:#e5c07b>int</span> <span style=color:#e06c75>inputIndex</span> <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0</span>;          <span style=color:#7f848e>// 当前处理的指令行中的偏移量
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>unique_ptr</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>PCStateBase</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>pc</span>;      <span style=color:#7f848e>// 当前线程的程序计数器（PC）
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>havePC</span> <span style=color:#56b6c2>=</span> <span style=color:#e5c07b>false</span>;                  <span style=color:#7f848e>// PC 是否有效
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>lastStreamSeqNum</span>;          <span style=color:#7f848e>// 上一个指令流的序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>fetchSeqNum</span>;               <span style=color:#7f848e>// 取指序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>expectedStreamSeqNum</span>;      <span style=color:#7f848e>// 预期的指令流序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>predictionSeqNum</span>;          <span style=color:#7f848e>// 预测序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>blocked</span> <span style=color:#56b6c2>=</span> <span style=color:#e5c07b>false</span>;                 <span style=color:#7f848e>// 线程是否被阻塞
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>};
</span></span></code></pre></div><h3 id=fetch2evaluate>fetch2::evaluate</h3><ul><li><strong>功能</strong>：<ul><li>Fetch2 阶段的核心函数，负责处理输入数据并生成输出。</li></ul></li><li><strong>逻辑</strong>：<ol><li>将 Fetch1 的输入数据放入输入缓冲区。</li><li>根据 Execute 的分支信息更新分支预测器。</li><li>如果指令流改变，清空指令缓冲区inputBuffer .</li><li>如果下一阶段的输入缓冲区没有空间会阻塞线程。</li><li>从输入缓冲区中提取指令行数据，在while遍历，并将其分解为单独的指令。如果发生fault 之类的，可能需要把整行丢了，然后结束遍历</li><li>控制是否pipline activate</li></ol></li></ul><h3 id=fetch2updatebranchprediction>fetch2::updateBranchPrediction</h3><p>它的主要作用是处理来自 Execute 的分支反馈（如分支是否被正确预测、分支目标是否正确等），并根据这些反馈调整分支预测器的状态，以提高未来分支预测的准确性。</p><p>在未预测分支，正确预测分支，错误预测分支 ， 错误预测分支目标的时候都会去更新分支预测器。</p><p>branchPredictor.squash()</p><p>branchPredictor.update(),</p><p>在 Minor CPU 中，<code>stash</code> 操作用于在分支指令的取指（Fetch）或译码（Decode）阶段临时存储分支预测的结果和相关上下文信息。这些信息会被保存到分支预测历史记录（<code>predHist</code>）中，以便在后续阶段使用。</p><p>在 Minor CPU 中，<code>update</code> 操作用于在分支指令的提交（Commit）阶段根据实际执行结果更新分支预测器的状态。它的主要目的是修正预测器的内部状态，使其能够学习历史分支行为，从而提高未来的预测准确性。</p><h3 id=bpusquash>bpu::squash</h3><pre tabindex=0><code>// 现在我们知道某个分支预测错误了，我们需要撤销从该分支之后的所有已见分支，
// 并修复所有相关状态。
// 注意：这个函数可能在两种场景下被调用：
// (1) 当一个分支执行后，它会更新其在 ROB（重排序缓冲区）中的状态。
//     提交阶段会检查 ROB 的更新，并向取指阶段发送信号，
//     以清除该错误预测分支之后的历史记录。
// (2) 在译码阶段，你可以提前发现一个无条件 PC 相对分支是否被错误预测。
//     如果是，则向取指阶段发送信号，以清除该错误预测分支之后的历史记录。
</code></pre><ul><li><p><strong>目的</strong>：</p><ul><li>处理分支预测错误的情况。</li><li>清除错误的分支预测历史。</li><li>更新分支预测器的状态。</li></ul></li><li><p><strong>输入参数</strong>：</p><ul><li><code>squashed_sn</code>：被错误预测的分支的序列号（<code>InstSeqNum</code>）。</li><li><code>corr_target</code>：正确的分支目标地址（<code>PCStateBase</code>）。</li><li><code>actually_taken</code>：分支是否实际跳转（<code>bool</code>）。</li><li><code>tid</code>：线程 ID（<code>ThreadID</code>）。</li><li><code>from_commit</code>：是否来自提交阶段（<code>bool</code>）。</li></ul></li><li><p><strong><code>squash(squashed_sn, tid)</code></strong>：</p><ul><li>清除序列号大于 <code>squashed_sn</code> 的所有分支预测历史。</li><li>确保分支预测器恢复到错误预测之前的状态。</li></ul></li><li><p><strong>关键点</strong>：</p><ul><li>通过 <code>squash(squashed_sn, tid)</code> 清除错误的分支预测历史。</li><li>通过 <code>update()</code> 更新分支预测器的状态。</li><li>通过 <code>iPred->update()</code> 更新间接分支预测器。</li><li>通过 <code>ras->pop()</code> 和 <code>ras->push()</code> 更新返回地址栈（RAS）。</li><li>通过 <code>btb->update()</code> 更新分支目标缓冲器（BTB）。</li></ul></li></ul><p>通过 <code>BPredUnit::squash</code>，分支预测单元能够动态调整其状态，确保在分支预测错误时能够快速恢复，并提高未来分支预测的准确性。</p><h3 id=bpuupdate>bpu::update</h3><p>略</p><h3 id=fetch2predictbranch>fetch2::predictbranch</h3><p>负责预测分支指令的行为（是否跳转、目标地址等），并更新相关的状态信息。</p><p>如果是分支指令，调用分支预测器得到相应的结果，如果预测为跳转的话生成新的BranchData , 此时predictionSeqNum 会+1</p><h2 id=decode>decode</h2><p>解码从Fetch2（通过其输入缓冲区）获取指令向量并将这些指令分解为微操作（如有必要）并将它们打包到其输出指令向量中。类型都是forwardInstData , 但是</p><p>参数executeInputWidth设置每个周期可以打包到输出中的指令数量。如果参数decodeCycleInput为真，则 Decode可以尝试在每个周期从其输入缓冲区中的多个条目中获取指令。</p><p>它会去更新 forwardInst 的 execSeqNum</p><p>同样，也需要去更新流水线的状态</p><h2 id=execute>Execute</h2><p>输入从Decode 接收的指令流 ForwardInstData</p><p>输出向Fetch1 发送的分支信息 BranchData , 负责指令流的更新</p><p>Execute 提供所有指令执行和内存访问机制。通过 Execute 的指令通道可能需要多个周期，其精确时间由功能单元管道 FIFO 建模。</p><p>指令向量（可能包括错误“指令”）由解码提供给执行，并可在执行输入缓冲区中排队后再发出。设置参数executeCycleInput允许执行检查多个输入缓冲区条目（多个指令向量）。可以使用executeInputWidth设置输入向量中的指令数量，可以使用参数executeInputBufferSize设置输入缓冲区的深度。</p><pre tabindex=0><code>将输入推送到inputbUffer 
设置对输入输出数据slot 和分支slot的
step dcache 的接口队列 
如果有中断，执行中断 
否则，提交指令 ， issue 新的指令 
advance 功能module pipline 
reactivate execute if the unit is still active 
如果数据没有全部使用，则commit the push to the input Buffer 
</code></pre><p>execute</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>输入/输出端口：
</span></span><span style=display:flex><span>inp：接收来自 Decode 阶段的指令数据。
</span></span><span style=display:flex><span>out：发送分支信息到 Fetch1 阶段。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>功能单元（FU）：
</span></span><span style=display:flex><span>funcUnits：功能单元池，每个 FU 处理特定操作类（如 ALU、FPU）。
</span></span><span style=display:flex><span>noCostFUIndex：标记无成本指令（如 NOP）的虚拟 FU 索引。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>访存队列（LSQ）：
</span></span><span style=display:flex><span>lsq：管理 Load/Store 请求，处理内存访问和缓存交互。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>记分牌（Scoreboard）：
</span></span><span style=display:flex><span>scoreboard：跟踪寄存器的写后读（RAW）依赖，确保指令按序发射。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>线程状态：
</span></span><span style=display:flex><span>executeInfo：每个线程的状态信息，包括飞行中的指令队列（inFlightInsts）和访存指令队列（inFUMemInsts）
</span></span><span style=display:flex><span>executeInfo 的关键成员 
</span></span><span style=display:flex><span>inFlightInsts：未提交的指令队列，按执行顺序排列。
</span></span><span style=display:flex><span>inFUMemInsts：功能单元中待处理的访存指令队列。
</span></span><span style=display:flex><span>drainState：流水线排空状态（如正常、排空当前指令、暂停取指等）
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. 指令发射（issue 函数）
</span></span><span style=display:flex><span>3.1 发射流程
</span></span><span style=display:flex><span>获取输入指令：从输入缓冲区（inputBuffer）中取出待发射指令。
</span></span><span style=display:flex><span>检查线程状态：若线程挂起或指令流序号不匹配，则丢弃指令。
</span></span><span style=display:flex><span>选择功能单元：
</span></span><span style=display:flex><span>遍历所有 FU，寻找支持当前指令操作类（OpClass）的单元。
</span></span><span style=display:flex><span>检查 FU 是否空闲且无结构冒险。
</span></span><span style=display:flex><span>依赖检查：调用 scoreboard.canInstIssue 检查源寄存器是否就绪。
</span></span><span style=display:flex><span>发射指令：
</span></span><span style=display:flex><span>无成本指令：直接标记为完成，更新记分牌。
</span></span><span style=display:flex><span>访存指令：推入 inFUMemInsts 队列，等待 LSQ 处理。
</span></span><span style=display:flex><span>常规指令：推入 FU 管道，记录预计完成周期。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. 指令提交（commit 函数）
</span></span><span style=display:flex><span>4.1 提交流程
</span></span><span style=display:flex><span>处理访存响应：从 LSQ 获取完成的 Load/Store 响应，更新寄存器或内存状态。
</span></span><span style=display:flex><span>提交非访存指令：
</span></span><span style=display:flex><span>检查 FU 头部指令是否与 inFlightInsts 队列头部一致。
</span></span><span style=display:flex><span>执行指令（如 ALU 操作），更新 CPU 状态（寄存器、PC）。
</span></span><span style=display:flex><span>处理异常：若指令执行中发生异常（如页错误），触发中断处理。
</span></span><span style=display:flex><span>更新记分牌：清除已提交指令的依赖标记（clearInstDests）。
</span></span><span style=display:flex><span>4.2 关键逻辑
</span></span><span style=display:flex><span>访存指令提交：需等待 LSQ 响应，确保数据返回后才提交。
</span></span><span style=display:flex><span>内存屏障：确保屏障后的指令按序执行，更新 LSQ 状态。
</span></span><span style=display:flex><span>中断处理：若检测到中断，暂停当前指令流，更新分支信息。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>6. 流水线排空（Drain）
</span></span><span style=display:flex><span>6.1 排空状态机
</span></span><span style=display:flex><span>NotDraining：正常执行。
</span></span><span style=display:flex><span>DrainCurrentInst：排空当前宏指令的所有微指令。
</span></span><span style=display:flex><span>DrainHaltFetch：停止取指，等待飞行中的指令完成。
</span></span><span style=display:flex><span>DrainAllInsts：丢弃所有未提交指令，准备关闭流水线。
</span></span><span style=display:flex><span>6.2 排空逻辑
</span></span><span style=display:flex><span>drain<span style=color:#56b6c2>()</span>：触发排空流程，设置线程状态为 DrainCurrentInst 或 DrainHaltFetch。
</span></span><span style=display:flex><span>isDrained<span style=color:#56b6c2>()</span>：检查 LSQ 和指令队列是否为空，确认排空完成。
</span></span></code></pre></div><h3 id=commit>commit</h3><p>通过检查 Execute::inFlightInsts 队列的头部（该队列标有发出指令的功能单元编号）来提交指令。然后，可以在其功能单元中找到的指令将被执行并从 Execute::inFlightInsts 中弹出。</p><p>内存操作指令被提交到内存队列（如上所述）并退出其功能单元管道，但不会从 Execute::inFlightInsts 队列中弹出。Execute::inFUMemInsts 队列在内存操作通过功能单元时为其提供排序（保持发出顺序）。进入 LSQ 时，指令会从 Execute::inFUMemInsts 中弹出。</p><p>如果设置了参数 executeAllowEarlyMemoryIssue，内存操作可以在到达 Execute::inFlightInsts 的头部之前但满足其依赖关系之后从其 FU 发送到 LSQ。MinorDynInst <a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#ac72a9dcff570bbaf24da9ee74392e6d0 target=_blank rel=noopener>::instToWaitFor</a> 标记了内存操作进入 LSQ 所需提交的最新依赖指令 execSeqNum。</p><p>一旦内存响应可用（通过测试 Execute::inFlightInsts 的头部与<a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html#a458abe5d220a0f66600bf339bceb2100 target=_blank rel=noopener>LSQ::findResponse</a>），提交将处理该响应（ExecuteContext::completeAcc）并从 Execute::inFlightInsts 中弹出指令。</p><p>任何分支、故障或中断都会导致流序列号发生变化，并向 Fetch1/Fetch2 发出分支信号。只有具有当前流序列号的指令才会被发出和/或提交。</p><p><strong>commit 的核心目标</strong></p><ul><li><strong>完成指令生命周期</strong>：将指令从功能单元（FU）或访存队列（LSQ）中提交，更新 CPU 状态（如寄存器、PC）。</li><li><strong>处理依赖与冲突</strong>：通过记分牌（Scoreboard）管理寄存器依赖，确保指令按序提交。</li><li><strong>处理异常与中断</strong>：响应指令执行中的异常（如缺页）和外部中断，更新流水线状态。</li><li><strong>多线程调度</strong>：按策略选择线程提交指令，确保公平性和效率。</li></ul><p>处理访存响应</p><h3 id=issue>issue</h3><p>发出指令涉及迭代输入缓冲区指令和功能单元的头部，以尝试按顺序发出指令。每个周期可以发出的指令数量受参数 executeIssueLimit、executeCycleInput 的设置方式、可用性的限制</p><p>管道空间以及用于选择可以发出指令的管道的策略。</p><p>目前，唯一的问题策略是严格按照给定的顺序循环访问每个管道。为了获得更大的灵活性，需要制定更好的（和更具体的）策略。</p><p>内存操作指令遍历其功能单元以执行其 EA 计算。在“提交”时，执行ExecContext ::initiateAcc 执行阶段，并向[LSQ发出任何内存访问（通过 ExecContext::{read,write}Mem 调用LSQ::pushRequest）。</p><p>请注意，故障的发出就像指令一样，并且（当前）可以发送给任何功能单元。</p><p>每条发出的指令也被推送到 Execute::inFlightInsts 队列中。内存引用指令被推送到 Execute::inFUMemInsts 队列中。</p><p>issue 的时候会去更新inFlightInst , 和scoreboard</p><p>isNoConstInst , 可以issue</p><p>fu不可用或者满</p><p>fu 阻塞</p><p>!fu->canInsert()</p><p>scoreboard 依赖未解决</p><p>遍历function unit 找个一个有效的去issue , 然后inflight inst 和 inFUMemInsts（如果是访存指令） 都会增加</p><p>相应的指令也会推送到fu的queue去</p><h2 id=scoreboard>scoreboard</h2><p>记分板 ( <a class=link href=http://doxygen.gem5.org/release/current/classMinor_1_1Scoreboard.html target=_blank rel=noopener>Scoreboard</a> ) 用于控制指令的发出。它包含将写入每个通用 CPU 整数或浮点寄存器的运行中指令的数量。只有当记分板包含 0 条将写入指令源寄存器之一的指令时，才会发出指令。</p><p>一旦发出指令，指令的每个目标寄存器的记分板计数将会增加。</p><p>通过将发出的 FU 的长度添加到当前时间，在记分板上标记指令结果的预计交付时间。每个 FU 上的计时参数提供了用于计算交付时间的附加规则列表。这些记录在 MinorCPU.py 中的参数注释中。</p><p>在提交时（对于内存操作、内存响应提交），指令源寄存器的记分板计数器将减少。将减少。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>Index</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>numResults</span> <span style=color:#7f848e>//个寄存器有多少条in-flight的指令没有修改 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>Index</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>numUnpredictableResults</span>; <span style=color:#7f848e>// 记录每个寄存器有多少条不可预测结果的指令正在修改它
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>fuIndices</span> : <span style=color:#7f848e>//当前正在修改该寄存器的功能单元（FU）的索引。用于判断结果是否可以转发（Forwarding）
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>Cycles</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>returnCycle</span>:<span style=color:#7f848e>//计该寄存器的结果将在哪个周期可用。用于计算指令发射时间。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>InstSeqNum</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>writingInst</span>;  <span style=color:#7f848e>//最近一次修改该寄存器的指令的执行序列号（execSeqNum），用于确定依赖顺序。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e5c07b>bool</span> <span style=color:#61afef;font-weight:700>findIndex</span>(<span style=color:#c678dd>const</span> <span style=color:#e06c75>RegId</span><span style=color:#56b6c2>&amp;</span> <span style=color:#e06c75>reg</span>, <span style=color:#e06c75>Index</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>scoreboard_index</span>);<span style=color:#7f848e>// RegId 转换为 Scoreboard 内部索引（如整数寄存器映射到 intRegOffset + reg.index()）。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e5c07b>void</span> <span style=color:#61afef;font-weight:700>markupInstDests</span>(<span style=color:#e06c75>MinorDynInstPtr</span> <span style=color:#e06c75>inst</span>, <span style=color:#e06c75>Cycles</span> <span style=color:#e06c75>retire_time</span>,
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>ThreadContext</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>thread_context</span>, <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>mark_unpredictable</span>);<span style=color:#7f848e>//在指令发射时，标记其目的寄存器的依赖关系。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>遍历指令的所有目的寄存器。
</span></span><span style=display:flex><span>更新 <span style=color:#e06c75>numResults</span> 和 <span style=color:#e06c75>numUnpredictableResults</span>。
</span></span><span style=display:flex><span>记录 <span style=color:#e06c75>returnCycle</span>（预计结果可用周期）和 <span style=color:#e06c75>writingInst</span>（最近写入指令的序列号）。
</span></span><span style=display:flex><span><span style=color:#e5c07b>void</span> <span style=color:#e06c75>clearInstDests</span>(<span style=color:#e06c75>MinorDynInstPtr</span> <span style=color:#e06c75>inst</span>, <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>clear_unpredictable</span>); <span style=color:#7f848e>//在指令提交后，清除其目的寄存器的依赖标记。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>减少 <span style=color:#e06c75>numResults</span> 和 <span style=color:#e06c75>numUnpredictableResults</span>，若归零则重置 <span style=color:#e06c75>returnCycle</span> 和 <span style=color:#e06c75>writingInst</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>execSeqNumToWaitFor</span>(<span style=color:#e06c75>MinorDynInstPtr</span> <span style=color:#e06c75>inst</span>, <span style=color:#e06c75>ThreadContext</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>thread_context</span>);<span style=color:#7f848e>//返回当前指令需要等待的最大的 execSeqNum（即其源寄存器最近一次被修改的指令序列号）
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e5c07b>bool</span> <span style=color:#61afef;font-weight:700>canInstIssue</span>(<span style=color:#e06c75>MinorDynInstPtr</span> <span style=color:#e06c75>inst</span>,
</span></span><span style=display:flex><span>                 <span style=color:#c678dd>const</span> <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>Cycles</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>src_reg_relative_latencies</span>,
</span></span><span style=display:flex><span>                 <span style=color:#c678dd>const</span> <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e5c07b>bool</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>cant_forward_from_fu_indices</span>,
</span></span><span style=display:flex><span>                 <span style=color:#e06c75>Cycles</span> <span style=color:#e06c75>now</span>, <span style=color:#e06c75>ThreadContext</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>thread_context</span>); <span style=color:#7f848e>//检查指令的源寄存器是否全部就绪（无未完成依赖
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>所有源寄存器的 <span style=color:#e06c75>returnCycle</span> <span style=color:#56b6c2>&lt;=</span> <span style=color:#e06c75>now</span> <span style=color:#56b6c2>+</span> 相对延迟。
</span></span><span style=display:flex><span>无不可预测结果（<span style=color:#e06c75>numUnpredictableResults</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span>）
</span></span><span style=display:flex><span>   
</span></span></code></pre></div><h2 id=func_unit>func_unit</h2><pre tabindex=0><code>MinorOpClass 与 MinorOpClassSet 
功能：描述功能单元支持的操作类（OpClass），如 IntAlu、MemRead 等。
实现：
MinorOpClass 包装单个操作类，通过参数配置。
MinorOpClassSet 管理多个操作类集合，生成能力列表（capabilityList），用于快速检查功能单元是否支持某类操作

MinorFUTiming
功能：为特定指令类型提供额外的时序控制，例如调整源寄存器的依赖延迟或添加提交延迟。
关键字段：
mask 和 match：通过指令的 ExtMachInst 匹配特定指令。
srcRegsRelativeLats：源寄存器的相对延迟（允许指令提前发射）。
extraCommitLat：指令提交时的额外延迟。
应用场景：为某类指令（如浮点乘除）设置更高的延迟。

MinorFU
功能：描述单个功能单元的基本属性。
关键参数：
opClasses：支持的 OpClass 集合。
opLat：指令在 FU 中的执行延迟（周期数）。
issueLat：两次指令发射的最小间隔周期。
cantForwardFromFUIndices：禁止结果转发的 FU 索引列表。
timings：附加的时序规则（MinorFUTiming 列表）。

MinorFUPool
功能：管理多个功能单元的集合，通常在 CPU 配置中定义多个 FU 实例。

FUPipeline
功能：实现功能单元的流水线行为，继承自 SelfStallingPipeline，支持自我阻塞。
核心机制：
流水线推进：通过 advance() 方法逐步推进指令。
发射间隔控制：nextInsertCycle 记录下次允许发射的周期。
时序匹配：findTiming() 根据指令的 ExtMachInst 匹配附加时序规则。
</code></pre><h2 id=lsu>lsu</h2><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2025/gem5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84cpu_model/><div class=article-details><h2 class=article-title>Gem5创建一个新的cpu_model</h2></div></a></article><article><a href=/2024/gem5_%E4%BF%AE%E6%94%B9%E6%89%A9%E5%B1%95/><div class=article-details><h2 class=article-title>Gem5_修改扩展</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了394.9k字·共 104篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#温习修改gem5-源码的方法创建自己的simobject>温习修改gem5 源码的方法（创建自己的simobject)</a></li><li><a href=#代码分析>代码分析</a></li><li><a href=#instid>InstId</a><ol><li><a href=#minordyninst>MinorDynInst</a></li></ol></li><li><a href=#forwardlinedata>forwardlinedata</a><ol><li><a href=#forwardinstdata>forwardInstData</a></li><li><a href=#branchdata>BranchData</a></li><li><a href=#fetch1fetchrequest>fetch1::fetchRequest</a></li></ol></li><li><a href=#pipline>pipline</a><ol><li><a href=#event-handling-minoractivityrecorder>Event handling: MinorActivityRecorder</a></li></ol></li><li><a href=#cpucc>cpu.cc</a></li><li><a href=#fetch1>fetch1</a><ol><li><a href=#fetch1evaluate>fetch1::evaluate</a></li><li><a href=#fetch1changestream>fetch1::changeStream</a></li><li><a href=#fetch1fetchline>fetch1::fetchLine</a></li><li><a href=#fetch1stepqueues>fetch1::stepQueues</a></li><li><a href=#fetch1requestisdiscardable>fetch1::request::isDiscardable</a></li><li><a href=#fetch1processresponse>fetch1::processResponse</a></li><li><a href=#fetch1popanddiscard>fetch1::popanddiscard</a></li><li><a href=#fetch1transfers>fetch1::transfers</a></li></ol></li><li><a href=#fetch2>fetch2</a><ol><li><a href=#branch-predictor>branch predictor</a></li><li><a href=#fetch2-阶段的核心功能><strong>Fetch2 阶段的核心功能</strong></a></li><li><a href=#fetch2evaluate>fetch2::evaluate</a></li><li><a href=#fetch2updatebranchprediction>fetch2::updateBranchPrediction</a></li><li><a href=#bpusquash>bpu::squash</a></li><li><a href=#bpuupdate>bpu::update</a></li><li><a href=#fetch2predictbranch>fetch2::predictbranch</a></li></ol></li><li><a href=#decode>decode</a></li><li><a href=#execute>Execute</a><ol><li><a href=#commit>commit</a></li><li><a href=#issue>issue</a></li></ol></li><li><a href=#scoreboard>scoreboard</a></li><li><a href=#func_unit>func_unit</a></li><li><a href=#lsu>lsu</a></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/prefetch/ class=category-list-link>prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/ class=category-list-link>基础概念<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class=category-list-link>操作系统<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83/ class=category-list-link>环境<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>17</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>56</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_4>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>