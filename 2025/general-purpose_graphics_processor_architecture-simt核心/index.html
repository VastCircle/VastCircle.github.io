<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='在其传统的图形渲染角色中，GPU 访问数据集，例如详细的纹理图，这些数据集太大而无法完全缓存在芯片上。实现在图形中所期望的高性能可编程性，既可以随着图形模式数量的增加而降低验证成本，也可以使游戏开发人员更容易区分他们的产品 [Lindholm et al., 2001]，为此我们有必要采用能够维持大的片外 (off-chip) 带宽的架构。因此，今天的 GPU 会同时执行数万个线程。虽然每个线程的片上内存存储量很小，但缓存仍然可以有效地减少大量的片外内存访问。例如，在图形工作负载中，可以由片上缓存捕获的相邻像素操作之间存在显著的空间局部性。
'><title>General Purpose_graphics_processor_architecture SIMT核心</title>
<link rel=canonical href=https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='General Purpose_graphics_processor_architecture SIMT核心'><meta property='og:description' content='在其传统的图形渲染角色中，GPU 访问数据集，例如详细的纹理图，这些数据集太大而无法完全缓存在芯片上。实现在图形中所期望的高性能可编程性，既可以随着图形模式数量的增加而降低验证成本，也可以使游戏开发人员更容易区分他们的产品 [Lindholm et al., 2001]，为此我们有必要采用能够维持大的片外 (off-chip) 带宽的架构。因此，今天的 GPU 会同时执行数万个线程。虽然每个线程的片上内存存储量很小，但缓存仍然可以有效地减少大量的片外内存访问。例如，在图形工作负载中，可以由片上缓存捕获的相邻像素操作之间存在显著的空间局部性。
'><meta property='og:url' content='https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-02-04T23:43:57+08:00'><meta property='article:modified_time' content='2025-02-04T23:43:57+08:00'><meta name=twitter:title content="General Purpose_graphics_processor_architecture SIMT核心"><meta name=twitter:description content="在其传统的图形渲染角色中，GPU 访问数据集，例如详细的纹理图，这些数据集太大而无法完全缓存在芯片上。实现在图形中所期望的高性能可编程性，既可以随着图形模式数量的增加而降低验证成本，也可以使游戏开发人员更容易区分他们的产品 [Lindholm et al., 2001]，为此我们有必要采用能够维持大的片外 (off-chip) 带宽的架构。因此，今天的 GPU 会同时执行数万个线程。虽然每个线程的片上内存存储量很小，但缓存仍然可以有效地减少大量的片外内存访问。例如，在图形工作负载中，可以由片上缓存捕获的相邻像素操作之间存在显著的空间局部性。
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>GPGPU读书笔记</a></header><h2 class=article-title><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/>General Purpose_graphics_processor_architecture SIMT核心</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 04, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>6748字</time></div></footer></div></header><section class=article-content><p>在其传统的图形渲染角色中，GPU 访问数据集，例如详细的纹理图，这些数据集太大而无法完全缓存在芯片上。实现在图形中所期望的高性能可编程性，既可以随着图形模式数量的增加而降低验证成本，也可以使游戏开发人员更容易区分他们的产品 [Lindholm et al., 2001]，为此我们有必要采用能够维持大的片外 (<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=off-chip&amp;zhida_source=entity" target=_blank rel=noopener>off-chip</a>) 带宽的架构。因此，今天的 GPU 会同时执行数万个线程。虽然每个线程的片上内存存储量很小，但缓存仍然可以有效地减少大量的片外内存访问。例如，在图形工作负载中，可以由片上缓存捕获的相邻像素操作之间存在显著的空间局部性。</p><p>图 3.1 展示了本章讨论的 GPU 流水线的微架构。该图说明了图 1.2 中所示的单个 SIMT 核心的内部组织。流水线可以分为 SIMT 前端和 SIMD 后端。流水线由三个调度“循环 (loop)”组成，它们在一个流水线中共同作用：一个取指循环、一个指令发射 (issue) 循环和一个寄存器访问调度 (scheduling) 循环。取指循环包括标记为 Fetch、I-Cache、Decode 和 I-Buffer 的块。指令发射循环包括标记为 I-Buffer、Scoreboard、Issue 和 SIMT 堆栈的块。寄存器访问调度循环包括标记为 Operand Collector、ALU 和 Memory 的块。在本章的其余部分，我们通过考虑依赖于每个循环的架构的关键方面，帮助您全面了解图中的各个块。</p><p><figure class=gallery-image style=flex-grow:346;flex-basis:830px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-39b3d9c0ba9b95b3314545e5533fa20d_1440w.jpg data-size=1440x416><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-39b3d9c0ba9b95b3314545e5533fa20d_1440w.jpg width=1440 height=416 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-39b3d9c0ba9b95b3314545e5533fa20d_1440w_hu12847181308280320978.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-39b3d9c0ba9b95b3314545e5533fa20d_1440w_hu17105675378257904179.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><h2 id=31-单循环近似>3.1 单循环近似</h2><p>为了提高效率，线程被组织成 NVIDIA 称为 &ldquo;warp&rdquo; 和 AMD 称为 &ldquo;wavefronts&rdquo; 的组。因此，调度的单位是一个 warp。**在每个周期中，硬件选择一个 <a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=3&amp;q=warp&amp;zhida_source=entity" target=_blank rel=noopener>warp</a> 进行调度。**在单循环近似中，warp 的<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8&amp;zhida_source=entity" target=_blank rel=noopener>程序计数器</a> (pc) 用于访问指令存储器以查找要为 warp 执行的下一条指令。获取指令后，对指令进行解码并从寄存器堆中获取源操作数寄存器。在从寄存器堆中获取源操作数的同时，确定 SIMT 执行掩码 (execution mask) 值。以下小节描述了如何确定 SIMT 执行掩码值并将它们与现代 GPU 中也使用的谓词 (<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=predication&amp;zhida_source=entity" target=_blank rel=noopener>predication</a>) 进行对比。</p><p>在执行掩码和源寄存器可用后，执行以单指令、多数据 (SIMD) 的方式进行。如果设置了 SIMT 执行掩码，则每个线程都在与通路 (lane) 关联的功能单元上执行。与现代 CPU 设计一样，功能单元通常是异构的，这意味着给定的功能单元仅支持指令的子集。例如，NVIDIA GPU 包含一个特殊功能单元 (Special Function Unit, SFU)、加载/存储单元、浮点功能单元、整数功能单元，以及从 Volta 开始的 Tensor Core。</p><p>**所有功能单元 (function unit) 名义上包含的通路数与 warp 中的线程数一样多。**然而，一些 GPU 使用了不同的实现，其中单个 warp 或 wavefront 在多个时钟周期内执行。这是通过以更高的频率为功能单元提供时钟来实现的，这可以以增加能耗为代价实现更高的单位面积性能。为功能单元实现更高时钟频率的一种方法是将它们的执行流水线化或增加它们的流水线深度。</p><h2 id=32-双循环近似>3.2 双循环近似</h2><p>为了帮助减少每个核心必须支持以隐藏长执行延迟的 warp 数量，能够在早期指令尚未完成时从 warp 发出后续指令是有帮助的。然而，前面描述的单循环微架构阻止了这种情况，因为该设计中的调度逻辑只能访问线程标识符和下一条要发出的指令的地址。具体来说，它不知道为 warp 发出的下一条指令是否依赖于尚未完成执行的较早指令。为了提供这样的依赖信息，有必要首先从内存中获取指令，以确定存在哪些数据和/或结构冒险 (hazard)。为此，GPU 实现了一个指令缓冲区，指令从缓存被取出之后被放置在这里。一个单独的调度程序用于决定指令缓冲区中的几条指令中的哪一条应该被发射到流水线的其余部分。</p><p>指令内存被实现为一级指令缓存，由一级或多级二级（通常是统一的）缓存支持。指令缓冲区还可以结合指令未命中状态保持寄存器 (MSHR) [Kroft, 1981] 帮助隐藏指令缓存未命中延迟。在缓存命中或缓存未命中填充 (fill) 后，指令信息被放入指令缓冲区。指令缓冲区的组织可以采取多种形式。一种特别直接的方法是为每个 warp 存储一个或多个指令。</p><blockquote><p>译者注：我们把 buffer 翻译为缓冲区，cache 翻译为缓存，memory 翻译为内存，scratchpad 翻译为暂存器，storage 翻译为存储（暂未用到），以作区分。</p></blockquote><p>接下来，让我们考虑如何检测同一 warp 中指令之间的数据依赖关系。它们是检测传统 CPU 架构中指令之间依赖关系的两种传统方法：记分板 (scoreboard) 和保留站 (reservation station)。保留站用于消除名称依赖性并引入对在面积和能源方面昂贵的关联逻辑的需求。记分板可以设计为支持顺序执行或乱序执行。支持乱序执行的记分板（如 CDC 6600 中使用的记分板）也相当复杂。另一方面，单线程顺序 CPU 的记分板非常简单：记分板中的每个寄存器都用 1 bit 表示，只要发射将写入该寄存器的指令，就会置位该 bit。任何想要读取或写入在记分板上置位了相应 bit 的寄存器的指令都会停止 (stall)，直到该 bit 被写入寄存器的指令清除。这可以防止先写后读 (RAW) 和先写后写 (WAW) 冒险。当与顺序指令问题结合使用时，这个简单的记分板可以防止先读后写 (WAR) 冒险，前提是寄存器堆的读取被限制为顺序发生，这通常是顺序 CPU 设计中的情况。鉴于它是最简单的设计，因此将消耗最少的面积和能量，GPU 实现了顺序记分板。然而，正如接下来所讨论的，在支持多个 warp 时使用顺序记分板存在挑战。</p><p>上述简单顺序记分板设计的第一个问题是现代 GPU 中包含大量寄存器。每个 warp 最多 128 个寄存器，每个核心最多 64 个 warp，每个核心总共需要 8192 bit 来实现记分板。</p><p>上面描述的简单顺序记分板设计的另一个问题是遇到依赖的指令必须在记分板中重复查找其操作数，直到它所依赖的前一条指令将其结果写入寄存器堆。对于单线程设计，这没怎么引入复杂性。然而，在顺序发射的多线程处理器中，来自多个线程的指令可能正在等待更早的指令完成。如果所有此类指令都必须探测 (probe) 记分板，则需要额外的读取端口。最近的 GPU 支持每个核心最多 64 个 warp，并且最多支持 4 个操作数，允许所有 warp 在每个周期探测记分板，这将需要 256 个读取端口，这将非常昂贵。一种替代方法是限制每个周期可以探测记分板的 warp 数量，但这限制了可以考虑被调度的 warp 数量。此外，如果检查的指令都没有依赖关系，则即使其他无法检查的指令碰巧没有依赖关系，也不会发射指令。</p><p>这两个问题都可以使用 Coon [2008] 等人提出的设计来解决。该设计不是在每个 warp 的每个寄存器中保留 1 bit，而是在每个 warp 中包含少量（在最近的一项研究 [Lashgar 等人，2016 年] 中估计约为 3 或 4 个）表项，其中每个表项指示的是已发射但尚未完成执行的指令写入的寄存器。常规的顺序记分牌在发射指令和写回指令时都会被访问。相反，Coon 等人的记分板是在将指令放入指令缓冲区以及将其结果写入寄存器堆时访问的。</p><p>当从指令缓存中取出一条指令并将其放入指令缓冲区时，相应 warp 的记分板表项将与该指令的源寄存器和目的寄存器进行比较。这会产生一个短的位向量 (bit vector)，相应 warp 的记分板上的每个表项对应一个 bit（例如，3 或 4 bit）。如果记分板中的相应表项与指令的任何操作数匹配，则置位相应 bit。然后将该位向量与指令缓冲区中的指令一起复制。在所有 bit 都被清除之前，指令调度程序没有资格考虑发射这条指令，这可以通过将向量的每个 bit 送入或非门 (NOR) 来确定。指令缓冲区中的相关 bit 在指令将其结果写入寄存器堆时被清除。如果一个给定的 warp 的所有表项都用完了，那么要么停止所有 warp 取指，要么该指令被丢弃并且必须再次取指。当一条已执行的指令准备好写入寄存器堆时，它会清除记分板中分配给它的表项，并清除存储在指令缓冲区中的来自同一 warp 的任何指令的相应依赖 bit。</p><blockquote><p>常规的计分牌在发射阶段访问是否存在依赖，去比较相应源寄存器 （目标寄存器也要比较（避免waw冲突））， 在写回阶段更新目标寄存器，将相应的目标寄存器复位</p><p>优化后的记分牌在将指令写入指令缓存区的时候就会被访问，去比较源寄存器和目的寄存器和记分牌条目，将比较的结果和指令一起放入指令缓冲区，</p><p>个人感觉在指令发射时还是会将目标寄存器写入scoreboard，和常规记分牌一样</p><p>在执行的指令写入寄存器堆时，会清除记分牌中分配的表项，并清除指令缓存区来自同一warp任何指令的依赖bit</p><p>区别之处就在于直接将比较的掩码写入指令缓存区，后续通过清除掩码来确认指令是否能够发射，而不是再去访问scoreboard</p><p>在warp的条目用完了之后，因为无法在将目的寄存器写入表项，所以需要停止所有warp取指或丢弃指令，直到又有空余表项</p><p>思想其实就是没必要将每一个寄存器都预留一位，而是直接加法式的加入依赖</p></blockquote><p>在双循环架构中，第一个循环选择在指令缓冲区中有空间的 warp，查找其程序计数器并执行指令缓存访问以获得下一条指令。第二个循环在指令缓冲区中选择一条没有突出依赖关系的指令并将其发射到执行单元。</p><h2 id=33-三循环近似>3.3 三循环近似</h2><p>如前所述，为了隐藏较长的内存延迟，有必要支持每个核心上有多个 warp；为了支持 warp 之间的逐周期切换，必须有一个大的寄存器堆，其中包含每个正在执行的 warp 的单独物理寄存器。例如，在 NVIDIA 最近的 GPU 架构（例如，Kepler、Maxwell 和 Pascal 架构）上，此类寄存器包含 256 KB。现在，SRAM 内存的面积与端口数成正比。寄存器堆的简单实现要求每周期、每条被发射的指令、每个操作数都拥有一个端口。减少寄存器堆面积的一种方法是使用多个单端口内存 bank 来模拟大量端口。虽然可以通过将这些 bank 暴露于<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=%e6%8c%87%e4%bb%a4%e9%9b%86%e6%9e%b6%e6%9e%84&amp;zhida_source=entity" target=_blank rel=noopener>指令集架构</a>来实现这种效果，但在某些 GPU 设计中，它出现了一种称为操作数收集器 (operand collector) 的结构 [Coon et al., 2009, Lindholm et al., 2008b, Lui et al.。 , 2008] 用于以更透明的方式实现这一目标。操作数收集器有效地形成第三个调度循环，如下所述。</p><blockquote><p>通过分bank可能会出现非常多的储存体冲突的现象</p></blockquote><p>为了更好地理解操作数收集器解决的问题，首先考虑图 3.12，它显示了一个简单的微架构，用于提供增加的寄存器堆带宽。此图显示了 GPU <a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=%e6%8c%87%e4%bb%a4%e6%b5%81%e6%b0%b4%e7%ba%bf&amp;zhida_source=entity" target=_blank rel=noopener>指令流水线</a>的寄存器读取阶段，其中寄存器堆由四个单端口逻辑寄存器 bank 组成。在实践中，由于寄存器堆非常大，每个逻辑 bank 可以进一步分解为更多的物理 bank（未示出）。逻辑 bank 通过 crossbar 连接到 staging 寄存器（标记为“pipeline 寄存器”），这些 staging 寄存器在将源操作数传递给 SIMD 执行单元之前对其进行缓冲。仲裁器控制对各个 bank 的访问，并通过 crossbar 将结果路由到适当的 staging 寄存器。</p><p><figure class=gallery-image style=flex-grow:174;flex-basis:419px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-dd51be15d927d0739373793d5a7d74ac_1440w.jpg data-size=720x412><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-dd51be15d927d0739373793d5a7d74ac_1440w.jpg width=720 height=412 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-dd51be15d927d0739373793d5a7d74ac_1440w_hu2498103953481885470.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-dd51be15d927d0739373793d5a7d74ac_1440w_hu8146024903042846369.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>图 3.13 显示了每个 warp 的寄存器到逻辑 bank 的简单布局。在该图中，warp 0 (w0) 中的寄存器 r0 存储在 Bank 0 的第一个位置，warp 0 中的寄存器 r1 存储在 Bank 1 的第一个位置，依此类推。如果计算所需的寄存器数量大于逻辑 bank 的数量，则分配回绕 (wrap around)。例如，warp 0 的寄存器 r4 存储在 Bank 0 的第二个位置。</p><p><figure class=gallery-image style=flex-grow:320;flex-basis:769px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-9afd1fb45cad06e29953cba695919aa5_1440w.jpg data-size=1440x449><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-9afd1fb45cad06e29953cba695919aa5_1440w.jpg width=1440 height=449 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-9afd1fb45cad06e29953cba695919aa5_1440w_hu1377142609073268482.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-9afd1fb45cad06e29953cba695919aa5_1440w_hu17407686598267492085.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>图 3.14 展示了一个时序示例，突出显示了此微架构如何影响性能。该示例涉及顶部显示的两条指令。第一条指令 i1 是一个多重加法运算，它从寄存器 r5、r4 和 r6 中读取，这些寄存器分配在存储区 1、0 和 2 中（图中用下标表示）。第二条指令 i2 是一条加法指令，它从分配在 bank 1 中的寄存器 r5 和 r1 中读取。图中的中间部分显示了指令发射的顺序。在第 0 周期，warp 3 发出指令 i1，在第 1 周期，warp 0 发出指令 i2，在第 4 周期，warp 1 在由于 bank 冲突而延迟后发出指令 i2，如下所述。该图的底部说明了不同指令访问不同 bank 的时序。在周期 1，warp 3 中的指令 i1 能够在周期 1 读取其所有三个源寄存器，因为它们映射到不同的逻辑 bank。但是，在周期 2，来自 warp 0 的指令 i2 只能读取其两个源寄存器之一，因为它们都映射到 bank 1。在周期 3，该指令的第二个源寄存器读取与来自 warp 3 指令 i1 的写回并行。在周期 4，来自 warp 1 的指令 i2 能够读取其第一个源操作数，但不能读取第二个，因为两者都映射到 bank 1。在周期 5，来自 warp 的指令 i2 的第二个源操作数 1 被阻止从寄存器堆中读取，因为该 bank 已经被 warp 0 较早发出的指令 i2 的较高优先级写回访问。最后，在周期 6 中，来自 warp 1 的 i2 的第二个源操作数从寄存器堆中读取。总之，三个指令需要六个周期才能完成对其源寄存器的读取，并且在此期间，许多 bank 都没有被访问。</p><p><figure class=gallery-image style=flex-grow:188;flex-basis:453px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-99ceb7c00185522daddba089c7f00069_1440w.jpg data-size=720x381><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-99ceb7c00185522daddba089c7f00069_1440w.jpg width=720 height=381 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-99ceb7c00185522daddba089c7f00069_1440w_hu620754345236744594.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-99ceb7c00185522daddba089c7f00069_1440w_hu926320356211440376.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><h3 id=331-操作数收集器>3.3.1 操作数收集器</h3><p>操作数收集器微架构 [Lindholm et al., 2008b] 如图 3.15 所示。关键的变化是 staging 寄存器已被收集器单元 (collector unit) 取代。每条指令在进入寄存器读取阶段时都会分配一个收集器单元。有多个收集器单元，因此多个指令可以重叠读取源操作数，这有助于在各个指令的源操作数之间存在 bank 冲突的情况下提高吞吐量。每个收集器单元包含执行指令所需的所有源操作数的缓冲空间。鉴于多条指令的源操作数数量较多，仲裁器更有可能实现增加的 bank 级并行性，以允许并行访问多个寄存器文件 bank。</p><p><figure class=gallery-image style=flex-grow:172;flex-basis:413px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-1ff19d0418efad1bf92d2397cb0bf542_1440w.jpg data-size=720x418><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-1ff19d0418efad1bf92d2397cb0bf542_1440w.jpg width=720 height=418 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-1ff19d0418efad1bf92d2397cb0bf542_1440w_hu6640150918055554793.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-1ff19d0418efad1bf92d2397cb0bf542_1440w_hu1326406193266683119.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>当 bank 冲突发生时，操作数收集器使用调度来容忍它。这留下了如何减少 bank 冲突数量的问题。图 3.16 说明了 Coon 等人修改的寄存器布局，描述了如何减少 bank 冲突。这个想法是从不同 bank 中的不同 warp 分配等效寄存器。例如，在图 3.16 中，warp 0 的寄存器 r0 分配给 bank 0，但 warp 1 的寄存器 r0 分配给 bank 1。这并不能解决单个指令的寄存器操作数之间的 bank 冲突。然而，它确实有助于减少来自不同warp的指令之间的 bank 冲突。特别是，每当 warp 取得相对平稳的进展时（例如，由于轮询调度或两级调度 [Narasiman et al., 2011]，其中 fetch group 中的各个 warp 以轮询顺序调度）。</p><p><figure class=gallery-image style=flex-grow:396;flex-basis:952px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-2f8d4c53a9676d9f27b587101c41d3b1_1440w.jpg data-size=1440x363><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-2f8d4c53a9676d9f27b587101c41d3b1_1440w.jpg width=1440 height=363 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-2f8d4c53a9676d9f27b587101c41d3b1_1440w_hu12587032214458145580.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-2f8d4c53a9676d9f27b587101c41d3b1_1440w_hu6796830029142670608.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>图 3.17 显示了一个时序示例，顶部显示了一系列的加法和乘加指令。中间显示了发射顺序。在周期 0 到 2 上发出来自 warp 1 到 3 的三个 i1 实例。来自 warp 0 的指令 i2 的实例在周期 3 上发出。请注意，加法指令写入寄存器 r1，对于任何给定的 warp，该寄存器都分配在作为源寄存器 r5 的同一 bank。然而，与图 3.13 中使用寄存器布局的情况不同，这里不同的 warp 访问不同的 bank，这有助于减少一个 warp 的写回和读取其他 warp 中的源操作数之间的冲突。底部显示了由于操作数收集器而导致的访问的 bank 级别时序。在周期 1 中，寄存器 r2 从 warp 1 读取 Bank 3。在周期 4，注意从 warp 1 写回寄存器 r1、从 warp 3 读取寄存器 r5 和从 warp 0 读取寄存器 r3 并行进行。</p><p><figure class=gallery-image style=flex-grow:182;flex-basis:437px><a href=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-669c1a88acd478c3468218c445ed9c51_1440w.jpg data-size=720x395><img src=/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-669c1a88acd478c3468218c445ed9c51_1440w.jpg width=720 height=395 srcset="/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-669c1a88acd478c3468218c445ed9c51_1440w_hu11132557564854649658.jpg 480w, /2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/v2-669c1a88acd478c3468218c445ed9c51_1440w_hu11513458141479289621.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>到目前为止所描述的操作数收集器的一个微妙问题是，由于它不会在准备发射不同指令的时间之间施加任何顺序，因此它可能会出现先读后写 (WAR) 冒险 [Mishkin et al., 2016]。如果来自同一 warp 的两条指令存在于操作数收集器中，并且第一条指令读取第二条指令将写入的寄存器，则可能会发生这种情况。如果第一条指令的源操作数访问遇到重复的 bank 冲突，则可以想象第二条指令可能在第一条寄存器读取（正确的）旧值之前将新值写入寄存器。防止这种 WAR 冒险的一种方法是简单地要求来自同一 warp 的指令按照程序顺序将操作数收集器留给执行单元。米什金等人 [2016] 探索了三种具有低硬件复杂性的潜在解决方案，并评估了它们对性能的影响。第一个是提交时释放 (release) 的 warpboard，每个warp最多允许执行一条指令。不出所料，他们发现这会对性能产生负面影响，在某些情况下，性能几乎会降低两倍。他们的第二个提议是读取时释放 warpboard，它每次只允许一个指令在操作数收集器中收集操作数。该方案导致他们研究的工作负载最多降低 10%。最后，为了在操作数收集器中实现指令级并行性，他们提出了一种布隆板 (bloomboard) 机制，该机制使用小型<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8&amp;zhida_source=entity" target=_blank rel=noopener>布隆过滤器</a>来跟踪未完成的寄存器读取。相比于（错误地）允许 WAR 冒险，这导致的影响小于百分之几。另外，Gray 进行的一项分析表明，NVIDIA 的 Maxwell GPU 引入了一个“读取依赖屏障”，该屏障由特殊的“控制指令”管理，可用于避免某些指令的 WAR 冒险（参见第 2.2.1 节）。</p><blockquote><p>虽然说发射是第一个指令提前于第二条指令发射的，但是由于储存体冲突，有可能第二条指令先于第一条指令将数据写入了，scoreboard已经解决了raw和waw</p></blockquote><h3 id=332-指令重放处理结构冒险>3.3.2 指令重放：处理结构冒险</h3><p>GPU 流水线中存在许多潜在的结构冒险的原因。例如，寄存器读取阶段可能会用完操作数收集器单元。许多结构冒险的来源与内存系统有关，我们将在下一章更详细地讨论。一般来说，一个 warp 执行的单个内存指令可能需要分解成多个单独的操作。这些单独的操作中的每一个都可以在给定的周期中充分利用流水线的一部分。</p><p>当一条指令在 GPU 流水线中遇到结构冒险时会发生什么？在单线程顺序 CPU 流水线中，标准解决方案是停止较年轻的指令，直到遇到停止条件的指令可以继续执行。至少有两个原因，这种方法在高多线程吞吐量架构中不太理想。首先，考虑到寄存器堆的大尺寸以及支持完整图形流水线分配停止信号所需的许多流水级，可能会影响<a class=link href="https://zhida.zhihu.com/search?content_id=201679542&amp;content_type=Article&amp;match_order=1&amp;q=%e5%85%b3%e9%94%ae%e8%b7%af%e5%be%84&amp;zhida_source=entity" target=_blank rel=noopener>关键路径</a>。流水线停顿周期分布导致需要引入额外的缓冲增加区域。其次，停止来自一个 warp 的指令可能会导致来自其他 warp 的指令在它后面停止。如果这些指令不需要导致停顿的指令所需的资源，则吞吐量可能会受到影响。</p><p>为了避免这些问题，GPU 实现了一种指令重放 (replay) 形式。在一些 CPU 设计中发现了指令重放，当根据具有可变延迟的较早指令推测性地 (speculatively) 调度依赖指令时，它被用作恢复机制。例如，负载可能在一级缓存中命中或未命中，但时钟频率较高的 CPU 设计可能会在多达四个时钟周期内流水线式访问一级缓存。一些 CPU 会根据负载推测唤醒指令，以提高单线程性能。相比之下，GPU 避免推测，因为它往往会浪费能源并降低吞吐量。相反，在 GPU 中使用指令重放以避免阻塞流水线和电路区域和/或因停顿导致的时序开销。</p><p>为了实现指令重放，GPU 可以将指令保存在指令缓冲区中，直到知道它们已完成或指令的所有单独部分都已执行 [Lindholm et al., 2015]。</p><h3 id=参考文献>参考文献</h3><p><a class=link href=https://zhuanlan.zhihu.com/p/510961793 target=_blank rel=noopener>https://zhuanlan.zhihu.com/p/510961793</a></p><p><a class=link href=http://b.7dell.com/index.php/article/95.html target=_blank rel=noopener>http://b.7dell.com/index.php/article/95.html</a></p></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2025/general-purpose_graphics_processor_architecture-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/><div class=article-details><h2 class=article-title>General Purpose_graphics_processor_architecture 编程模型</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了318.8k字·共 94篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#31-单循环近似>3.1 单循环近似</a></li><li><a href=#32-双循环近似>3.2 双循环近似</a></li><li><a href=#33-三循环近似>3.3 三循环近似</a><ol><li><a href=#331-操作数收集器>3.3.1 操作数收集器</a></li><li><a href=#332-指令重放处理结构冒险>3.3.2 指令重放：处理结构冒险</a></li><li><a href=#参考文献>参考文献</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/a_prime_on_hardware_prefetch/ class=category-list-link>a_prime_on_hardware_prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>14</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>47</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_3>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>