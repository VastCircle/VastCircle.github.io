<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='introduction 在本文中，我们提出了一种自上而下的分析 - 一种可行、快速的方法，可以识别乱序 CPU 中的关键瓶颈，这个想法很简单 - 以分层方式进行结构化的深入研究，引导用户前往正确的区域进行调查。将权重分配给树中的节点，以指导用户将分析工作集中在确实重要的问题上，而忽略无关紧要的问题。例如，假设给定的应用程序受到指令获取问题的严重损害;该方法在树的最上层将其分类为 Frontend Bound。用户/工具应（仅）向下钻取层次结构的 Frontend 子树。递归执行向下钻取，直到到达树叶。叶可以指向工作负载的特定停顿，也可以表示具有常见微体系结构症状的问题子集，这些问题可能会限制应用程序的性能。
'><title>A_Top Down_Method_for_performance_analysis_and_couters_architecturee</title>
<link rel=canonical href=https://VastCircle.github.io/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='A_Top Down_Method_for_performance_analysis_and_couters_architecturee'><meta property='og:description' content='introduction 在本文中，我们提出了一种自上而下的分析 - 一种可行、快速的方法，可以识别乱序 CPU 中的关键瓶颈，这个想法很简单 - 以分层方式进行结构化的深入研究，引导用户前往正确的区域进行调查。将权重分配给树中的节点，以指导用户将分析工作集中在确实重要的问题上，而忽略无关紧要的问题。例如，假设给定的应用程序受到指令获取问题的严重损害;该方法在树的最上层将其分类为 Frontend Bound。用户/工具应（仅）向下钻取层次结构的 Frontend 子树。递归执行向下钻取，直到到达树叶。叶可以指向工作负载的特定停顿，也可以表示具有常见微体系结构症状的问题子集，这些问题可能会限制应用程序的性能。
'><meta property='og:url' content='https://VastCircle.github.io/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-04-07T10:39:59+08:00'><meta property='article:modified_time' content='2025-04-07T10:39:59+08:00'><meta name=twitter:title content="A_Top Down_Method_for_performance_analysis_and_couters_architecturee"><meta name=twitter:description content="introduction 在本文中，我们提出了一种自上而下的分析 - 一种可行、快速的方法，可以识别乱序 CPU 中的关键瓶颈，这个想法很简单 - 以分层方式进行结构化的深入研究，引导用户前往正确的区域进行调查。将权重分配给树中的节点，以指导用户将分析工作集中在确实重要的问题上，而忽略无关紧要的问题。例如，假设给定的应用程序受到指令获取问题的严重损害;该方法在树的最上层将其分类为 Frontend Bound。用户/工具应（仅）向下钻取层次结构的 Frontend 子树。递归执行向下钻取，直到到达树叶。叶可以指向工作负载的特定停顿，也可以表示具有常见微体系结构症状的问题子集，这些问题可能会限制应用程序的性能。
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></header><h2 class=article-title><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/>A_Top Down_Method_for_performance_analysis_and_couters_architecturee</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 07, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>6416字</time></div></footer></div></header><section class=article-content><h2 id=introduction>introduction</h2><p>在本文中，我们提出了一种自上而下的分析 - 一种可行、快速的方法，可以识别乱序 CPU 中的关键瓶颈，这个想法很简单 - 以分层方式进行结构化的深入研究，引导用户前往正确的区域进行调查。将权重分配给树中的节点，以指导用户将分析工作集中在确实重要的问题上，而忽略无关紧要的问题。例如，假设给定的应用程序受到指令获取问题的严重损害;该方法在树的最上层将其分类为 Frontend Bound。用户/工具应（仅）向下钻取层次结构的 Frontend 子树。递归执行向下钻取，直到到达树叶。叶可以指向工作负载的特定停顿，也可以表示具有常见微体系结构症状的问题子集，这些问题可能会限制应用程序的性能。</p><h2 id=background>background</h2><p>从鸟瞰图来看，现代无序 CPU 的管道有两个主要部分：前端和后端。前端负责从内存中获取指令并将其转换为微作 （uops）。这些 uop 被馈送到 backend 部分。后端负责根据原始程序的顺序调度、执行和提交（停用）这些 uops。为了保持机器的平衡，一旦准备好供后端消费，交付的 uops 通常会缓冲在某个 “ready-uops-queue” 中。</p><p><figure class=gallery-image style=flex-grow:136;flex-basis:327px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407104450288.png data-size=1045x765><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407104450288.png width=1045 height=765 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407104450288_hu11078082374491171511.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407104450288_hu6890919926433227285.png 1024w" loading=lazy></a></figure></p><p>传统方法 [4][5] 对 stall 进行简单的估计，例如，将某些缓存的未命中次数乘以预定义的延迟：</p><p>​ Stall_Cycles = Σ Penaltyi * MissEventi</p><p>对于现代乱序执行（out-of-order）CPU显然不适用，原因包括以下几点</p><ol><li><strong>停滞重叠</strong>：多个单元并行工作。例如，在处理数据缓存缺失的同时，后续指令可能遇到指令缓存缺失。</li><li><strong>推测执行</strong>：当CPU沿错误的控制路径执行时，错误路径产生的事件远不如正确路径的关键。</li><li><strong>惩罚与工作负载相关</strong>：简单方法假设所有工作负载的惩罚固定，但实际上代价可能受多种因素影响（例如分支间距会增加预测错误成本）。</li><li><strong>预定义事件集的局限性</strong>：复杂微架构可能存在无数潜在问题，但专用事件仅覆盖最常见子集。</li><li><strong>超标量不准确性</strong>：CPU每周期可发射、执行和提交多个操作。某些（如客户端）应用会受限于流水线带宽，因为越来越多的技术已缓解了延迟问题。</li></ol><p>我们通过以下方式解决这些不足：</p><ol><li><strong>核心分类“错误推测”（Bad Speculation）</strong>
在顶层新增名为“错误推测”的主类别（后文详述），用于量化因预测错误导致的停滞以及错误路径执行所浪费的资源。此举不仅优先凸显该问题，还简化了层级中其他模块对硬件计数器的依赖。</li><li><strong>专用硬件计数器设计</strong>
引入十余种严格遵循TopDown方法的定制计数器，以应对其他难点。我们发现，关键在于<strong>确定观察哪一级流水线</strong>以及**“在关键节点计数”**，这能有效解决前文的(1)（停滞重叠）和(3)（惩罚动态性）。例如：不统计总内存访问时长，而仅测量因内存访问未完成导致执行单元闲置的子时长。</li><li><strong>通用事件与占用事件</strong><ul><li>采用<strong>非绑定于“专用缺失事件”的通用事件</strong>，以应对(4)（预定义事件局限性）；</li><li>部分场景使用<strong>占用事件（occupancy events）</strong>，从而解决(5)（超标量不准确性）中的带宽瓶颈问题。</li></ul></li></ol><h2 id=top-down-analysis>top-Down Analysis</h2><p>首先在高级别对 CPU 执行时间进行分类。此步骤会标记（报告高馏分值）某些结构域以供可能进行调查。接下来，用户可以向下钻取到那些被标记的域，并可以安全地忽略所有未标记的域。该过程以分层方式重复，直到确定特定的性能问题或至少确定一小部分候选问题以供潜在调查。</p><h3 id=the-hierarchy>The Hierarchy</h3><p><figure class=gallery-image style=flex-grow:124;flex-basis:298px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407110814695.png data-size=857x689><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407110814695.png width=857 height=689 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407110814695_hu17766472016731465791.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407110814695_hu13096314704510467652.png 1024w" loading=lazy></a></figure></p><p>该层次化分析方法会应用于那些值得关注的热点区域，将可用的流水线槽位划分为四个基本类别：有效指令退役(Retiring)、错误推测(Bad Speculation)、前端受限(Frontend Bound)和后端受限(Backend Bound)。</p><p>假设某个工作负载受数据缓存性能限制，该方法会标记出后端受限(Backend Bound)问题，而前端受限(Frontend Bound)则不会被标记。这意味着用户下一步需要深入分析后端受限类别，暂时无需关注所有前端相关问题。在后端受限类别中进一步分析时，由于假设该应用对缓存敏感，内存受限(Memory Bound)类别会被标记出来。同样地，此时用户可以跳过非内存相关问题的分析。接着，在内存受限类别内部进行深入分析。L1、L2和L3缓存受限(L1/L2/L3 Bound)自然构成了内存受限类别的细分项，每个子项表示工作负载受限于相应级别缓存的程度。在这个例子中，L1缓存受限(L1 Bound)会被标记出来。最后，在L1受限类别下可能存在的具体性能问题包括：由于与早期存储操作重叠导致的加载阻塞(Loads block due to overlap with earlier stores)，或者缓存行分裂加载(cache line split loads)等问题。该方法最终会建议用户重点关注这个领域。</p><h3 id=top-level-breakdown>Top Level breakdown</h3><p>我们选择以发射点（issue point，图1中星号标记处）作为分界，因为这是划分机器前端（frontend）与后端（backend）的天然边界，能够实现高度精确的顶层分类。</p><p>在发射点，我们将每个流水线槽位（pipeline-slot）划分为四个基础类别（如图3所示）：</p><ol><li><strong>前端受限（Frontend Bound）</strong></li><li><strong>后端受限（Backend Bound）</strong></li><li><strong>错误推测（Bad Speculation）</strong></li><li><strong>有效退役（Retiring）</strong></li></ol><ul><li>若微指令（uop）在某周期被发射，它最终要么被退役（retired），要么被取消（cancelled），分别归入<strong>有效退役</strong>或<strong>错误推测</strong>。</li><li>若未发射，则进一步判断是否存在后端阻塞（backend-stall）。后端阻塞是后端因资源不足（如加载缓冲区条目耗尽）触发的反压机制。此时，停滞时间归属于<strong>后端受限</strong>——因为即使前端有更多微指令就绪，也无法继续向下传递。</li><li>若无后端阻塞，则表明前端本应在后端就绪时交付微指令却未能完成，故标记为<strong>前端受限</strong>。这一后端阻塞条件至关重要，我们将在下一节的FetchBubbles定义中详述。</li></ul><h3 id=frontend-bound-category>Frontend Bound category</h3><p>**前端（Frontend）**指的是流水线的起始部分，其功能包括：分支预测器确定下一条待取指令地址、缓存行获取、指令解析以及将指令解码为后端可执行的微操作（uops）。**前端受限（Frontend Bound）**特指当前端无法为后端提供足够的微操作供给，而此时后端其实已准备好接收更多微操作。</p><p>Top-Down方法进一步区分了<strong>延迟停滞（Latency Bound）和带宽停滞（Bandwidth Bound）</strong>：</p><ul><li><strong>指令缓存（i-cache）未命中</strong>归类于<strong>前端延迟受限（Frontend Latency Bound）</strong></li><li><strong>指令解码器效率不足</strong>则归类于<strong>前端带宽受限（Frontend Bandwidth Bound）</strong></li></ul><p>具体定义</p><ul><li><strong>前端延迟（Frontend Latency）</strong>：涵盖所有导致取指饥饿（即无法交付微操作）的情况，无论具体原因是什么。常见的指令缓存（i-cache）和指令TLB（i-TLB）未命中属于此类，但不仅限于此。例如，文献[4]指出**指令长度解码（Instruction Length Decoding）**也可能成为取指瓶颈（该问题与CPU具体设计相关，因此未在图2中展示）。</li><li><strong>分支重定向（Branch Resteers）</strong>：量化因流水线刷新（如分支预测错误）导致的延迟。该指标与**错误推测（Bad Speculation）**紧密关联（我们将在后文详细讨论预测错误成本）。</li></ul><p>此外，该方法还根据<strong>微操作注入单元</strong>对带宽问题进行细分：</p><ol><li><strong>指令解码器</strong>：将主流指令转换为机器可执行的微操作（这是最常见的取指单元）</li><li><strong>复杂指令专用单元</strong>：例如CPUID等指令，通常由独立单元提供长微操作流（属于第二类取指单元）</li></ol><h3 id=bad-speculation-category>Bad Speculation category</h3><p>**错误推测（Bad Speculation）**反映了因错误推测而浪费的流水线槽位，包含两部分内容：</p><ol><li>用于发射但最终未能退役的微操作所占用的槽位；</li><li>因恢复先前错误推测而导致发射流水线阻塞的槽位。</li></ol><p>错误预测惩罚的第三部分（即从正确目标快速重新取指的速度）被归类于<strong>分支重定向（Branch Resteers）</strong>，因其可能与其他前端停滞重叠。</p><p>、将错误推测作为顶层分类是Top-Down分析方法的关键原则：</p><ul><li>它量化了受错误执行路径影响的工作负载比例，直接决定了其他类别观测结果的准确性；</li><li>由于乱序CPU中的大多数计数器会统计推测执行事件，该分类使得底层节点能够复用传统硬件计数器；</li><li>当错误推测占比过高时，用户应优先将其视为需紧急排查的"红旗警告"，再分析其他类别。换言之，确保错误推测占比微小不仅能提升资源利用率，还能增强整个层次结构中所有指标的可靠性。</li></ul><p>该方法进一步将错误推测槽位细分为：</p><ul><li><strong>分支预测错误（Branch Mispredict）</strong>：广为人知的经典情况；</li><li><strong>机器清除（Machine Clears）</strong>：虽同样导致流水线刷新，但成因不同（例如错误数据推测引发的<strong>内存顺序清除（Memory Ordering Nukes）</strong>[7]）。</li></ul><p>这种区分至关重要，因为两者的分析方向截然不同：前者需优化程序控制流以提高分支预测器友好性，后者往往指向非预期的异常情况。</p><h3 id=有效退役retiring类别>有效退役（Retiring）类别</h3><p>该类别统计由"有效微操作"占用的流水线槽位——即最终成功退役的已发射微操作。理想情况下，我们希望所有槽位都归属于此类别（Retiring达到100%时，表示达到了该微架构每周期可退役微操作的理论最大值）。例如：</p><ul><li>若每条指令解码为1个微操作，在4路超标量机器上50%的Retiring值意味着实现了IPC=2
因此，提升Retiring比例可直接增加IPC。</li></ul><p>但需注意，高Retiring值并不代表没有性能优化空间：</p><ul><li><strong>微码序列（Microcode sequences）</strong>：如浮点(FP)辅助操作通常会损害性能（可通过优化避免[7]），这些操作被单独归类为**微序列器（Micro Sequencer）**指标以引起用户关注</li><li><strong>非向量化代码</strong>：高Retiring值可能提示用户需要实现向量化。通过单条指令/微操作完成更多运算（例如第5节的矩阵乘法案例），可显著提升性能</li></ul><p>针对高性能计算(HPC)领域的特殊需求，我们进一步将基础Retiring类别细分为：</p><ul><li><strong>标量浮点运算（FP Arithmetic Scalar）</strong></li><li><strong>向量浮点运算（FP Arithmetic Vector）</strong>
（注：此类细分源于实际领域需求，用户也可根据退役操作分布特征采用其他分类方式）</li></ul><h3 id=backend-bound-category>Backend Bound category</h3><p>该类别表示由于后端缺乏接收资源而导致发射流水线无法交付微操作（uops）的槽位，典型场景包括：</p><ul><li>数据缓存未命中（data-cache misses）</li><li>除法器过载（divider overload stalls）</li></ul><p>后端受限进一步细分为<strong>内存受限（Memory Bound）和核心受限（Core Bound）</strong>，其分类依据是每个周期执行单元（execution units）的占用情况分析。要维持最大IPC，必须确保执行单元持续处于忙碌状态。例如在4路超标量机器中，若稳态代码每周期仅执行≤3个微操作，则无法达到IPC=4的理论峰值，这类次优周期称为<strong>执行停滞（ExecutionStalls）</strong>。</p><p><strong>内存受限</strong>的特征表现为：</p><ul><li>内存子系统相关停滞</li><li>典型现象如：缓存未命中（load missing all caches）导致执行单元短期内资源枯竭</li></ul><p><strong>核心受限</strong>的判定更为复杂，其停滞可能呈现两种形态：</p><ol><li><strong>短周期执行饥饿</strong>：如长延迟除法操作（long latency divide）导致的串行化执行</li><li><strong>执行端口利用率不足</strong>：特定类型微操作所需端口被占满，致使单周期可用端口数减少</li></ol><p>优化建议：</p><ul><li><strong>代码生成优化</strong>：编译器通过改进指令调度（instruction scheduling）可缓解依赖算术操作链（dependent arithmetic operations）导致的核心受限</li><li><strong>向量化技术</strong>：如第5.5节案例所示，能有效提升执行单元利用率</li></ul><h3 id=memory-bound-breakdown-within-backend>Memory Bound breakdown (within Backend)</h3><p>为处理重叠执行带来的干扰，我们引入一种新颖的启发式方法来确定内存访问的实际惩罚。优秀的乱序调度器应能通过让执行单元持续处理不依赖待处理内存访问的有用微操作(uops)，来掩盖部分内存访问停滞。因此，内存访问的真正惩罚发生在调度器没有就绪微操作可供给执行单元时。这通常意味着后续微操作要么在等待待处理的内存访问，要么依赖其他未就绪的微操作。当出现显著的执行停滞(ExecutionStalls)但没有需求加载(demand-load)在任何缓存层级缺失时，表明执行可能受限于该缓存层级本身。</p><p><figure class=gallery-image style=flex-grow:109;flex-basis:262px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/4da324794b437c5e10bc74ec3b378b7c.png data-size=704x644><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/4da324794b437c5e10bc74ec3b378b7c.png width=704 height=644 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/4da324794b437c5e10bc74ec3b378b7c_hu8705716312893654974.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/4da324794b437c5e10bc74ec3b378b7c_hu3327898970585776297.png 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><p>至此我们已讨论了内存子系统的加载操作。存储操作由于x86架构的内存顺序要求，在乱序CPU中会被缓冲并在指令退役（完成）后执行。大多数情况下它们对性能影响较小（如结果部分所示），但仍不可完全忽视。TopDown方法定义了存储受限（Stores Bound）指标，表示为执行端口利用率低且缓冲存储数量高的周期占比。当同时存在加载和存储问题时，基于前述分析我们将优先处理加载相关节点。</p><p>最后，我们采用一个简易启发式方法来区分外部内存受限（Ext. Memory Bound）中的内存带宽（MEM Bandwidth）和内存延迟（MEM Latency）：通过测量内存控制器待返回数据的请求占用率。当占用率超过特定阈值（比如内存控制器可同时处理最大请求数的70%）时，我们将其标记为可能受内存带宽限制；剩余部分则归因于内存延迟。</p><blockquote><p>请求占用率 ： 请求数 / 最大请求数</p></blockquote><h2 id=counter>Counter</h2><p>实际上仅需八个新增定制事件（表1中带星号标记的事件已存在于现有PMU中，例如TotalSlots事件可通过基础Clockticks事件计算得出）</p><p><figure class=gallery-image style=flex-grow:99;flex-basis:239px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141219667.png data-size=1102x1103><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141219667.png width=1102 height=1103 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141219667_hu6980161411273866048.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141219667_hu8565303974674633057.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:158;flex-basis:380px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141330766.png data-size=915x577><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141330766.png width=915 height=577 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141330766_hu2807843687346996910.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141330766_hu9605133610847425846.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:176;flex-basis:423px><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141348095.png data-size=892x506><img src=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141348095.png width=892 height=506 srcset="/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141348095_hu10395396466861373404.png 480w, /2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/image-20250407141348095_hu6136584162321004614.png 1024w" loading=lazy></a></figure></p><div class=table-wrapper><table><thead><tr><th style=text-align:left>事件名称</th><th style=text-align:left>定义</th></tr></thead><tbody><tr><td style=text-align:left><strong>TotalSlots</strong>*</td><td style=text-align:left>发射流水线槽位的总数</td></tr><tr><td style=text-align:left><strong>SlotsIssued</strong>*</td><td style=text-align:left>用于发射操作的已占用发射槽位</td></tr><tr><td style=text-align:left><strong>SlotsRetired</strong>*</td><td style=text-align:left>用于退役（完成）操作的已占用发射槽位</td></tr><tr><td style=text-align:left><strong>FetchBubbles</strong></td><td style=text-align:left>无后端阻塞时未利用的发射槽位</td></tr><tr><td style=text-align:left><strong>RecoveryBubbles</strong></td><td style=text-align:left>因恢复先前错误推测而未利用的发射槽位</td></tr><tr><td style=text-align:left><strong>BrMispredRetired</strong>*</td><td style=text-align:left>已退役的错误预测分支指令</td></tr><tr><td style=text-align:left><strong>MachineClears</strong>*</td><td style=text-align:left>机器清除事件（流水线刷新）</td></tr><tr><td style=text-align:left><strong>MsSlotsRetired</strong>*</td><td style=text-align:left>由微序列器取指单元提供的退役槽位</td></tr><tr><td style=text-align:left><strong>OpsExecuted</strong>*</td><td style=text-align:left>每周期执行的操作数量</td></tr><tr><td style=text-align:left><strong>MemStalls.AnyLoad</strong></td><td style=text-align:left>无微操作执行且至少有一个未完成的加载请求的周期</td></tr><tr><td style=text-align:left><strong>MemStalls.L1miss</strong></td><td style=text-align:left>无微操作执行且至少有一个加载请求未命中L1缓存的周期</td></tr><tr><td style=text-align:left><strong>MemStalls.L2miss</strong></td><td style=text-align:left>无微操作执行且至少有一个加载请求未命中L2缓存的周期</td></tr><tr><td style=text-align:left><strong>MemStalls.L3miss</strong></td><td style=text-align:left>无微操作执行且至少有一个加载请求未命中L3缓存的周期</td></tr><tr><td style=text-align:left><strong>MemStalls.Stores</strong></td><td style=text-align:left>微操作执行较少且无法发射更多存储操作的周期</td></tr><tr><td style=text-align:left><strong>ExtMemOutstanding</strong></td><td style=text-align:left>每周期内存控制器未完成的请求数量</td></tr></tbody></table></div><div class=table-wrapper><table><thead><tr><th style=text-align:left>指标名称</th><th style=text-align:left>公式</th></tr></thead><tbody><tr><td style=text-align:left><strong>前端受限 (Frontend Bound)</strong></td><td style=text-align:left>FetchBubbles / TotalSlots</td></tr><tr><td style=text-align:left><strong>错误推测 (Bad Speculation)</strong></td><td style=text-align:left>(SlotsIssued – SlotsRetired + RecoveryBubbles) / TotalSlots</td></tr><tr><td style=text-align:left><strong>有效退役 (Retiring)</strong></td><td style=text-align:left>SlotsRetired / TotalSlots</td></tr><tr><td style=text-align:left><strong>后端受限 (Backend Bound)</strong></td><td style=text-align:left>1 – (Frontend Bound + Bad Speculation + Retiring)</td></tr><tr><td style=text-align:left><strong>取指延迟受限 (Fetch Latency Bound)</strong></td><td style=text-align:left>FetchBubbles[≥ #MIW] / Clocks</td></tr><tr><td style=text-align:left><strong>取指带宽受限 (Fetch Bandwidth Bound)</strong></td><td style=text-align:left>Frontend Bound – Fetch Latency Bound</td></tr><tr><td style=text-align:left><strong>分支预测错误占比 (#BrMispredFraction)</strong></td><td style=text-align:left>BrMispredRetired / (BrMispredRetired + MachineClears)</td></tr><tr><td style=text-align:left><strong>分支预测错误 (Branch Mispredicts)</strong></td><td style=text-align:left>#BrMispredFraction * Bad Speculation</td></tr><tr><td style=text-align:left><strong>机器清除 (Machine Clears)</strong></td><td style=text-align:left>Bad Speculation – Branch Mispredicts</td></tr><tr><td style=text-align:left><strong>MicroSequencer</strong></td><td style=text-align:left>MsSlotsRetired / TotalSlots</td></tr><tr><td style=text-align:left><strong>BASE</strong></td><td style=text-align:left>Retiring – MicroSequencer</td></tr><tr><td style=text-align:left><strong>#ExecutionStalls</strong></td><td style=text-align:left>(∑OpsExecuted[ = FEW] ) / Clocks</td></tr><tr><td style=text-align:left><strong>Memory Bound</strong></td><td style=text-align:left>(MemStalls.AnyLoad + MemStalls.Stores) / Clocks</td></tr><tr><td style=text-align:left><strong>Core Bound</strong></td><td style=text-align:left>#ExecutionStalls – Memory Bound</td></tr><tr><td style=text-align:left><strong>L1 Bound</strong></td><td style=text-align:left>(MemStalls.AnyLoad – MemStalls.L1miss) / Clocks</td></tr><tr><td style=text-align:left><strong>L2 Bound</strong></td><td style=text-align:left>(MemStalls.L1miss – MemStalls.L2miss) / Clocks</td></tr><tr><td style=text-align:left><strong>L3 Bound</strong></td><td style=text-align:left>(MemStalls.L2miss – MemStalls.L3miss) / Clocks</td></tr><tr><td style=text-align:left><strong>Ext. Memory Bound</strong></td><td style=text-align:left>MemStalls.L3miss / Clocks</td></tr><tr><td style=text-align:left><strong>MEM Bandwidth</strong></td><td style=text-align:left>ExtMemOutstanding[≥ THRESHOLD] / ExtMemOutstanding[≥ 1]</td></tr><tr><td style=text-align:left><strong>MEM Latency</strong></td><td style=text-align:left>(ExtMemOutstanding[≥ 1] / Clocks) – MEM Bandwidth</td></tr></tbody></table></div><p>（注：带<code>*</code>的事件表示该事件通常已存在于现代CPU的PMU中，无需额外硬件支持。）</p><h2 id=有关rocket-chip-的性能计数器>有关rocket chip 的性能计数器</h2><p>这个功能由mhpmevent CSR控制，其计数器的值则有mhpmcounter CSR提供。 mhpmevent的低8位可以取三种取值：0，指令事件；1，微结构事件；2，内存系统事件。同一时刻，性能计数器只能记一种类型的事件。</p><p>在每种类型中，mhpmevent的高56位是一个选取细节事件的bitmap，如果任何一个bitmap使能的事件发生，则会导致mhpmcounter自增。</p><p>在rocket 里</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>  <span style=color:#e06c75>csr</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>io</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>counters</span> <span style=color:#e06c75>foreach</span> <span style=color:#56b6c2>{</span> <span style=color:#e06c75>c</span> <span style=color:#c678dd>=&gt;</span> <span style=color:#e06c75>c</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>inc</span> <span style=color:#c678dd>:</span><span style=color:#56b6c2>=</span> <span style=color:#e5c07b>RegNext</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>perfEvents</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>evaluate</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>c</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>eventSel</span><span style=color:#56b6c2>))</span> <span style=color:#56b6c2>}</span>
</span></span></code></pre></div><p>PerfCounter</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>PerfCounterIO</span><span style=color:#56b6c2>(</span><span style=color:#c678dd>implicit</span> <span style=color:#e06c75>p</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>Parameters</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>extends</span> <span style=color:#e5c07b>CoreBundle</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>with</span> <span style=color:#e5c07b>HasCoreParameters</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>val</span> <span style=color:#e06c75>eventSel</span> <span style=color:#c678dd>=</span> <span style=color:#e5c07b>Output</span><span style=color:#56b6c2>(</span><span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>xLen</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>W</span><span style=color:#56b6c2>))</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>val</span> <span style=color:#e06c75>inc</span> <span style=color:#c678dd>=</span> <span style=color:#e5c07b>Input</span><span style=color:#56b6c2>(</span><span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>log2Ceil</span><span style=color:#56b6c2>(</span><span style=color:#d19a66>1</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>retireWidth</span><span style=color:#56b6c2>).</span><span style=color:#e06c75>W</span><span style=color:#56b6c2>))</span>
</span></span><span style=display:flex><span><span style=color:#56b6c2>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#7f848e>// csr 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>val</span> <span style=color:#e06c75>reg_hpmevent</span> <span style=color:#c678dd>=</span> <span style=color:#e06c75>io</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>counters</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>map</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>c</span> <span style=color:#c678dd>=&gt;</span> <span style=color:#e5c07b>RegInit</span><span style=color:#56b6c2>(</span><span style=color:#d19a66>0.</span><span style=color:#e06c75>U</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>xLen</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>W</span><span style=color:#56b6c2>)))</span> <span style=color:#7f848e>// 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#56b6c2>(</span><span style=color:#e06c75>io</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>counters</span> <span style=color:#e06c75>zip</span> <span style=color:#e06c75>reg_hpmevent</span><span style=color:#56b6c2>)</span> <span style=color:#e06c75>foreach</span> <span style=color:#56b6c2>{</span> <span style=color:#c678dd>case</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>c</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>e</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>=&gt;</span> <span style=color:#e06c75>c</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>eventSel</span> <span style=color:#c678dd>:</span><span style=color:#56b6c2>=</span> <span style=color:#e06c75>e</span> <span style=color:#56b6c2>}</span> <span style=color:#7f848e>// 输出io端口的eventSel 为 reg_hpmvent 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>val</span> <span style=color:#e06c75>reg_hpmcounter</span> <span style=color:#c678dd>=</span> <span style=color:#e06c75>io</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>counters</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>zipWithIndex</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>map</span> <span style=color:#56b6c2>{</span> <span style=color:#c678dd>case</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>c</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>i</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>=&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>WideCounter</span><span style=color:#56b6c2>(</span><span style=color:#e5c07b>CSR</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>hpmWidth</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>c</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>inc</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>reset</span> <span style=color:#c678dd>=</span> <span style=color:#e5c07b>false</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>inhibit</span> <span style=color:#c678dd>=</span> <span style=color:#e06c75>reg_mcountinhibit</span><span style=color:#56b6c2>(</span><span style=color:#e5c07b>CSR</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>firstHPM</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>))</span> <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 这是直接通过指令去更新csr寄存器 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#c678dd>for</span> <span style=color:#56b6c2>(((</span><span style=color:#e06c75>e</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>c</span><span style=color:#56b6c2>),</span> <span style=color:#e06c75>i</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>&lt;-</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>reg_hpmevent</span> <span style=color:#e06c75>zip</span> <span style=color:#e06c75>reg_hpmcounter</span><span style=color:#56b6c2>).</span><span style=color:#e06c75>zipWithIndex</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>writeCounter</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>i</span> <span style=color:#56b6c2>+</span> <span style=color:#e5c07b>CSR</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>firstMHPC</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>c</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>wdata</span><span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>when</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>decoded_addr</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>i</span> <span style=color:#56b6c2>+</span> <span style=color:#e5c07b>CSR</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>firstHPE</span><span style=color:#56b6c2>))</span> <span style=color:#56b6c2>{</span> <span style=color:#e06c75>e</span> <span style=color:#c678dd>:</span><span style=color:#56b6c2>=</span> <span style=color:#e06c75>perfEventSets</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>maskEventSelector</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>wdata</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#e06c75>maskEventSelector</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSel</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>)</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>UInt</span> <span style=color:#56b6c2>=</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// allow full associativity between counters and event sets (for now?)
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#c678dd>val</span> <span style=color:#e06c75>setMask</span> <span style=color:#c678dd>=</span> <span style=color:#56b6c2>(</span><span style=color:#e5c07b>BigInt</span><span style=color:#56b6c2>(</span><span style=color:#d19a66>1</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>eventSetIdBits</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// eventSets.map(_.size).max 就是最多的事件组的事件 ， 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#c678dd>val</span> <span style=color:#e06c75>maskMask</span> <span style=color:#c678dd>=</span> <span style=color:#56b6c2>((</span><span style=color:#e5c07b>BigInt</span><span style=color:#56b6c2>(</span><span style=color:#d19a66>1</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>eventSets</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>map</span><span style=color:#56b6c2>(</span><span style=color:#c678dd>_</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>size</span><span style=color:#56b6c2>).</span><span style=color:#e06c75>max</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>1</span><span style=color:#56b6c2>)</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>maxEventSetIdBits</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>eventSel</span> <span style=color:#56b6c2>&amp;</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>setMask</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>maskMask</span><span style=color:#56b6c2>).</span><span style=color:#e06c75>U</span>
</span></span><span style=display:flex><span>  <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// maxEventSetIDBits = 8 ， 是因为前8位都是选择事件组的吗， 然后然后是选择具体的事件的  
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// eventSetIdBits = 2 , 因为只有3个event 组 ，
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>
</span></span><span style=display:flex><span><span style=color:#c678dd>private</span> <span style=color:#c678dd>def</span> <span style=color:#e06c75>decode</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>counter</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>)</span><span style=color:#c678dd>:</span> <span style=color:#56b6c2>(</span><span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>,</span> <span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>=</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>require</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSets</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>size</span> <span style=color:#56b6c2>&lt;=</span> <span style=color:#56b6c2>(</span><span style=color:#d19a66>1</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>maxEventSetIdBits</span><span style=color:#56b6c2>))</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>require</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSetIdBits</span> <span style=color:#56b6c2>&gt;</span> <span style=color:#d19a66>0</span><span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>(</span><span style=color:#e06c75>counter</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSetIdBits</span><span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span><span style=color:#56b6c2>,</span> <span style=color:#d19a66>0</span><span style=color:#56b6c2>),</span> <span style=color:#e06c75>counter</span> <span style=color:#56b6c2>&gt;&gt;</span> <span style=color:#e06c75>maxEventSetIdBits</span><span style=color:#56b6c2>)</span> <span style=color:#7f848e>// 拆成组和具体的事件
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#e06c75>evaluate</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSel</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>UInt</span><span style=color:#56b6c2>)</span><span style=color:#c678dd>:</span> <span style=color:#e5c07b>Bool</span> <span style=color:#56b6c2>=</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>val</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>set</span><span style=color:#56b6c2>,</span> <span style=color:#e06c75>mask</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>=</span> <span style=color:#e06c75>decode</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>eventSel</span><span style=color:#56b6c2>)</span> 
</span></span><span style=display:flex><span>    <span style=color:#c678dd>val</span> <span style=color:#e06c75>sets</span> <span style=color:#c678dd>=</span> <span style=color:#c678dd>for</span> <span style=color:#56b6c2>(</span><span style=color:#e06c75>e</span> <span style=color:#c678dd>&lt;-</span> <span style=color:#e06c75>eventSets</span><span style=color:#56b6c2>)</span> <span style=color:#c678dd>yield</span> <span style=color:#56b6c2>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>require</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>e</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>hits</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>getWidth</span> <span style=color:#56b6c2>&lt;=</span> <span style=color:#e06c75>mask</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>getWidth</span><span style=color:#56b6c2>,</span> <span style=color:#98c379>s&#34;too many events </span><span style=color:#98c379>${</span><span style=color:#e06c75>e</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>hits</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>getWidth</span><span style=color:#98c379>}</span><span style=color:#98c379> wider than mask </span><span style=color:#98c379>${</span><span style=color:#e06c75>mask</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>getWidth</span><span style=color:#98c379>}</span><span style=color:#98c379>&#34;</span><span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 利用check 方式比对mask 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>      <span style=color:#e06c75>e</span> <span style=color:#e06c75>check</span> <span style=color:#e06c75>mask</span>  <span style=color:#7f848e>// 它做的是一个独热的形式，就是说这么多事件有其中一条事件被使能，就能够counter+1 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#56b6c2>}</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>sets</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>set</span><span style=color:#56b6c2>)</span> <span style=color:#7f848e>// 这里得到的就是一个bool 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#56b6c2>}</span>
</span></span></code></pre></div><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2025/a_scalable_multi_path_microarchitecture_for_efficient_gpu_control_flow/><div class=article-details><h2 class=article-title>A_scalable_multi_path_microarchitecture_for_efficient_GPU_Control_Flow</h2></div></a></article><article><a href=/2025/memory_dependence_prediction_using_store_sets/><div class=article-details><h2 class=article-title>Memory_dependence_prediction_using_store_sets</h2></div></a></article><article><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/><div class=article-details><h2 class=article-title>Gaze_into_the_Pattern__for_Hardware_Prefetching</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了394.9k字·共 104篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#introduction>introduction</a></li><li><a href=#background>background</a></li><li><a href=#top-down-analysis>top-Down Analysis</a><ol><li><a href=#the-hierarchy>The Hierarchy</a></li><li><a href=#top-level-breakdown>Top Level breakdown</a></li><li><a href=#frontend-bound-category>Frontend Bound category</a></li><li><a href=#bad-speculation-category>Bad Speculation category</a></li><li><a href=#有效退役retiring类别>有效退役（Retiring）类别</a></li><li><a href=#backend-bound-category>Backend Bound category</a></li><li><a href=#memory-bound-breakdown-within-backend>Memory Bound breakdown (within Backend)</a></li></ol></li><li><a href=#counter>Counter</a></li><li><a href=#有关rocket-chip-的性能计数器>有关rocket chip 的性能计数器</a></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/prefetch/ class=category-list-link>prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/ class=category-list-link>基础概念<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class=category-list-link>操作系统<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83/ class=category-list-link>环境<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>17</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>56</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_4>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>