<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='摘要 硬件预取（Hardware prefetching）是隐藏长数据访问延迟最常用的技术之一。为了解决硬件预取面临的挑战，架构师提出在空间区域（spatial region）的粒度上检测并利用空间局部性。当一个新的区域被激活时，他们尝试基于系统级环境特征（如触发指令或数据地址）查找类似的先前访问区域，以进行足迹预测。然而，我们发现这种基于上下文的预测无法捕捉访问模式的本质特征，导致灵活性和实用性受限，并使预取性能次优。在本文中，我们受到存储访问的时间特性的启发，注意到空间足迹内部的时间相关性是空间模式的关键特征。为此，我们提出了一种简单高效的硬件空间预取器——Gaze，它巧妙地利用足迹内部的时间相关性来高效表征空间模式。同时，我们发现利用由空间流（spatial streaming）生成的空间足迹时，存在一个独特但未解决的挑战，即这些足迹表现出极高的访问密度。因此，我们进一步为 Gaze 设计了一个专门的两阶段方法，以缓解传统方案中常见的过度预取（over-prefetching）问题。我们进行了全面且多样化的实验，结果表明 Gaze 能够在更广泛的场景中有效提升性能。具体而言，与最新的低成本方案 PMP 和 vBerti 相比，Gaze 在单核环境下分别提升 5.7% 和 5.4%，在八核环境下分别提升 11.4% 和 8.8%。
'><title>Gaze_into_the_Pattern__for_Hardware_Prefetching</title>
<link rel=canonical href=https://VastCircle.github.io/2025/gaze_into_the_pattern__for_hardware_prefetching/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='Gaze_into_the_Pattern__for_Hardware_Prefetching'><meta property='og:description' content='摘要 硬件预取（Hardware prefetching）是隐藏长数据访问延迟最常用的技术之一。为了解决硬件预取面临的挑战，架构师提出在空间区域（spatial region）的粒度上检测并利用空间局部性。当一个新的区域被激活时，他们尝试基于系统级环境特征（如触发指令或数据地址）查找类似的先前访问区域，以进行足迹预测。然而，我们发现这种基于上下文的预测无法捕捉访问模式的本质特征，导致灵活性和实用性受限，并使预取性能次优。在本文中，我们受到存储访问的时间特性的启发，注意到空间足迹内部的时间相关性是空间模式的关键特征。为此，我们提出了一种简单高效的硬件空间预取器——Gaze，它巧妙地利用足迹内部的时间相关性来高效表征空间模式。同时，我们发现利用由空间流（spatial streaming）生成的空间足迹时，存在一个独特但未解决的挑战，即这些足迹表现出极高的访问密度。因此，我们进一步为 Gaze 设计了一个专门的两阶段方法，以缓解传统方案中常见的过度预取（over-prefetching）问题。我们进行了全面且多样化的实验，结果表明 Gaze 能够在更广泛的场景中有效提升性能。具体而言，与最新的低成本方案 PMP 和 vBerti 相比，Gaze 在单核环境下分别提升 5.7% 和 5.4%，在八核环境下分别提升 11.4% 和 8.8%。
'><meta property='og:url' content='https://VastCircle.github.io/2025/gaze_into_the_pattern__for_hardware_prefetching/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-02-02T22:53:52+08:00'><meta property='article:modified_time' content='2025-02-02T22:53:52+08:00'><meta name=twitter:title content="Gaze_into_the_Pattern__for_Hardware_Prefetching"><meta name=twitter:description content="摘要 硬件预取（Hardware prefetching）是隐藏长数据访问延迟最常用的技术之一。为了解决硬件预取面临的挑战，架构师提出在空间区域（spatial region）的粒度上检测并利用空间局部性。当一个新的区域被激活时，他们尝试基于系统级环境特征（如触发指令或数据地址）查找类似的先前访问区域，以进行足迹预测。然而，我们发现这种基于上下文的预测无法捕捉访问模式的本质特征，导致灵活性和实用性受限，并使预取性能次优。在本文中，我们受到存储访问的时间特性的启发，注意到空间足迹内部的时间相关性是空间模式的关键特征。为此，我们提出了一种简单高效的硬件空间预取器——Gaze，它巧妙地利用足迹内部的时间相关性来高效表征空间模式。同时，我们发现利用由空间流（spatial streaming）生成的空间足迹时，存在一个独特但未解决的挑战，即这些足迹表现出极高的访问密度。因此，我们进一步为 Gaze 设计了一个专门的两阶段方法，以缓解传统方案中常见的过度预取（over-prefetching）问题。我们进行了全面且多样化的实验，结果表明 Gaze 能够在更广泛的场景中有效提升性能。具体而言，与最新的低成本方案 PMP 和 vBerti 相比，Gaze 在单核环境下分别提升 5.7% 和 5.4%，在八核环境下分别提升 11.4% 和 8.8%。
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></header><h2 class=article-title><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/>Gaze_into_the_Pattern__for_Hardware_Prefetching</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 02, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>9591字</time></div></footer></div></header><section class=article-content><h2 id=摘要>摘要</h2><p>硬件预取（Hardware prefetching）是隐藏长数据访问延迟最常用的技术之一。为了解决硬件预取面临的挑战，架构师提出在空间区域（spatial region）的粒度上检测并利用空间局部性。当一个新的区域被激活时，他们尝试基于系统级环境特征（如触发指令或数据地址）查找类似的先前访问区域，以进行足迹预测。然而，我们发现这种基于上下文的预测无法捕捉访问模式的本质特征，导致灵活性和实用性受限，并使预取性能次优。在本文中，我们受到存储访问的时间特性的启发，注意到空间足迹内部的时间相关性是空间模式的关键特征。为此，我们提出了一种简单高效的硬件空间预取器——Gaze，它巧妙地利用足迹内部的时间相关性来高效表征空间模式。同时，我们发现利用由空间流（spatial streaming）生成的空间足迹时，存在一个独特但未解决的挑战，即这些足迹表现出极高的访问密度。因此，我们进一步为 Gaze 设计了一个专门的两阶段方法，以缓解传统方案中常见的过度预取（over-prefetching）问题。我们进行了全面且多样化的实验，结果表明 Gaze 能够在更广泛的场景中有效提升性能。具体而言，与最新的低成本方案 PMP 和 vBerti 相比，Gaze 在单核环境下分别提升 5.7% 和 5.4%，在八核环境下分别提升 11.4% 和 8.8%。</p><h2 id=introduction>introduction</h2><p>在过去的几十年里，主存的容量经历了指数级增长；然而，主存与CPU之间的延迟差距（即“存储墙”）并未得到显著改善[36]、[57]、[89]。此外，随着大数据[53]和深度学习[54]等内存密集型应用的激增，这种性能差距正变得越来越严重。</p><p>硬件预取是一种广泛使用且被深入研究的方法，旨在弥合这一差距[27]、[36]。通过推测并在CPU明确请求之前主动将数据块预取到缓存，数据预取可以隐藏长数据访问延迟，并缓解存储子系统的压力[59]。硬件预取器通过观察内存请求来提取内存访问模式。当检测到模式可能重复时，它们会尝试预取未来可能访问的数据[27]。因此，准确刻画程序行为对预取性能至关重要。然而，在实际应用中，多样化的访问行为以及乱序调度等干扰因素，使得在保持硬件简洁性的同时实现高效预取变得极具挑战性。</p><p>为了解决这些挑战，架构师提出了检测和利用空间局部性的方法[13]、[17]–[19]、[21]、[22]、[29]、[48]、[51]、[52]、[58]、[65]、[67]、[70]、[75]、[78]、[79]、[83]。一种有效的策略是利用存储区域（如4KB物理页）粒度上的空间模式[13]、[17]、[19]、[22]、[29]、[48]、[52]、[78]、[79]、[83]。存储区域的空间模式通常表示为其空间足迹的位向量[22]。基于空间模式的预取器通过跟踪多个活动内存区域来学习空间模式，并利用这些模式预测新激活区域的可能足迹。已有大量研究表明，空间足迹预测可以有效减少强制性缺失（compulsory misses）[13]、[22]、[27]、[48]、[52]，并适用于相似循环[48]、重复数据布局[13]、[27]、[47]、[78]，以及数据结构遍历[13]、[78]。此外，它还可以在乱序调度环境下保持稳健性[17]。</p><p>为了准确识别相似区域进行足迹预测，许多研究人员提出使用系统级环境特征（如触发指令或数据地址）来表征空间模式[52]。这是因为当系统在访问新区域时表现出相似特征时，模式很可能会再次出现。例如，在PC+地址（PC+Address）方案中，相同指令访问相同地址意味着可能会重现相同的足迹[13]。尽管这种基于上下文的表征方法在微架构技术（如分支预测[74]、值预测[55]和缓存替换策略[41]）中被广泛使用，但在空间模式预测中并不如预期那样高效。</p><p>图1绘制了几种空间模式预取表征方案的性能表现（详细方法见§IV-A）。“-opt”表示最近文献中的优化版本。横轴显示了来自CloudSuite[30]的scale-out服务器工作负载，其中包含大量不规则访问。纵轴则呈现了SPEC17[11]的实验结果。结合PC和数据地址进行精细化表征的预取器确实能实现较高加速比，但需要大量硬件资源。而采用较粗粒度表征的方法虽然更具硬件友好性，但在复杂工作负载中会产生大量误预测。此外，即使是优化方案也未能完全解决这些问题，严重限制了灵活性和实用性。</p><p><figure class=gallery-image style=flex-grow:165;flex-basis:398px><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233714536.png data-size=574x346><img src=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233714536.png width=574 height=346 srcset="/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233714536_hu847725272767874917.png 480w, /2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233714536_hu161907399799803115.png 1024w" loading=lazy></a></figure></p><p>在本文中，我们重新思考如何从本质上刻画空间模式。由于访问行为本身通常表现出时间相关性[84]，因此由这些行为生成的空间模式也应具有类似的特性。受此启发，我们观察到，当空间模式重复出现时，其内部的时间相关性往往也会以相似方式重现。也就是说，足迹内部的访问顺序在表征空间模式方面起着至关重要的作用。</p><p>基于这一观察，我们提出了一种名为Gaze2的空间预取器，该预取器创新性地利用足迹内部的时间相关性来高效刻画空间模式。然而，充分利用这一时间特性在实际中并不可行。相反，我们的研究表明，仅关注前几个初始访问即可实现高效预测。因此，Gaze 选择利用足迹内部的一小部分时间相关性，以保持简洁性。此外，传统基于空间模式的预取器使用位向量表示足迹，未能捕捉访问顺序的任何时间信息。与其引入额外的元数据，Gaze 直接将时间信息无缝融入经验搜索过程，从而增强了硬件设计的简洁性和兼容性。</p><p>此外，我们发现由空间流（spatial streaming）生成的足迹通常表现出极高的访问密度。如果误用此模式，可能导致严重的过度预取（over-prefetching），因为它可能指示预取几乎整个区域。然而，过于保守的策略又可能错失大量预取机会。为了解决这一独特挑战，我们进一步为Gaze设计了一种专门的两阶段策略，以在整个区域的需求和过度激进性之间动态平衡预取力度。</p><p>我们使用涵盖各种真实应用的基准测试对Gaze进行评估。实验包括单核、多核和带宽受限环境等多个场景。通过与七种最先进的预取器进行广泛对比，我们表明Gaze可以在更广泛的场景下有效提升性能。具体而言，在整个单核评估集中，Gaze 相比 PMP 和 vBerti [65] 分别提升了 5.7% 和 5.4%；在八核仿真中，分别提升了 11.4% 和 8.8%。此外，Gaze 的存储开销几乎与 PMP 相同，比 Bingo [13] 低 31 倍。同时，其面积和能耗开销远低于 PMP 和 vBerti。</p><p>本论文的主要贡献如下：</p><ul><li>我们指出基于空间模式的预取器的薄弱环节在于其基于环境上下文的模式表征方法，这极大限制了其灵活性和实用性。</li><li>通过利用足迹内部的时间相关性来表征空间模式，所提出的 Gaze 可以更准确地预测即将访问的足迹。此外，Gaze 将这一时间信息直接集成到经验搜索过程中，从而保持了硬件的简洁性。</li><li>我们进一步针对空间流优化 Gaze，提出了一种两阶段策略，以在整个区域需求和过度激进性之间取得平衡。</li><li>我们评估了 Gaze 以及七种最新的预取器，覆盖了来自 SPEC06、SPEC17、Ligra、PARSEC 和 CloudSuite 基准测试套件的 201 条不同的真实应用轨迹。实验结果表明，Gaze 能够在各种场景下有效提升性能。</li></ul><h2 id=ii-相关工作与研究动机><strong>II. 相关工作与研究动机</strong></h2><h3 id=a-近期基于空间模式的机制><strong>A. 近期基于空间模式的机制</strong></h3><p>基于空间模式的预取通过直接记录某一区域的足迹来学习该区域的空间模式，并尝试找到其他相似区域以利用所学的经验进行预取 [22], [52]。这一潜力已被许多前期工作所证明 [13], [17], [19], [22], [29], [48], [52], [78], [79], [83]。</p><p>空间足迹预测器（SFP）[52]首次示范了基于空间模式的预取的常见结构和逻辑。SFP提议使用程序计数器（PC）以及一些数据地址的位来表征模式，从而提高预取准确性，并使预取器能够消除强制缺失。空间模式预测 [22] 在SFP的基础上进行了改进，使用了更大的区域大小和缓存行大小。</p><p><strong>细粒度空间预取</strong>通常通过几个环境上下文来表征模式，如激活的指令和数据地址。空间内存流（SMS）[78]提议使用PC+偏移量（Offset3）。SMS还使用一个过滤表（FT）来过滤掉单一比特的空间足迹。批量内存访问预测与流式传输 [83] 进一步减少了SMS的能量消耗。</p><p>长触发事件（PC+地址）携带（PC+偏移量）。受TAGE [74] 分支预测器的启发，Bingo首次尝试使用较长的触发事件来找到精确匹配。如果没有找到匹配，则使用较短的事件来找到近似匹配。因此，与SMS相比，Bingo通过更多的失配覆盖了相似的准确度（由精确匹配维持）。</p><p>结合触发指令和数据地址，能够准确捕获模式开始时的上下文特征。因此，匹配区域的预测通常会获得很高的准确性。然而，由于微小的上下文差异，相似的模式通常与不同的事件相关联，导致严重的数据冗余 [13], [48]。因此，为了实现可观的覆盖率，需要大量的存储开销和较长的学习周期 [17], [48]，这使得预取器不切实际。SMS和Bingo在实现最佳性能时都需要超过100KB的存储 [13], [78]。</p><p>**粗粒度空间预取。**到目前为止，几项最近的研究尝试采用更简化的方式。它们选择更适合硬件的粗粒度事件，并采用各种方法来缓解由此带来的低准确度。粗粒度方法仅通过触发指令或数据地址的几位来表征模式。</p><p>双重空间模式预取器（DSPatch）[17]在指令粒度上表征空间模式（即使用PC）。同时，它为每个PC保持两个最新的模式，并且可以通过预取同时/任一模式中出现的数据块来进一步提高准确性/覆盖率。</p><p>模式合并预取器（PMP）[48]通过仅使用偏移量进一步简化了表征，确保在短时间内几乎总能找到匹配。这几乎消除了由于执行新指令或访问未见过的地址而丢失预取机会的可能性。此外，对于每个偏移量，PMP合并了最近的32个模式，意味着它们的共同特征得以保留和利用。</p><h3 id=b-现有局限性与研究动机><strong>B. 现有局限性与研究动机</strong></h3><p>传统的基于上下文的方法在捕获关键访问特征时存在重大局限性。如图 1 所示，低成本方案难以适用于复杂工作负载，而引入更多的环境上下文信息又会导致难以接受的硬件成本。尽管已有研究提出了基于带宽利用率的动态调整 [17]、模式合并 [48] 和长短事件联合关联 [13] 来缓解这一问题，但这些方法的缺陷仍然未能彻底解决，严重限制了基于空间模式的预取的灵活性和实用性。因此，我们的研究进一步探索模式本身，以开发更高效的表征方法。</p><p>内存访问通常表现出时间局部性，即已访问的数据在短时间内可能会被再次访问 [27]。时间相关性（Temporal Correlation）类似于时间局部性，指的是一组地址倾向于按相同的顺序被重复访问 [84]。它被广泛应用于识别指针追踪和图处理等不规则模式 [12], [40], [49], [66], [79], [85], [87], [88]。由于空间模式是由内存访问产生的，它们自身也应该表现出类似的时间特性。这意味着，模式复现可能与内部访问的顺序一致。</p><p>图 2 上半部分展示了从 fotonik3d_s 负载中提取的几个空间区域的详细访问足迹。其中：</p><ul><li>Region A 和 Region C 具有相同的空间足迹和访问顺序，即它们的被访问块是对齐的，且访问顺序相同。</li><li>Region A 和 Region B 之间的空间足迹和访问顺序差异较大，因此它们属于不同模式。</li></ul><p>由于足迹内部的时间相关性是由访问行为本身决定的，利用这一特性进行精细粒度模式表征可能是一个可行的方向。</p><p>假设我们观察图 2 所示的场景：</p><ul><li>t0 时刻（见下半部分），Region A、B 和 C 先前的模式已被学习，而 Region D 此刻刚刚被激活。四个区域的触发访问（红色标记）是对齐的，因此它们在定义上是相似的。然而，Region A、B 和 C 之间的模式存在冲突，因此难以确定 Region D 的最佳预取模式。</li><li>仅依赖触发偏移量是不够的，而引入附加的上下文信息（如 PC 或完整地址）会导致不可接受的元数据开销。</li><li>t2 时刻，在额外观察了两次内存访问之后，Region B 和 Region D 之间的相似性变得明显。因此，在 t2 时刻，我们可以做出高置信度的预测。</li></ul><p>这种方法能够在不大幅增加元数据开销的情况下，实现细粒度模式表征。</p><p><figure class=gallery-image style=flex-grow:137;flex-basis:330px><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232304939.png data-size=676x491><img src=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232304939.png width=676 height=491 srcset="/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232304939_hu1848116493838343710.png 480w, /2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232304939_hu2640066683923030370.png 1024w" loading=lazy></a></figure></p><p>然而，这一思想并不能直接应用于基于空间模式的预取，主要原因有两点：
➊ 它与传统的硬件设计不兼容；
➋ 它引入了额外的复杂性。</p><p>第一个挑战在于，传统方法是基于触发访问（trigger access）进行预测的，而要获取时间相关性，需要额外的观察。
第二个挑战在于，存储和利用时间信息的成本较高。</p><p>因此，为了保持方法的简单性和高效性，我们需要进行精心设计，否则其效果可能还不如现有的细粒度方法。</p><h2 id=iii-gaze空间预取器>III. Gaze空间预取器</h2><p>我们提出了Gaze，据我们所知，它是第一个利用足迹内部时间相关性来高效表征空间模式的空间预取器。为了平衡硬件复杂度和性能，Gaze利用区域的前两个访问信息（§III-B）。这种简化使得Gaze能够将时间特征提取无缝集成到现有硬件设计中，而无需额外的元数据存储。同时，Gaze引入了一种专用的双阶段方法，以减轻在常规方案中，当利用由空间流生成的高密度足迹时，常常出现的过度预取问题（§III-C）。Gaze被设计并主要评估为L1D预取器。然而，它也可以放置在L2C，与现有的商业L1D预取器IP-stride一起工作。</p><h3 id=a-设计概述>A. 设计概述</h3><p>图3展示了Gaze的设计。中间的子图（图3b）显示了设计概览，而左侧子图（图3a）和右侧子图（图3c）分别展示了详细的学习和预取过程。图3b突出了关键创新，包括使用来自前两个访问的时间信息（细节在§III-B中讨论）以及专用的激进性控制路径（§III-C）。</p><p>如图3b所示，Gaze在缓存加载时进行训练。与传统的基于空间模式的预取器[13]，[48]，[78]类似，Gaze由三个主要组件组成：过滤表（FT）、累积表（AT）和模式历史模块（PHM）。FT用于过滤掉单比特空间模式，表示在跟踪期间区域内只有一个块被需求。AT用于跟踪所有活动区域。PHM用于学习访问模式，并基于学习到的经验发出预取。任何新激活的区域首先会在FT中记录，并且只有在到达第二次不同的加载访问后，才会被AT跟踪。Gaze还采用了一个预取缓冲区（PB），高效存储预取地址，因为单个位向量通常包含多个具有相同起始地址（即区域编号）的请求。此外，PB还帮助平滑预取的发出。</p><p>访问流程。加载到达时，Gaze首先检查AT，以查看所访问的区域是否正在跟踪（➊），如果是，Gaze将更新相应的足迹。否则，Gaze会查找FT（➋）。如果找到该区域，表示它曾经激活过，Gaze将开始在AT中跟踪它（➌）。与以前的提案不同，Gaze还会将触发偏移、第二个偏移以及触发PC发送到PHM进行预取（➍）。这是因为Gaze选择结合前两个访问之间的时间相关性，这在此时可用。如果需要更多访问，则该步骤将被延迟。传统方法[13]，[17]，[48]，[78]通过触发访问而不是第二次访问唤醒预取过程。在接收到这些信息后，PHM决定是否触发该区域的预取。如果触发，则相应的预取模式将被发送到PB，准备预取（➎）。对于每个正在跟踪的区域，一旦它被停用（例如，其中一个缓存块被从缓存中驱逐，或者其相关的跟踪条目因不活动而被LRU策略从AT中驱逐），累积结束，并将位向量发送到PHM（➏）进行模式学习。</p><p>AT中的每个条目用于跟踪一个活动区域，我们引入了两个额外的6位字段来存储该区域最后两个访问的偏移，这些偏移与新访问一起，将共同计算最后两个步长。AT根据这两个步长（➐）决定是否执行基于区域的步长预取（作为备份预取）和激进性提升。</p><p><figure class=gallery-image style=flex-grow:250;flex-basis:600px><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232532491.png data-size=1524x609><img src=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232532491.png width=1524 height=609 srcset="/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232532491_hu3768191653677687458.png 480w, /2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202232532491_hu8193013107137162743.png 1024w" loading=lazy></a></figure></p><h3 id=b-模式表征>B. 模式表征</h3><p>为了识别足迹内部特征，Gaze需要等待几个初始访问。因此，最关键的设计选择是用于提取时间相关性的访问次数。这要求Gaze在强干扰（如乱序调度）存在的情况下，保持并观察所有最近激活的区域，通过它们最近访问的块来区分空间模式。此外，这也意味着会错失一些预取机会。因此，等待过多的访问会带来负面影响。为了在性能和成本之间找到良好的平衡，我们首先探讨了使用的时间信息量与加速、准确性和覆盖率等效率之间的关系。当两个区域的初始访问在空间足迹和时间顺序上对齐时，我们认为它们是相似的。图4展示了将所需对齐的初始访问次数从一个扩展到最多四个的效果。结果是整个评估集的平均值。我们依次连接这些访问的偏移量来形成索引事件。当仅使用触发偏移时，模式历史表（PHT）的大小为64，因为在一个4KB区域内有64个不同的偏移且没有包含指令信息。然而，当考虑更多的访问时，完整的PHT变得不切实际且低效。因此，在这些情况下，为了简化，我们使用了256条入口的全关联历史表，其消耗不到3KB。如图4所示，如果我们要求前四个需求块在空间和时间上都必须对齐，预取准确性从56%提高到90%，这表明访问行为的成功表征。然而，预取机会显著丧失，导致IPC和覆盖率下降。当我们选择仅使用前两个访问时，达到了理想的平衡，这在IPC上提供了3%的提升，在准确性上提供了35%的提升，同时覆盖率的减少几乎可以忽略不计。当使用的偏移数量再次增加时，准确性的边际提升是以IPC和覆盖率的显著下降为代价的。</p><p>基于这一见解，我们决定利用前两个访问之间的时间相关性来表征空间模式。这一选择带来了三个主要优势。首先，与传统的依赖多样化程序上下文的细粒度方法相比，这种方法显著减少了存储开销。其次，它平衡了性能、准确性和覆盖率，确保及时的预取并最小化乱序调度带来的干扰。第三，它可以无缝集成到近期的硬件设计中。Gaze利用现有逻辑来捕捉前两个偏移，并以不增加额外元数据开销的方式存储模式，保持简洁性和兼容性。具体而言，最近的方法使用FT来使仅访问一次的区域无效，这使我们能够在FT将有效区域发送到AT时获取这两个偏移（图3b中的➋）。此外，我们将第一个偏移作为索引，第二个偏移作为标签来存储模式，在表查找过程中本质上验证它们的顺序。</p><p>此外，为了保持高准确性，Gaze采用了严格的匹配机制，当只有一个访问匹配而另一个不匹配时，防止唤醒预取。这与Bingo [13]、TAGE [74]和Domino [12]中采用的机制略有不同，这些机制即使在部分匹配的情况下也能进行预测。我们限制这种能力，主要是因为前两个访问之间的时间相关性是一个关键特征。然而，当候选区域未能找到匹配时，尽管其即将到来的模式可能很容易跟随，我们可能会错失预取机会。为了弥补这一点，我们通过备用预取器增强了跟踪结构。具体细节将在与我们专用的双阶段激进性控制一起在§III-C中进一步讨论。</p><h3 id=c-向空间流式处理的增强>C. 向空间流式处理的增强</h3><p>空间流式处理指的是长期的空间跨越访问现象 [27]。尽管过去几十年对空间流式处理进行了广泛的研究 [37]–[39]，[50]，[71]，[91]，我们仍然观察到在利用其空间足迹时存在一个独特的未解决挑战。具体来说，我们发现，由空间流式处理生成的足迹通常表现出极高的访问密度，尤其是当跨越为1时，这意味着在用于预取时，几乎会为候选区域中的所有块发出推测性预取。显然，空间流式处理可以从这种高激进性中大大受益。然而，实际上，各种访问模式往往以交错的方式表现出来，如果过度使用这种高密度的足迹，产生的大量无效预取可能会导致显著的缓存污染和外部带宽瓶颈。例如，图5提供了Ligra中基于BFS的图处理算法的伪代码。该算法分配一个临时空间，称为Frontier，用于存储当前级别中将被处理的稀疏分布的顶点。因此，遍历Frontier（在函数BFS_forward中）会产生同时包含不规则访问和空间流式处理的访问模式。</p><p>为了解决这个挑战，像许多之前的方法 [38]，[71]，[91]，我们使用基于PC的机制。具体来说，我们部署了一个密集PC表（DPCT）来记录最近的密集PC，一个密集计数器（DC）来跟踪最近密集足迹的频率。我们使用这两个结构进行双重检查，并采用两阶段方法来逐步增加预取激进性。</p><p><strong>学习阶段</strong>。空间流式处理检测如图3a上部所示。当我们跟踪完一个区域，其初始两个访问的块是块0和块1（即图中的r）时，我们检查它是否是高度密集的，即它的所有块是否都已被访问。如果是，我们将其触发指令记录到DPCT中，并增加DC。否则，我们减少DC，其中较大的值促使快速减少。</p><p>**预取阶段。**我们采用两阶段方法来调整预取的激进性，尝试将此密集模式应用于候选区域。在第一阶段，对于候选区域，我们检测其展示空间流式处理的信心级别，并相应地分配初始预取激进性。在第二阶段，我们根据随后的访问动态调整预取的激进性，逐步增加激进性。</p><p>阶段1。如图3c上部所示，当为可能被空间流式处理完全需求的区域p发出预取时，如果触发指令最近被标记为密集PC或DC已饱和，我们分配适中的激进性：将前16个块预取到L1D，将剩余的块预取到L2C。我们经验性地将具有较高激进性的初始块数设置为16（即区域的四分之一），以避免错失预取机会，同时不至于过于激进。否则，如果DC饱和度为一半，表示p成为密集区域的概率较低，我们只将前16个块预取到L2C。如果触发指令未被标记或DC不够大，我们则不进行预取。同时，在将该区域插入AT时，我们设置stride_flag标记。这使得AT在该区域后续展示流式处理行为时，能够预取其余块。</p><p>阶段2。AT将跟踪所有标记的区域。对于每个区域，我们计算最后三个访问的两个跨越。如果这两个跨越都等于1，我们将若干后续块提升到L1D（见图3c上部）。图3b下部显示了PB如何合并提升模式和原始预取模式。这种基于跨越的方法还可以作为当我们的严格匹配机制（见§III-B）未能预测时的备选预测器。如图3c下部所示，如果未找到匹配，则在跟踪时也会设置该区域的stride_flag。一般来说，对于标记的区域，一旦最后两个跨越匹配，就会激活基于区域的跨越预取。</p><p>我们基于区域的跨越预取与其他基于跨越的机制之间的差异如下。首先，它具有双重目的：促进激进性并捕捉潜在的错失机会（图3b中的➐）。其次，它利用现有结构，例如AT，并在区域级别操作，而不是全局或每个PC视图，这避免了需要新的跟踪结构。因此，为了保持简洁性，不处理诸如多个跨越之类的复杂场景。</p><h3 id=d-模式历史模块>D. 模式历史模块</h3><p>如图3b所示，除了负责处理§III-C中提到的大规模空间流式处理的DPCT和DC（简化表示为案例1）之外，PHM还包括一个模式历史表（PHT），用于处理典型场景（简化表示为案例2）。如前所述，如果一个区域的前两个访问是空间相邻并且发生在区域的开头，那么DPCT和DC将学习到该模式。否则，将使用PHT来学习该模式。同样，对于候选区域的足迹预测，PHM根据其前两个访问的块来调用相应的结构。此外，PHT会将所有块预取到L1D中。</p><h3 id=e-硬件开销>E. 硬件开销</h3><p>**存储开销。**Gaze将区域大小设置为4KB（与典型的物理页面相同）。表I展示了每个组件的详细划分以及总存储开销。FT和AT都有64个条目，允许同时跟踪64个页面。PB使用32个条目存储最多32个页面的预取模式，每个偏移量有四个状态：不预取、预取到L1D、L2C和LLC（未使用）。PHT采用4路组相联方式。DPCT包含8个条目。我们忽略了DC的开销，因为它只占用3个比特。最后，Gaze的总硬件开销为4.46KB（比Bingo [13]低31倍，比PMP [48]少0.54KB，比Berti [65]多1.91KB）。</p><p>**面积和能量开销。**我们使用CACTI [60]、[86]的22nm配置来估算Gaze（PHT和DPCT）和PMP（OPT和PPT）的模式历史模块所消耗的面积和访问能量。与PMP相比，Gaze消耗的面积约为29%（0.0034 mm² vs. 0.0117 mm²）。这是因为Gaze中的每一行仅需要64b来存储一个比特向量，而PMP则需要320b（或160b）来存储一个计数器向量（粗计数器向量）。此外，Gaze的模式历史模块的读写访问消耗的能量不到PMP的46%。Gaze的每个表可以在一个CPU周期内被访问。与Berti相比，Gaze的面积和能量消耗要低得多，因为Berti将每个L1D行扩展12个比特来容纳获取延迟。这种扩展导致其面积和访问能量比Gaze的PHM增加超过10倍。</p><p><figure class=gallery-image style=flex-grow:119;flex-basis:286px><a href=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233209992.png data-size=775x649><img src=/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233209992.png width=775 height=649 srcset="/2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233209992_hu2893704833838414597.png 480w, /2025/gaze_into_the_pattern__for_hardware_prefetching/image-20250202233209992_hu931932273048753573.png 1024w" loading=lazy></a></figure></p><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><h3 id=版权信息>版权信息</h3><p>本文原载于 <a class=link href=https://vastcircle.github.io target=_blank rel=noopener>vastcircle.github.io</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2025/a_top-down_method_for_performance_analysis_and_couters_architecturee/><div class=article-details><h2 class=article-title>A_Top Down_Method_for_performance_analysis_and_couters_architecturee</h2></div></a></article><article><a href=/2025/a_scalable_multi_path_microarchitecture_for_efficient_gpu_control_flow/><div class=article-details><h2 class=article-title>A_scalable_multi_path_microarchitecture_for_efficient_GPU_Control_Flow</h2></div></a></article><article><a href=/2025/memory_dependence_prediction_using_store_sets/><div class=article-details><h2 class=article-title>Memory_dependence_prediction_using_store_sets</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了394.9k字·共 104篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#摘要>摘要</a></li><li><a href=#introduction>introduction</a></li><li><a href=#ii-相关工作与研究动机><strong>II. 相关工作与研究动机</strong></a><ol><li><a href=#a-近期基于空间模式的机制><strong>A. 近期基于空间模式的机制</strong></a></li><li><a href=#b-现有局限性与研究动机><strong>B. 现有局限性与研究动机</strong></a></li></ol></li><li><a href=#iii-gaze空间预取器>III. Gaze空间预取器</a><ol><li><a href=#a-设计概述>A. 设计概述</a></li><li><a href=#b-模式表征>B. 模式表征</a></li><li><a href=#c-向空间流式处理的增强>C. 向空间流式处理的增强</a></li><li><a href=#d-模式历史模块>D. 模式历史模块</a></li><li><a href=#e-硬件开销>E. 硬件开销</a></li></ol></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li><li><a href=#版权信息>版权信息</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/prefetch/ class=category-list-link>prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/ class=category-list-link>基础概念<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class=category-list-link>操作系统<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83/ class=category-list-link>环境<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>17</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>56</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_4>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>