<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='关于 OS 的目标：
管理底层硬件 应用程序的并行 应用程序的隔离 应用程序的数据共享 多用户之间的访问控制（Access Control System）/安全性（Security）/权限系统Permission System 帮助应用程序获得高性能（Performance）。 能够支持大量不同的用户场景：文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算 OS 的结构 在这个架构的最上层，运行各种各样的应用程序，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）
'><title>Mit操作系统</title>
<link rel=canonical href=https://VastCircle.github.io/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='Mit操作系统'><meta property='og:description' content='关于 OS 的目标：
管理底层硬件 应用程序的并行 应用程序的隔离 应用程序的数据共享 多用户之间的访问控制（Access Control System）/安全性（Security）/权限系统Permission System 帮助应用程序获得高性能（Performance）。 能够支持大量不同的用户场景：文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算 OS 的结构 在这个架构的最上层，运行各种各样的应用程序，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）
'><meta property='og:url' content='https://VastCircle.github.io/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-04-14T14:00:28+08:00'><meta property='article:modified_time' content='2025-04-14T14:00:28+08:00'><meta name=twitter:title content="Mit操作系统"><meta name=twitter:description content="关于 OS 的目标：
管理底层硬件 应用程序的并行 应用程序的隔离 应用程序的数据共享 多用户之间的访问控制（Access Control System）/安全性（Security）/权限系统Permission System 帮助应用程序获得高性能（Performance）。 能够支持大量不同的用户场景：文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算 OS 的结构 在这个架构的最上层，运行各种各样的应用程序，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></header><h2 class=article-title><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>Mit操作系统</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 14, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>10457字</time></div></footer></div></header><section class=article-content><p>关于 <strong>OS 的目标</strong>：</p><ol><li>管理底层硬件</li><li>应用程序的并行</li><li>应用程序的隔离</li><li>应用程序的数据共享</li><li>多用户之间的访问控制（Access Control System）/安全性（Security）/权限系统Permission System</li><li>帮助应用程序获得高性能（Performance）。</li><li>能够支持大量不同的用户场景：文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算</li></ol><h3 id=os-的结构>OS 的结构</h3><p>在这个架构的最上层，运行各种各样的应用程序，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）</p><p>计算机有一些硬件资源，包括了CPU，内存，磁盘，网卡。所以硬件资源在最低一层。</p><p>区别于用户空间程序，有一个特殊的程序总是会在运行，它称为Kernel。Kernel是计算机资源的守护者。</p><p>当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel中的最重要的两个<strong>服务</strong>，其中一个服务是<strong>文件系统</strong>，另一个就是<strong>进程管理系统</strong>。（在真实的 os 中，kernel 还有很多其他服务：比如 <strong>进程间通信</strong>服务，比如<strong>TCP/IP协议栈</strong>，比如<strong>支持声卡</strong>的软件，比如支持数百种不同磁盘，不同网卡的<strong>驱动</strong>）</p><p>在进程管理系统中，Kernel会管理内存的分配。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。</p><p>应用程序是如何<strong>与Kernel交互</strong>：</p><p>这里是通过所谓的<strong>系统调用</strong>（System Call）来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。</p><h3 id=13-os难的原因>1.3 OS难的原因</h3><ol><li>内核的编程环境比较困难，你实际上在<strong>提供一个基础设施</strong>让别人来运行他们的程序。在这门课程中，我们会使用一个叫做<strong>QEMU的硬件模拟器，来模拟CPU和计算机</strong>。这会简单一些，但即使这样，编程环境还是比较恶劣。</li><li>设计 OS 时一些矛盾：<ul><li><strong>高效和易用的矛盾</strong>。高效通常意味着操作系统需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的<strong>high-level可移植接口</strong>。所以，提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。</li><li><strong>简单和强大的矛盾</strong>。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。想要提供一个非常强大的操作系统服务，这样操作系统才能<strong>分担运行应用程序的负担</strong>，所以我们需要强大的操作系统服务。</li><li><strong>灵活和安全的矛盾</strong>。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。</li></ul></li></ol><p><figure class=gallery-image style=flex-grow:373;flex-basis:895px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f0-1.png data-size=922x247><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f0-1.png width=922 height=247 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f0-1_hu2842828033553791817.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f0-1_hu17178178957280554480.png 1024w" loading=lazy alt=figure0-1></a><figcaption>figure0-1</figcaption></figure></p><p>如图0-1所示，xv6 使用了传统的<strong>内核</strong>概念 - 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为<strong>进程</strong>）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。
进程通过<strong>系统调用</strong>使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p><p>内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。</p><p>内核提供的一系列系统调用就是用户程序可见的操作系统接口，xv6 内核提供了 Unix 传统系统调用的一部分，它们是：</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>系统调用</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left>fork()</td><td style=text-align:left>创建进程</td></tr><tr><td style=text-align:left>exit()</td><td style=text-align:left>结束当前进程</td></tr><tr><td style=text-align:left>wait()</td><td style=text-align:left>等待子进程结束</td></tr><tr><td style=text-align:left>kill(pid)</td><td style=text-align:left>结束 pid 所指进程</td></tr><tr><td style=text-align:left>getpid()</td><td style=text-align:left>获得当前进程 pid</td></tr><tr><td style=text-align:left>sleep(n)</td><td style=text-align:left>睡眠 n 秒</td></tr><tr><td style=text-align:left>exec(filename, *argv)</td><td style=text-align:left>加载并执行一个文件</td></tr><tr><td style=text-align:left>sbrk(n)</td><td style=text-align:left>为进程内存空间增加 n 字节</td></tr><tr><td style=text-align:left>open(filename, flags)</td><td style=text-align:left>打开文件，flags 指定读/写模式</td></tr><tr><td style=text-align:left>read(fd, buf, n)</td><td style=text-align:left>从文件中读 n 个字节到 buf</td></tr><tr><td style=text-align:left>write(fd, buf, n)</td><td style=text-align:left>从 buf 中写 n 个字节到文件</td></tr><tr><td style=text-align:left>close(fd)</td><td style=text-align:left>关闭打开的 fd</td></tr><tr><td style=text-align:left>dup(fd)</td><td style=text-align:left>复制 fd</td></tr><tr><td style=text-align:left>pipe( p)</td><td style=text-align:left>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td style=text-align:left>chdir(dirname)</td><td style=text-align:left>改变当前目录</td></tr><tr><td style=text-align:left>mkdir(dirname)</td><td style=text-align:left>创建新的目录</td></tr><tr><td style=text-align:left>mknod(name, major, minor)</td><td style=text-align:left>创建设备文件</td></tr><tr><td style=text-align:left>fstat(fd)</td><td style=text-align:left>返回文件信息</td></tr><tr><td style=text-align:left>link(f1, f2)</td><td style=text-align:left>给 f1 创建一个新名字(f2)</td></tr><tr><td style=text-align:left>unlink(filename)</td><td style=text-align:left>删除文件</td></tr></tbody></table></div><h3 id=进程和内存>进程和内存</h3><p>一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内核可见的进程状态。xv6 提供了分时特性：它在可用 CPU 之间不断切换，决定哪一个等待中的进程被执行。当一个进程不在执行时，xv6 保存它的 CPU 寄存器，当他们再次被执行时恢复这些寄存器的值。内核将每个进程和一个 <strong>pid</strong> (process identifier) 关联起来。</p><p>一个进程可以通过系统调用 <code>fork</code> 来创建一个新的进程。<code>fork</code> 创建的新进程被称为<strong>子进程</strong>，子进程的内存内容同创建它的进程（父进程）一样。<code>fork</code> 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。</p><p>系统调用 <code>exec</code> 将从某个<em>文件</em>（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。这份文件必须符合特定的格式，规定文件的哪一部分是指令，哪一部分是数据，哪里是指令的开始等等。xv6 使用 ELF 文件格式，第2章将详细介绍它。当<code>exec</code>执行成功后，它并不返回到原来的调用进程，而是从ELF头中声明的入口开始，执行从文件中加载的指令。<code>exec</code> 接受两个参数：可执行文件名和一个字符串参数数组。</p><h3 id=第一个进程>第一个进程</h3><h4 id=进程概览>进程概览</h4><p>进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。</p><p>xv6 使用页表（由硬件实现）来为每个进程提供其独有的地址空间。页表将<em>虚拟地址</em>（x86 指令所使用的地址）翻译（或说“映射”）为<em>物理地址</em>（处理器芯片向主存发送的地址）。</p><p><figure class=gallery-image style=flex-grow:179;flex-basis:431px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-1.png data-size=844x469><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-1.png width=844 height=469 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-1_hu17080778730521287958.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-1_hu7829738728039753347.png 1024w" loading=lazy alt=figure1-1></a><figcaption>figure1-1</figcaption></figure></p><p>xv6 为每个进程维护了不同的页表，这样就能够合理地定义进程的地址空间了。如图表1-1所示，一片地址空间包含了从虚拟地址0开始的<em>用户内存</em>。它的地址最低处放置进程的指令，接下来则是全局变量，栈区，以及一个用户可按需拓展的“堆”区（malloc 用）</p><p>和上面提到的<em>用户内存</em>一样，内核的指令和数据也会被进程映射到每个进程的地址空间中。当进程使用系统调用时，系统调用实际上会在进程地址空间中的内核区域执行。这种设计使得内核的系统调用代码可以直接指向用户内存。为了给用户留下足够的内存空间，xv6 将内核映射到了地址空间的高地址处，即从 0x80100000 开始。</p><p>xv6 使用结构体 <code>struct proc</code> 来维护一个进程的状态，其中最为重要的状态是进程的页表，内核栈，当前运行状态。</p><p>每个进程都有一个运行线程（或简称为<em>线程</em>）来执行进程的指令。线程可以被暂时挂起，稍后再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的大多数状态（局部变量和函数调用的返回地址）都保存在线程的栈上。</p><p>每个进程都有用户栈和内核栈（<code>p->kstack</code>）。当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程（通过系统调用或中断）进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。</p><p>当进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码。当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级，转入用户栈，恢复执行系统调用指令后面的那条用户指令。线程可以在内核中“阻塞”，等待 I/O, 在 I/O 结束后再恢复运行。</p><p><code>p->state</code> 指示了进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中。</p><p><code>p->pgdir</code> 以 x86 硬件要求的格式保存了进程的页表。xv6 让分页硬件在进程运行时使用 <code>p->pgdir</code>。进程的页表还记录了保存进程内存的物理页的地址。</p><h4 id=代码第一个地址空间>代码：第一个地址空间</h4><p><figure class=gallery-image style=flex-grow:170;flex-basis:410px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-2.png data-size=858x502><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-2.png width=858 height=502 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-2_hu2091394219348629988.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f1-2_hu4129194502675129496.png 1024w" loading=lazy alt=figure1-2></a><figcaption>figure1-2</figcaption></figure></p><p>当 PC 开机时，它会初始化自己然后从磁盘中载入 <em>boot loader</em> 到内存并运行。附录 B 介绍了其具体细节。然后，<em>boot loader</em> 把 xv6 内核从磁盘中载入并从 <code>entry</code>（1040）开始运行。x86 的分页硬件在此时还没有开始工作；所以这时的虚拟地址是直接映射到物理地址上的。</p><p>boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。</p><p>为了让内核的剩余部分能够运行，<code>entry</code> 的代码设置了页表，将 0x80000000（称为 <code>KERNBASE</code>（0207））开始的虚拟地址映射到物理地址 0x0 处。注意，页表经常会这样把两段不同的虚拟内存映射到相同的一段物理内存，我们将会看到更多类似的例子</p><pre tabindex=0><code class=language-assembly data-lang=assembly>_entry:
        # set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0
        li a0, 1024*4
        csrr a1, mhartid
        addi a1, a1, 1
        mul a0, a0, a1
        add sp, sp, a0
        # jump to start() in start.c
        call start
</code></pre><h4 id=代码创建第一个进程>代码：创建第一个进程</h4><p>在 <code>main</code> 初始化了一些设备和子系统后，它通过调用 <code>userinit</code>（1239）建立了第一个进程。<code>userinit</code> 首先调用 <code>allocproc</code>。<code>allocproc</code>（2205）的工作是在页表中分配一个槽（即结构体 <code>struct proc</code>），并初始化进程的状态，为其内核线程的运行做准备。注意一点：<code>userinit</code> 仅仅在创建第一个进程时被调用，而 <code>allocproc</code> 创建每个进程时都会被调用。**<code>allocproc</code> 会在 <code>proc</code> 的表中找到一个标记为 <code>UNUSED</code>(2211-2213)的槽位。当它找到这样一个未被使用的槽位后，<code>allocproc</code> 将其状态设置为 <code>EMBRYO</code>，使其被标记为被使用的并给这个进程一个独有的 <code>pid</code>（2201-2219）。**接下来，它尝试为进程的内核线程分配内核栈。如果分配失败了，<code>allocproc</code> 会把这个槽位的状态恢复为 <code>UNUSED</code> 并返回0以标记失败。</p><h4 id=第一个系统调用exec>第一个系统调用：exec</h4><p>可以看到，在一开始就把SYS_exec 放在a7 , 然后ecall ,</p><pre tabindex=0><code class=language-assembly data-lang=assembly>.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec
        ecall
</code></pre><p>大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是真正的操作系统会利用一个显式的链表在常数时间内找到空闲的 <code>proc</code>，而不像 <code>allocproc</code> 中那样花费线性时间；xv6 使用的是朴素的线性搜索（找第一个空闲的 <code>proc</code>）</p><p>观点</p><ol><li><p><strong>进程抽象了物理上的 CPU （的核）</strong>，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，操作系统内核会完成不同进程在CPU上的切换。<strong>OS 就是进程池</strong>（管理进程状态，创建和销毁进程）</p></li><li><p><strong>exec 抽象了物理上的内存</strong>。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的<strong>内存镜像</strong>。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限</p></li><li><p><strong>files 来说抽象了物理上的磁盘</strong>。应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。</p></li><li><p>为了实现 OS 和用户程序的隔离，需要 <strong>user / kernel mode</strong>，kernel mode在RISC-V中被称为<strong>Supervisor</strong> mode但是其实是同一个东西；这需要 <strong>CPU 的一个 mode bit</strong> 支持</p></li><li><p>为了实现用户程序之间的隔离，需要<strong>虚拟内存</strong>（Virtual Memory）。这需要 CPU 的 <strong>MMU 硬件</strong>支持</p></li></ol><p>一个<strong>处理器</strong>如果需要运行能够<strong>支持多个应用程序</strong>的<strong>操作系统</strong>，<strong>需要同时支持 user/kernle mode 和虚拟内存实现强隔离性</strong>。</p><ol><li>当运行在 kernel mode 时，CPU 可以运行<strong>特定权限</strong>的指令（privileged instructions）；操作系统内核在 kernel mode 下运行</li><li>当运行在 user mode 时，CPU 只能运行<strong>普通权限</strong>的指令（unprivileged instructions）；用户应用程序在 user mode 下运行</li></ol><p><strong>ECALL接收一个数字参数</strong>，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System C、</p><p>在xv6 中，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork</p><h2 id=xv6启动流程>xv6启动流程</h2><pre tabindex=0><code> 1.  主板上电，启动位于 ROM 上的 BIOS
 2.  BIOS 完成硬件自检程序POST(Power-On Self Test)
 3.  BIOS 读取MBR(主引导记录), 并执行其中的 **boot loader** 代码。BIOS将**启动控制权移交给boot loader**。
 4.  boot loader **把 xv6 kernel 加载到内存中**的 0x8000000 处（0x80000000 此时是物理地址，因为RISC-V是在禁用分页硬件的情况下开始的）（**BIOS完成硬件初始化后，boot loader完成软件加载**）
 5.  OS 启动，计算机可用
</code></pre><p>首先在<strong>机器模式</strong>下执行了以下4件事（如下图）：</p><ol><li>加载内核代码到 ox80000000处，CPU 会从这个约定好的地址处取指令</li><li>为每个 CPU 核分配栈空间，以便后续执行 C 代码</li><li>执行一些只能在机器模式下进行的配置（比如一个关键配置是把“上一个状态”设置为内核态，返回地址设置为内核态的 main()函数，这里上一个之所以加引号是因为这是 OS 首次启动，当然没有所谓的“上一个状态”，这是是为了 mret 指令做铺垫）</li><li>使用 mret 指令切换到<strong>内核模式</strong>，执行内核代码</li></ol><p><figure class=gallery-image style=flex-grow:168;flex-basis:405px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100305-1762941689.png data-size=2484x1470><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100305-1762941689.png width=2484 height=1470 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100305-1762941689_hu17109682599394789225.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100305-1762941689_hu16907681099941089391.png 1024w" loading=lazy></a></figure></p><p>跳转到内核模式后，做了以下 2 件事：</p><ol><li>初始化内存和文件系统（如内存分页、设置内核页表等）</li><li>创建OS 的第一个进程，在进程中执行 initcode 代码（这是一段写好的固定代码，嵌入到了内核程序中）</li></ol><p><figure class=gallery-image style=flex-grow:278;flex-basis:667px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100280-20951949.png data-size=2950x1060><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100280-20951949.png width=2950 height=1060 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100280-20951949_hu5749852311790031476.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230810171100280-20951949_hu1120281274587606641.png 1024w" loading=lazy></a></figure></p><p>kernel/main.c main()</p><p>main()在 kernel mode 中初始化多个设备和子系统， 调用userinit()创建第一个进程 ， 然后等待schedule 运行</p><p>kvminithart() , trapinithart(), plicinithart() 是其他核心都要做初始化的 ，</p><p><figure class=gallery-image style=flex-grow:88;flex-basis:212px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005106864.png data-size=767x868><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005106864.png width=767 height=868 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005106864_hu2402105870884373212.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005106864_hu16507090726818953294.png 1024w" loading=lazy></a></figure></p><p>kernel/proc.c userinit()</p><p><figure class=gallery-image style=flex-grow:128;flex-basis:307px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005314304.png data-size=769x600><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005314304.png width=769 height=600 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005314304_hu16162943402380203200.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415005314304_hu14281729924204139541.png 1024w" loading=lazy></a></figure></p><p>执行 initcode 后会跳转到<strong>用户态</strong>，用户态执行用户程序：exec("/init", argc)，exec 上一节已经讲过：exec系统调用，这个系统调用会<strong>从指定的文件</strong>(第一个参数)中读取并加载指令，并替代当前调用进程的指令。</p><h2 id=页表>页表</h2><p>最常见的方法，同时也是非常灵活的一种方法就是使用<strong>页表</strong>（Page Tables）。<strong>页表就是一个数组</strong>，他的元素就是一个个<strong>页表条目（PTE）</strong>，使用 页表可以实现<strong>虚拟内存地址</strong>到<strong>物理内存地址</strong>的翻译，页表<strong>存储在内存中，由 OS 负责维护，内存管理单元（Memory Management Unit） 有查询页表的权限，MMU由一般被集成在 CPU 中。</strong></p><ol><li></li><li>页表存在哪里？<strong>页表是保存在内存中的</strong>，MMU只是会去查看 page table，MMU并不会保存 page table</li><li>在 RISC-V 上 <strong>SATP 的寄存器</strong>会存储页表的地址（这里简单思考一下，存的是物理地址还是虚拟地址？肯定是物理啊！不然成了地址翻译套娃了，永远得不到物理地址）</li><li>page table 中 PTE 的<strong>粒度是：page</strong>，所以这里要清楚，<strong>内存中每个字节都有自己的地址</strong>没错，但不是每个字节都有对应的PTE，是<strong>每一页才有对应的PTE</strong>（RISC-V中，一个page是4KB，4096Bytes）</li><li><strong>页表翻译的过程</strong>，以下图为例说明，一个虚拟地址有 64bit，而 xv6 运行在 <strong>Sv39 模式</strong>下，即 64bit 的虚拟地址只用到了低 39bit，高 25bit 没有使用。<code>2^39 bytes = 512 GB</code>，所以 RISCV 虚拟地址空间有 512GB。<ol><li>将 39 bit 虚拟地址分为 2 部分，前 27 bit 称为 index，后 12bit 称为 offset</li><li>index 部分就是页表的索引，取出页表中第 index 条PTE，PTE 有 54bit ，前 44bit 称为 PPN（Physical Page Number 物理页号），后 10bit 称为 Flags，目前我们只关注前 44bit</li><li><strong>将 PPN 和 offset 拼接到一起</strong>，就是翻译出来的物理地址</li></ol></li></ol><p>为什么使用 39bit，是因为 RISC-V 的设计者认为这个数字在可预测的将来可以容纳足够多的 I/O设备 和 DRAM芯片；如果需要更多的虚拟地址，RISC-V设计者已经定义了具有48位虚拟地址的Sv48模式</p><blockquote><p>sv39 , 27 + 12</p></blockquote><p>页表的巨大开销</p><ul><li>一条 PTE 占 8bytes：一条 PTE 有54bit，由于可以扩展到 64bit，所以我们以一条 PTE 64bit = 8bytes 计算</li><li>PTE 有 54bit ，前 44bit 称为 PPN（Physical Page Number 物理页号），后 10bit 称为 Flags，目前我们只关注前 44bit</li><li>一个虚拟空间就是一页，每一页都会有一个PTE</li></ul><p><figure class=gallery-image style=flex-grow:1182;flex-basis:2838px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415011044441.png data-size=1242x105><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415011044441.png width=1242 height=105 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415011044441_hu512967515597316184.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250415011044441_hu6753296686479645320.png 1024w" loading=lazy></a></figure></p><p>多级页表</p><ol><li>虚拟地址依旧是 27bit index + 12bit offset，但是 <strong>27bit 的 index 被分成了 3 部分，每部分 9bit</strong>，9bit 意味着可以表示2^9 = 512 条PTE，以一级页表为例，<strong>每条 PTE 对应 一张二级页表</strong>，所以 512 条 PTE 对应 512 张二级页表</li><li>从 satp 寄存器中找到<strong>一级页表</strong>的物理地址，然后利用L2 的 9bit 在一级页表中定位一条 PTE，其中的 PPN + 12个 0 就是某张二级页表的物理地址，然后利用 L2 的 9bit在这张二级页表中定位一条 PTE</li><li>利用二级页表中某条 PTE 中的 PPN，+ 12个 0的得到三级页表的物理地址，然后利用 L0 的 9bit 在三级页表中定位一条 PTE，这条 PTE + offset 就是最终的物理地址(这个12应该是 2^9 * 2^ 3 = 512 页表 * 8bytes)</li></ol><p><figure class=gallery-image style=flex-grow:133;flex-basis:320px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633996-1022275490.png data-size=1910x1432><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633996-1022275490.png width=1910 height=1432 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633996-1022275490_hu6823815449885518590.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633996-1022275490_hu10760887719961668081.png 1024w" loading=lazy></a></figure></p><p><strong>无论是单级页表还是多级页表，他们都需要、也都做到了内存（虚拟）地址的全覆盖</strong>，但是多级页表更加灵活，如果某个一级页表的PTE没有被用到，那么<strong>二级页表和三级页表就不会存在</strong>，这是一种巨大的节约！而单级页表只能老老实实对所有虚拟地址进行映射，因为如果不这样的话，单级页表就不是“全覆盖”，地址翻译就无法进行了</p><p>辅助位</p><ul><li>V-bit ：Valid，有效位，如果Valid bit位为1，那么表明这是一条<strong>合法的PTE</strong>，可以用来做地址翻译，否则，不能使用这条PTE，因为<strong>这条PTE并不包含有用的信息</strong>。（用 CSAPP 中的概念解释的话，<strong>有效 = 该页处于“已缓存”状态</strong>，具体见下面的引用）</li><li>R-bit ：Readable，该页是否允许被读</li><li>W-bit ：Writable，该页是否允许被写</li><li>X-bit ：Executable，CPU是否可以将页面的内容解释为指令并执行</li><li>U-bit：User， 是否（只）允许在 user mode 下使用该条 PTE</li></ul><p>在常见的地址映射方案中，当 CPU 访问物理地址空间时，若得到的物理地址<strong>小于</strong> 0x80000000，则可以认为该访问是针对各类 <strong>I/O 设备（外设）<strong>的操作；而若得到的物理地址</strong>大于</strong>等于 0x80000000，则可以认为该访问是针对 <strong>DRAM</strong> 的操作。下面的讲解也遵循这个惯例</p><p><figure class=gallery-image style=flex-grow:115;flex-basis:278px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633866-796170140.png data-size=1101x950><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633866-796170140.png width=1101 height=950 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633866-796170140_hu4584327199967869790.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214633866-796170140_hu8009148280355461439.png 1024w" loading=lazy></a></figure></p><ul><li>最下面（地址为0）是未被使用的地址；</li><li>地址 0x1000 是 <strong>boot ROM</strong> 的物理地址，当主板上电后，<strong>做的第一件事情就是运行存储在 boot ROM 中的代码</strong>。这里的代码会启动 boot loader ，<strong>把 xv6 kernel 加载到内存中</strong>的 0x8000000 处。当 boot 完成之后，会跳转到地址0x80000000，开始执行 OS 的代码</li><li>PLIC是中断控制器（Platform-Level Interrupt Controller）</li><li>CLINT（Core Local Interruptor）也是中断的一部分。地址0x02000000对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。<strong>（看样子是在读写物理内存，但由于地址小于 0x80000000，实际上是以这种形式操作外设）</strong></li><li>UART0（Universal Asynchronous Receiver/Transmitter）负责与Console和显示器交互。</li><li>VIRTIO disk，与磁盘进行交互。</li></ul><h3 id=xv6-中支持虚拟内存的代码>XV6 中支持虚拟内存的代码</h3><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#7f848e>// Initialize the one kernel_pagetable
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e5c07b>void</span> <span style=color:#61afef;font-weight:700>kvminit</span>(<span style=color:#e5c07b>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#e06c75>kernel_pagetable</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>kvmmake</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#7f848e>//-------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// Make a direct-map page table for the kernel.
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>pagetable_t</span> <span style=color:#61afef;font-weight:700>kvmmake</span>(<span style=color:#e5c07b>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#e06c75>pagetable_t</span> <span style=color:#e06c75>kpgtbl</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#e06c75>kpgtbl</span> <span style=color:#56b6c2>=</span> (<span style=color:#e06c75>pagetable_t</span>) <span style=color:#e06c75>kalloc</span>();
</span></span><span style=display:flex><span>  <span style=color:#e06c75>memset</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#d19a66>0</span>, <span style=color:#e06c75>PGSIZE</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// uart registers
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#e06c75>UART0</span>, <span style=color:#e06c75>UART0</span>, <span style=color:#e06c75>PGSIZE</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_W</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// virtio mmio disk interface
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#e06c75>VIRTIO0</span>, <span style=color:#e06c75>VIRTIO0</span>, <span style=color:#e06c75>PGSIZE</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_W</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// PLIC
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#e06c75>PLIC</span>, <span style=color:#e06c75>PLIC</span>, <span style=color:#d19a66>0x400000</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_W</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// map kernel text executable and read-only.
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#e06c75>KERNBASE</span>, <span style=color:#e06c75>KERNBASE</span>, (<span style=color:#e06c75>uint64</span>)<span style=color:#e06c75>etext</span><span style=color:#56b6c2>-</span><span style=color:#e06c75>KERNBASE</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_X</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, (<span style=color:#e06c75>uint64</span>)<span style=color:#e06c75>etext</span>, (<span style=color:#e06c75>uint64</span>)<span style=color:#e06c75>etext</span>, <span style=color:#e06c75>PHYSTOP</span><span style=color:#56b6c2>-</span>(<span style=color:#e06c75>uint64</span>)<span style=color:#e06c75>etext</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_W</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// map the trampoline for trap entry/exit to
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#7f848e>// the highest virtual address in the kernel.
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>kvmmap</span>(<span style=color:#e06c75>kpgtbl</span>, <span style=color:#e06c75>TRAMPOLINE</span>, (<span style=color:#e06c75>uint64</span>)<span style=color:#e06c75>trampoline</span>, <span style=color:#e06c75>PGSIZE</span>, <span style=color:#e06c75>PTE_R</span> <span style=color:#56b6c2>|</span> <span style=color:#e06c75>PTE_X</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// allocate and map a kernel stack for each process.
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>  <span style=color:#e06c75>proc_mapstacks</span>(<span style=color:#e06c75>kpgtbl</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#c678dd>return</span> <span style=color:#e06c75>kpgtbl</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><figure class=gallery-image style=flex-grow:162;flex-basis:389px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214634394-693472761.png data-size=2838x1750><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214634394-693472761.png width=2838 height=1750 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214634394-693472761_hu4939570186964459255.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230814214634394-693472761_hu6639547643378623853.png 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><h2 id=trap-机制>Trap 机制</h2><p>所谓 trap，就是一个进程从用户空间到内核空间的<strong>切换</strong>，这里要强调一句，<strong>trap 不是一个瞬间完成的，而是一个过程</strong>，这个过程主要包括以下内容：</p><ul><li>保存用户寄存器中的内容</li><li>将 user page table 切换为 kernel page table</li><li>切换堆栈空间</li><li>&mldr;</li></ul><p>trap 的大致步骤如下：</p><ol><li>进程运行在用户空间，发生了系统调用，于是准备 trap 到内核空间</li><li>首先，保存 32 个用户寄存器的值，以便内核代码运行结束后恢复用户空间的上下文</li><li>然后，将 program counter （<strong>以下简称 pc</strong>）的值保存下来，以便内核代码运行结束后从中断的位置继续执行用户程序，这个值将会保存在 SEPC 寄存器中</li><li>然后，将 mode 标志位由 user mode 改为 kernel mode</li><li>然后，切换页表，将 user page table 切换为 kernlel page table，这里主要是修改 SATP 寄存器的值，这个寄存器保存了页表指针</li><li>然后，为内核代码设置堆栈空间，主要是修改堆栈寄存器的值，因为这里保存了堆栈的指针</li><li>完成 trap，开始运行内核的 C 代码</li></ol><h3 id=1-ecall-指令干了三件事>1. ecall 指令干了三件事</h3><p>ecall 指令是 RISC-V 中的指令，所以这三件事都是由 RISC-V 的 harware 完成的，无需 OS 介入</p><ol><li>将 mode flag 由 user mode 改为 kernel mode</li><li>将 pc 寄存器的值保存到 SEPC 寄存器中</li><li>将 STVEC 寄存器中的值加载到 pc 寄存器中</li></ol><p>0x3ffffff000 是 RISC-V 的 sv39 模式下的<strong>最高页的首地址</strong>（<code>1&lt;&lt;39 - PAGESIZE</code>）</p><p>确实是（实际上是 1&#171;38 - PAGESIZE ， 说是-1避免符号扩展问题）</p><pre tabindex=0><code>#define TRAMPOLINE (MAXVA - PGSIZE)
</code></pre><h3 id=2执行tampoline-page-的代码-uservec>2.执行Tampoline page 的代码 uservec</h3><ol><li><p><code>csrw sscratch, a0</code> ，这个指令交换了 a0 和 sscratch 两个寄存器的内容，交换之后，a0 的值是0x3fffffe000，这是 trapframe page 的虚拟地址。它之前保存在SSCRATCH寄存器中；SSCRATCH寄存器的内容是 2，这是 a0 寄存器之前的值。a0 寄存器保存的是系统调用的第一个参数；所以通过这次交换，即保存了 a0 寄存器的旧值，又有了指向 trapframe page 的指针。</p></li><li><p>将 32 个用户寄存器的值<strong>保存到 trapframe page</strong> 中（应该是 31 个 ，zero 寄存器的值不用保存，但这里为了方便记忆），XV6 在每个 user page table 中都映射了 trapframe page（就在 trampoline page 的下面），这样<strong>每个进程都有自己的 trapframe page</strong>。（特别注意，这两个 page 对应的PTE并没有设置PTE_u标志位，所以用户程序不可以写这两个 page，trap 依旧是安全的）</p></li><li><p>从 trapframe page 中将以下数据读取出来：</p><ul><li>将 kernel 的栈顶指针加载到寄存器 sp 寄存器中中</li><li>将 kernel 的 hartid （CPU 核编号）加载到 tp 寄存器中</li><li>将 usertrap() 函数的地址加载到 t0 寄存器中（打印出来是<code>0x800027a0</code>，属于虚拟地址空间中的 kernel text 区域）</li><li>将 kernel 的 page table 的指针加载到 t1 寄存器中</li></ul></li><li><p>切换 page table，将 kernel page table 的指针加载到 satp 寄存器中</p></li></ol><p>trampoline page在用户空间和内核空间的虚拟地址一样，物理地址也一样 ， 所以可以做到无缝切换 ， 不会导致程序的崩溃。</p><p>总结一下，Trampoline page 中的代码主要完成了以下三件事：</p><ol><li>保存用户寄存器数据</li><li>为内核代码设置好堆栈空间</li><li>切换页表</li></ol><p>a0 指向的正好是TRAPFRAME ,所以是把这里的一些数据写入到寄存器了</p><p>对应的就是p->trapframe 的一系列值</p><pre tabindex=0><code>struct trapframe {
  /*   0 */ uint64 kernel_satp;   // kernel page table
  /*   8 */ uint64 kernel_sp;     // top of process&#39;s kernel stack
  /*  16 */ uint64 kernel_trap;   // usertrap()
  /*  24 */ uint64 epc;           // saved user program counter
  /*  32 */ uint64 kernel_hartid; // saved kernel tp
  /*  40 */ uint64 ra;
  /*  48 */ uint64 sp;
  /*  56 */ uint64 gp;
  /*  64 */ uint64 tp;
  /*  72 */ uint64 t0;
  /*  80 */ uint64 t1;
  /*  88 */ uint64 t2;
  /*  96 */ uint64 s0;
  /* 104 */ uint64 s1;
  /* 112 */ uint64 a0;
  /* 120 */ uint64 a1;
  /* 128 */ uint64 a2;
  /* 136 */ uint64 a3;
  /* 144 */ uint64 a4;
  /* 152 */ uint64 a5;
  /* 160 */ uint64 a6;
  /* 168 */ uint64 a7;
  /* 176 */ uint64 s2;
  /* 184 */ uint64 s3;
  /* 192 */ uint64 s4;
  /* 200 */ uint64 s5;
  /* 208 */ uint64 s6;
  /* 216 */ uint64 s7;
  /* 224 */ uint64 s8;
  /* 232 */ uint64 s9;
  /* 240 */ uint64 s10;
  /* 248 */ uint64 s11;
  /* 256 */ uint64 t3;
  /* 264 */ uint64 t4;
  /* 272 */ uint64 t5;
  /* 280 */ uint64 t6;
};
</code></pre><p><figure class=gallery-image style=flex-grow:181;flex-basis:434px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145700927-1127803509.png data-size=1707x943><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145700927-1127803509.png width=1707 height=943 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145700927-1127803509_hu15008586112905747049.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145700927-1127803509_hu4568542398953263111.png 1024w" loading=lazy></a></figure></p><h3 id=3usertrap中的代码>3.usertrap()中的代码</h3><p>在trap.c</p><p>usertrap 函数属于内核代码了，内存中位于 kernel 虚拟地址空间的 kernel text 段，这里的代码细节很多，我就不一一讲解了，细节在图中都说明了，我只从宏观上讲，usertrap 负责判断<strong>触发 trap 的原因</strong>，并执行响应的处理：</p><ul><li>若是 syscall，则调用对应的系统调用</li><li>若是设备中断，则跳转到响应的处理代码</li><li>若是 page fault，则杀死进程</li><li>最后执行 usertrapret() 函数</li></ul><p><figure class=gallery-image style=flex-grow:164;flex-basis:394px><a href=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145701436-1097551617.png data-size=2848x1734><img src=/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145701436-1097551617.png width=2848 height=1734 srcset="/2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145701436-1097551617_hu7522443270862216104.png 480w, /2025/mit%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2174405-20230820145701436-1097551617_hu8573081162958935034.png 1024w" loading=lazy></a></figure></p><h3 id=4usertrapret中的代码>4.usertrapret()中的代码</h3><p>这个函数也是细节颇多，我都写在图中了，总结如下：</p><ul><li>恢复 STVEC 寄存器中的值，指向 trampoline page 中的 uservec，以便下次 trap 时，ecall 指令跳转到 trampoline page</li><li>填充 trapframe page 中的 <strong>4 虎将寄存器</strong>，以便下次 trap 时，trampoline page 中的 uservec 使用</li><li>恢复 SEPC 寄存器的值，指向 ecall 的下一条指令</li><li>跳转到 trampoline page 中的 userret 汇编代码，在那里切换回 user page table，因为trampoline page 在两个页表中的物理地址相同，所以在那里才可以安全切换页表，程序不会崩溃</li></ul><h3 id=5再次执行-tampoline-page-中的代码userret>5.再次执行 Tampoline page 中的代码：userret</h3><p>这里的代码和 uservec 一样，也位于 Tampoline page ，回忆 uservec 中的代码主要完成了以下三件事：</p><ol><li>保存用户寄存器数据</li><li>为内核代码设置好堆栈空间</li><li>切换页表，切换为 kernel page table</li></ol><p>对应的，userret 的代码主要完成 3 件事：</p><ol><li>切换页表，切换为 user page table</li><li>恢复用户寄存器中的值</li><li>调用 RISC-V 中的 sret 指令，跳转到用户空间，这样 SEPC 寄存器中的值（目前是 ecall 的下一条指令）就会加载到 pc 寄存器中，从而完成整个 trap 的返回</li></ol><h2 id=page-fault>page fault</h2><ul><li>出错的虚拟地址，当出现 page fault 的时候，是由于页表中找不到这个地址对应的 PTE 或者 PTE 无效，这里的出错的虚拟地址值得就是这条"找不到的地址"，XV6 内核会打印出错的虚拟地址，并且这个地址会被保存在 <strong>STVAL 寄存器</strong>中。</li><li>出错的原因，查看 RISC-V 文档可知有三种引起 page fault 的原因：<strong>load 引起的 page fault</strong>；<strong>store 引起的 page fault</strong>；<strong>指令执行引起的 page fault</strong>。这个信息存在 <strong>SCAUSE 寄存器</strong>中，总共有3个类型的原因与page fault 相关，分别是读、写和指令</li><li>触发 page fault 的指令的地址，即 page fault 在<strong>用户空间</strong>发生的位置。从<a class=link href=https://www.cnblogs.com/looking-for-zihuatanejo/p/17644000.html target=_blank rel=noopener>上节课</a>可以知道，作为trap处理代码的一部分，这个地址存放在 <strong>SEPC 寄存器</strong>中，并同时会保存在trapframe->epc 中。</li></ul><p>在出现page fault 可以直接杀死进程 ，但是 这样很粗暴， 可以借助page fault 做以下的事情</p><ul><li>lazy page allocation</li><li>copy-on-write fork（会作为 lab 出现）</li><li>demand paging</li><li>memory mapped files（会作为 lab 出现）</li></ul><p>page fault 是阶梯，触发 page fault 后，我们可以在 page fault handler 中做很多事情，其中最重要的就是**“懒加载”**，下面的 lazy allocation、Zero Fill On Demand、COW fork 、Demand paging 、Memory mapped 的核心思想都是“懒加载”。</p><p>lazy allocation 的概念。核心思想非常简单，摒弃 eager allocation，sbrk 被调用时不会立即分配内存，只是记录一下"假如真的分配了内存，那么现在应用程序可用的内存是多少"（在实际的 xv6 中，这个值是由 p->sz 记录的，他表示<strong>堆顶指针</strong>）</p><p>当应用程序真的用到了<strong>新申请的这部分内存</strong>，由于没有分配、页表中没有映射，自然找不到相应PTE，这时会触发page fault，但是 kernel 会识别到：要访问 va <strong>小于新的 p->sz</strong>，并且<strong>大于旧的 p->sz</strong>，就知道这是一个当初假装分配的地址，所以这时才会真正分配物理地址并且在用户程序的页表中添加 PTE，所以在 page fault handler 中就会：</p><ul><li>在page fault handler中，通过kalloc函数分配一个内存page；并初始化这个 page 内容为0；</li><li>将这个内存 page 映射到 user page table 中；</li><li>最后重新执行指令（SEPC 寄存器记录了发生 pf 时的地址，所以可以回到“事发地”重新执行指令）</li></ul><p>总之，lazy allocation 的核心概念就是“<strong>将分配物理内存 page 推迟到了真正访问这个内存 page 时做</strong>”。</p><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><p><a class=link href=https://www.cnblogs.com/looking-for-zihuatanejo/p/17564124.html target=_blank rel=noopener>https://www.cnblogs.com/looking-for-zihuatanejo/p/17564124.html</a></p><p><a class=link href=https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html target=_blank rel=noopener>xv6 中文文档</a></p></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了394.9k字·共 103篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#os-的结构>OS 的结构</a></li><li><a href=#13-os难的原因>1.3 OS难的原因</a></li><li><a href=#进程和内存>进程和内存</a></li><li><a href=#第一个进程>第一个进程</a><ol><li><a href=#进程概览>进程概览</a></li><li><a href=#代码第一个地址空间>代码：第一个地址空间</a></li><li><a href=#代码创建第一个进程>代码：创建第一个进程</a></li><li><a href=#第一个系统调用exec>第一个系统调用：exec</a></li></ol></li></ol></li><li><a href=#xv6启动流程>xv6启动流程</a></li><li><a href=#页表>页表</a><ol><li><a href=#xv6-中支持虚拟内存的代码>XV6 中支持虚拟内存的代码</a></li></ol></li><li><a href=#trap-机制>Trap 机制</a><ol><li><a href=#1-ecall-指令干了三件事>1. ecall 指令干了三件事</a></li><li><a href=#2执行tampoline-page-的代码-uservec>2.执行Tampoline page 的代码 uservec</a></li><li><a href=#3usertrap中的代码>3.usertrap()中的代码</a></li><li><a href=#4usertrapret中的代码>4.usertrapret()中的代码</a></li><li><a href=#5再次执行-tampoline-page-中的代码userret>5.再次执行 Tampoline page 中的代码：userret</a></li></ol></li><li><a href=#page-fault>page fault</a></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/prefetch/ class=category-list-link>prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/ class=category-list-link>基础概念<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class=category-list-link>操作系统<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83/ class=category-list-link>环境<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>17</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>55</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_4>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>