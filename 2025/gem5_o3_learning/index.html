<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='阅读gem5 o3 cpu 的相关代码
gem5 的启动流程 '><title>Gem5_o3_learning</title>
<link rel=canonical href=https://VastCircle.github.io/2025/gem5_o3_learning/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='Gem5_o3_learning'><meta property='og:description' content='阅读gem5 o3 cpu 的相关代码
gem5 的启动流程 '><meta property='og:url' content='https://VastCircle.github.io/2025/gem5_o3_learning/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content><meta property='article:published_time' content='2025-03-10T21:38:17+08:00'><meta property='article:modified_time' content='2025-03-10T21:38:17+08:00'><meta name=twitter:title content="Gem5_o3_learning"><meta name=twitter:description content="阅读gem5 o3 cpu 的相关代码
gem5 的启动流程 "><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/gem5/>Gem5</a></header><h2 class=article-title><a href=/2025/gem5_o3_learning/>Gem5_o3_learning</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 10, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>15223字</time></div></footer></div></header><section class=article-content><p>阅读gem5 o3 cpu 的相关代码</p><h2 id=gem5-的启动流程>gem5 的启动流程</h2><p><figure class=gallery-image style=flex-grow:117;flex-basis:280px><a href=/2025/gem5_o3_learning/image-20250311135207240.png data-size=1214x1037><img src=/2025/gem5_o3_learning/image-20250311135207240.png width=1214 height=1037 srcset="/2025/gem5_o3_learning/image-20250311135207240_hu18044602024549881621.png 480w, /2025/gem5_o3_learning/image-20250311135207240_hu15724206339638623331.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:161;flex-basis:388px><a href=/2025/gem5_o3_learning/v2-c3e789d58af32d1d3f731722f5fc7b76_1440w.jpeg data-size=1397x863><img src=/2025/gem5_o3_learning/v2-c3e789d58af32d1d3f731722f5fc7b76_1440w.jpeg width=1397 height=863 srcset="/2025/gem5_o3_learning/v2-c3e789d58af32d1d3f731722f5fc7b76_1440w_hu8355152863149321304.jpeg 480w, /2025/gem5_o3_learning/v2-c3e789d58af32d1d3f731722f5fc7b76_1440w_hu7752461498771057939.jpeg 1024w" loading=lazy alt="gem5-  c++/python co-binding"></a><figcaption>gem5- c++/python co-binding</figcaption></figure></p><h2 id=仿真前的初始化>仿真前的初始化</h2><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>sim</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>main</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>importer</span>() <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>importInit</span>()<span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>initAll</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>python</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>embedded</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>initAll</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>sim</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>init</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>initAll</span>()<span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>pybind_init_event</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>python</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>pybind11</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>event</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>pybind_init_event</span>() <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>simulate</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>sim</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>simulate</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>simulate</span>() <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>doSimloop</span>() <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>serviceOne</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>src</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>sim</span><span style=color:#56b6c2>/</span><span style=color:#e06c75>eventq</span>.<span style=color:#e06c75>cc</span>: <span style=color:#e06c75>serviceOne</span>() <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>eventq</span>.<span style=color:#e06c75>hh</span>:<span style=color:#e06c75>event</span><span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>process</span>()
</span></span></code></pre></div><h2 id=计算指令>计算指令</h2><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>Rename</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>Rename</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>RenameInsts</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>dispatchInsts</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>InstructionQueue</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>scheduleReadyInsts</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>executeInsts</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>IEW</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>writebackInsts</span>()
</span></span><span style=display:flex><span><span style=color:#e06c75>Commit</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>tick</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>Commit</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>commitInsts</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>Commit</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>commitHead</span>()
</span></span></code></pre></div><ul><li>重命名（<code>Rename::renameInsts()</code>）。顾名思义，就是将寄存器重命名，并将指令推送到 IEW 阶段。它会检查 IQ/LSQ 是否可以容纳新指令。</li><li>Dispatch（<code>IEW::dispatchInsts()</code>）。此函数将重命名的指令插入到 IQ 和 LSQ 中。</li><li>调度（<code>InstructionQueue::scheduleReadyInsts()</code>） IQ 管理就绪列表中的就绪指令（操作数就绪），并将它们调度到可用的 FU。FU 的延迟在这里设置，当 FU 完成时，指令将被发送执行。</li><li>执行（<code>IEW::executeInsts()</code>）。此处<code>execute()</code>调用计算指令函数并将其发送至提交。请注意<code>execute()</code>将把结果写入目标寄存器。</li><li>Writeback( <code>IEW::writebackInsts()</code>)。这里<code>InstructionQueue::wakeDependents()</code>调用。相关指令将被添加到就绪列表中以供调度。</li><li>提交（<code>Commit::commitInsts()</code>）。一旦指令到达ROB的头部，它将被提交并从ROB中释放。</li></ul><h2 id=访存指令>访存指令</h2><h3 id=load-指令>load 指令</h3><ul><li>加载指令与计算指令共享相同的路径直到执行。</li></ul><pre tabindex=0><code>Rename::tick()-&gt;Rename::RenameInsts()
IEW::tick()-&gt;IEW::dispatchInsts()
IEW::tick()-&gt;InstructionQueue::scheduleReadyInsts()
IEW::tick()-&gt;IEW::executeInsts()
  -&gt;LSQUnit::executeLoad()
    -&gt;StaticInst::initiateAcc()
      -&gt;LSQ::pushRequest()
        -&gt;LSQUnit::read()
          -&gt;LSQRequest::buildPackets()
          -&gt;LSQRequest::sendPacketToCache()
    -&gt;LSQUnit::checkViolation()
DcachePort::recvTimingResp()-&gt;LSQRequest::recvTimingResp()
  -&gt;LSQUnit::completeDataAccess()
    -&gt;LSQUnit::writeback()
      -&gt;StaticInst::completeAcc()
      -&gt;IEW::instToCommit()
IEW::tick()-&gt;IEW::writebackInsts()
</code></pre><ul><li><p><code>LSQUnit::executeLoad()</code>将通过调用指令的函数来启动访问<code>initiateAcc()</code>。通过执行上下文接口， <code>initiateAcc()</code>将调用<code>initiateMemRead()</code>并最终定向到<code>LSQ::pushRequest()</code>。</p></li><li><p><code>LSQ::pushRequest()</code>将分配一个<code>LSQRequest</code>来跟踪所有状态，并开始转换。转换完成后，它将记录虚拟地址并调用<code>LSQUnit::read()</code>。</p></li><li><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>LSQUnit::read()
</span></span></code></pre></div><p>将检查该负载是否与任何先前的存储有别名。</p><ul><li>如果可以转发，那么它将安排<code>WritebackEvent</code>下一个周期。</li><li>如果它是别名但不能转发，它会调用 <code>InstructionQueue::rescheduleMemInst()</code>和<code>LSQReuqest::discard()</code>。</li><li>否则，它会将数据包发送到缓存。</li></ul></li><li><p><code>LSQUnit::writeback()</code>将调用<code>StaticInst::completeAcc()</code>，它将把加载的值写入目标寄存器。然后该指令被推送到提交队列。<code>IEW::writebackInsts()</code> 然后将其标记为完成并唤醒其依赖项。从这里开始，它与计算指令共享相同的路径。</p></li></ul><h3 id=store-指令>store 指令</h3><pre tabindex=0><code>IEW::tick()-&gt;IEW::executeInsts()
  -&gt;LSQUnit::executeStore()
    -&gt;StaticInst::initiateAcc()
      -&gt;LSQ::pushRequest()
        -&gt;LSQUnit::write()
    -&gt;LSQUnit::checkViolation()
Commit::tick()-&gt;Commit::commitInsts()-&gt;Commit::commitHead()
IEW::tick()-&gt;LSQUnit::commitStores()
IEW::tick()-&gt;LSQUnit::writebackStores()
  -&gt;LSQRequest::buildPackets()
  -&gt;LSQRequest::sendPacketToCache()
  -&gt;LSQUnit::storePostSend()
DcachePort::recvTimingResp()-&gt;LSQRequest::recvTimingResp()
  -&gt;LSQUnit::completeDataAccess()
    -&gt;LSQUnit::completeStore()
</code></pre><ul><li>与<code>LSQUnit::read()</code>不同，<code>LSQUnit::write()</code>只会复制存储数据，但不会将数据包发送到缓存，因为存储尚未提交。</li><li>存储提交后，<code>LSQUnit::commitStores()</code>将标记 SQ 条目，以便<code>canWB</code>将<code>LSQUnit::writebackStores()</code>存储请求发送到缓存。</li><li>最后，当响应返回时，<code>LSQUnit::completeStore()</code>将释放 SQ 条目。</li></ul><h3 id=memory-order-fail>memory order fail</h3><p>InstructionQueue具有跟踪内存顺序依赖性的的功能<code>MemDepUnit</code>。如果 MemDepUnit 声明存在依赖性，IQ 将不会调度指令。</p><p>在<code>LSQUnit::read()</code> 中，LSQ 将搜索可能的别名存储并转发（如果可能）。否则，将阻止加载，并通过通知 MemDepUnit 重新安排，直到阻止存储完成。</p><p><code>LSQUnit::executeLoad/Store()</code>两者都将调用<code>LSQUnit::checkViolation()</code> 来搜索 LQ 以查找可能的错误推测。如果发现，它将设置 <code>LSQUnit::memDepViolator</code>并<code>IEW::executeInsts()</code>稍后启动以消除错误推测的指令。</p><pre tabindex=0><code>IEW::tick()-&gt;IEW::executeInsts()
  -&gt;LSQUnit::executeLoad()
    -&gt;StaticInst::initiateAcc()
    -&gt;LSQUnit::checkViolation()
  -&gt;IEW::squashDueToMemOrder()
</code></pre><h2 id=staticinst>staticinst</h2><p>StaticInst 为二进制指令提供所有静态信息和方法。</p><p>它包含以下信息/方法：</p><ul><li>标志来表明它是什么类型的指令（整数，浮点，分支，内存屏障等）</li><li>指令的操作类</li><li>源寄存器和目标寄存器的数量</li><li>使用的整数和浮点寄存器的数量</li><li>将二进制指令解码为 StaticInst 的方法</li><li>虚拟函数execute()，定义如何执行一条指令的具体架构操作（例如读取r1、r2，将它们添加并存储在r3中）。</li><li>虚拟函数来处理启动和完成内存操作</li><li>对于将内存操作拆分为两个操作的模型，虚拟函数分别执行地址计算和内存访问</li><li>反汇编指令的方法，以人类可读的格式打印出来。（例如 addq r1 r2 r3）</li></ul><p>它没有动态信息，例如指令的 PC 或源寄存器的值或结果。这允许将 StaticInst 1 对 1 映射到唯一的二进制机器指令。我们利用这一事实，将二进制指令到 StaticInst 的映射缓存在 hash_map 中，这样我们只需解码一次二进制指令，其余时间直接使用 StaticInst。</p><h2 id=dyninsts>DynInsts</h2><p>DynInst 用于保存有关指令的动态信息。这对于更详细的模型或无序模型是必需的，这两种模型都可能需要<a class=link href=https://www.gem5.org/documentation/general_docs/cpu_models/execution_basics#staticinsts target=_blank rel=noopener>StaticInsts</a>以外的额外信息才能正确执行指令。它存储的一些动态信息包括：</p><ul><li>指令的PC</li><li>源寄存器和目标寄存器的重命名寄存器索引</li><li>预测下一代 PC</li><li>指导结果</li><li>指令的线程号</li><li>执行该指令的 CPU</li><li>指令是否被压缩</li></ul><p>此外，DynInst 还提供了 ExecContext 接口。当执行 ISA 指令时，DynInst 将作为 ExecContext 传入，处理 ISA 对 CPU 状态的所有访问。</p><p>详细的 CPU 模型可以从 DynInst 派生，并创建自己的特定 DynInst 子类，以实现可能需要的任何附加状态或功能。请参阅 src/cpu/o3/alpha/dyn_inst.hh 以获取此示例。</p><h2 id=rename>rename</h2><h4 id=正常重命名><strong>正常重命名</strong></h4><ol><li>指令 <code>ADD R1, R2</code> 需重命名架构寄存器 <code>R1</code>。</li><li>当前映射 <code>map[R1] = P5</code>（旧寄存器）。</li><li>从 <code>freeList</code> 分配新物理寄存器 <code>P10</code>。</li><li>更新映射表：<code>map[R1] = P10</code>。</li><li>返回 <code>RenameInfo(P10, P5)</code>。</li></ol><h4 id=钉住寄存器重命名><strong>钉住寄存器重命名</strong></h4><ol><li>原子指令 <code>XCHG R3, [MEM]</code> 钉住 <code>R3</code>（<code>numPinnedWrites = 1</code>）。</li><li>后续指令尝试重命名 <code>R3</code> 时，检测到钉住计数 >0，保持映射 <code>P7</code>。</li><li>完成写入后，钉住计数减1，解除钉住。</li></ol><h2 id=gem5-timebuff>gem5 timebuff</h2><p><code>TimeBuffer</code> 是一个<strong>环形缓冲区</strong>，用于存储<strong>不同时间点</strong>的数据（如指令、状态等），支持：</p><ul><li><strong>时间偏移访问</strong>：可以访问“过去”（<code>past</code>）或“未来”（<code>future</code>）的数据。</li><li><strong>高效内存管理</strong>：通过预分配内存和 <code>placement new</code> 避免动态分配开销。</li><li><strong>线程安全</strong>：通过索引计算和边界检查保证数据访问的正确性。</li></ul><div class=table-wrapper><table><thead><tr><th style=text-align:left>变量</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><code>past</code></td><td style=text-align:left>可访问的“过去”时间步数（负数索引，如 <code>-1</code> 表示上一周期）。</td></tr><tr><td style=text-align:left><code>future</code></td><td style=text-align:left>可访问的“未来”时间步数（正数索引，如 <code>+1</code> 表示下一周期）。</td></tr><tr><td style=text-align:left><code>size</code></td><td style=text-align:left>缓冲区总大小（<code>size = past + future + 1</code>）。</td></tr><tr><td style=text-align:left><code>data</code></td><td style=text-align:left>预分配的内存块，存储所有数据（按 <code>sizeof(T)</code> 对齐）。</td></tr><tr><td style=text-align:left><code>index</code></td><td style=text-align:left>指针数组，每个元素指向 <code>data</code> 中一个时间点的数据。</td></tr><tr><td style=text-align:left><code>base</code></td><td style=text-align:left>环形缓冲区的当前基准索引（随 <code>advance()</code> 递增，模拟时间推进）。</td></tr><tr><td style=text-align:left><code>_id</code></td><td style=text-align:left>可选的缓冲区标识符（用于调试）。</td></tr></tbody></table></div><blockquote><p>index[i] 保存的是指针 ， 或者说是内存，是地址 ， 所以操作 new(index[ptr])T是直接在index[ptr]对应的地址上创建一个新的对象T ,在创建一个timebuffer 的时候就分配好了这一片内存</p></blockquote><p><figure class=gallery-image style=flex-grow:87;flex-basis:210px><a href=/2025/gem5_o3_learning/image-20250403201927705.png data-size=231x264><img src=/2025/gem5_o3_learning/image-20250403201927705.png width=231 height=264 srcset="/2025/gem5_o3_learning/image-20250403201927705_hu13499685319027115380.png 480w, /2025/gem5_o3_learning/image-20250403201927705_hu2202515542592325183.png 1024w" loading=lazy></a></figure></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#e06c75>TimeBuffer</span>(<span style=color:#e5c07b>int</span> <span style=color:#e06c75>p</span>, <span style=color:#e5c07b>int</span> <span style=color:#e06c75>f</span>)
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>:</span> <span style=color:#e06c75>past</span>(<span style=color:#e06c75>p</span>), <span style=color:#e06c75>future</span>(<span style=color:#e06c75>f</span>), <span style=color:#e06c75>size</span>(<span style=color:#e06c75>past</span> <span style=color:#56b6c2>+</span> <span style=color:#e06c75>future</span> <span style=color:#56b6c2>+</span> <span style=color:#d19a66>1</span>),
</span></span><span style=display:flex><span>          <span style=color:#e06c75>data</span>(<span style=color:#c678dd>new</span> <span style=color:#e5c07b>char</span>[<span style=color:#e06c75>size</span> <span style=color:#56b6c2>*</span> <span style=color:#c678dd>sizeof</span>(<span style=color:#e06c75>T</span>)]), <span style=color:#e06c75>index</span>(<span style=color:#e06c75>size</span>), <span style=color:#e06c75>base</span>(<span style=color:#d19a66>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>assert</span>(<span style=color:#e06c75>past</span> <span style=color:#56b6c2>&gt;=</span> <span style=color:#d19a66>0</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>future</span> <span style=color:#56b6c2>&gt;=</span> <span style=color:#d19a66>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#e5c07b>char</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>data</span>; <span style=color:#7f848e>// 内存的首地址 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#c678dd>for</span> (<span style=color:#e5c07b>unsigned</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> <span style=color:#56b6c2>&lt;</span> <span style=color:#e06c75>size</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>index</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>=</span> <span style=color:#e06c75>ptr</span>; 
</span></span><span style=display:flex><span>            <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>memset</span>(<span style=color:#e06c75>ptr</span>, <span style=color:#d19a66>0</span>, <span style=color:#c678dd>sizeof</span>(<span style=color:#e06c75>T</span>));
</span></span><span style=display:flex><span>            <span style=color:#c678dd>new</span> (<span style=color:#e06c75>ptr</span>) <span style=color:#e06c75>T</span>;
</span></span><span style=display:flex><span>            <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>+=</span> <span style=color:#c678dd>sizeof</span>(<span style=color:#e06c75>T</span>);  <span style=color:#7f848e>// 按照T的大小建立对象，并且赋值index[i] 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>_id</span> <span style=color:#56b6c2>=</span> <span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>注：此处的延迟与打拍特质ip内部的硬件行为，典型的如通过移位寄存器实现N个时钟的延迟，如fifo的硬件实现。（模块间的延迟，在gem5中可以通过 <a class=link href="https://zhida.zhihu.com/search?content_id=232363274&amp;content_type=Article&amp;match_order=1&amp;q=event%e8%b0%83%e5%ba%a6%e6%9c%ba%e5%88%b6&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDM4NDUxNTMsInEiOiJldmVudOiwg-W6puacuuWItiIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIzMjM2MzI3NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.beuQajf3pTcCnJqnteh--rAEmrAlw37yn9XE4RG9sHk&amp;zhida_source=entity" target=_blank rel=noopener>event调度机制</a>(参见 <a class=link href=https://zhuanlan.zhihu.com/p/587079919 target=_blank rel=noopener>gem5 源码阅读 之 event</a>)，直接设置调度时间event的在事件队列上的插入时间点来模拟）</p><h3 id=wire>wire</h3><p>wire是对timebuff元素指针的封装，本质上是一个指针（通过wire的成员变量 timerbuff* 和 当前wire在timerbuff中的位置 ：index 定位）通过wire的成员变量index，指示当前wire取自timebuff中那个位置的元素，特别的,index以参数形式传递给timerbuff的access方法，在内部实际访问元素时，是一个相对位置，即将获取相对于base作为0位置，偏移index的位置的元素的值</p><pre tabindex=0><code> T *operator-&gt;() const { return buffer-&gt;access(index); }
</code></pre><p>index 代表从这个数据缓存队列中实际取数的点，如果index=base-1 则代表通过wire拿到的是数据延迟一个cycle的值，如果index=base+1则代表通过wire那到的数据是当前时间前一个cycle的数据</p><blockquote><p>index 是一个偏移值</p></blockquote><p><figure class=gallery-image style=flex-grow:281;flex-basis:674px><a href=/2025/gem5_o3_learning/image-20250403194314969.png data-size=1057x376><img src=/2025/gem5_o3_learning/image-20250403194314969.png width=1057 height=376 srcset="/2025/gem5_o3_learning/image-20250403194314969_hu5177986229899195230.png 480w, /2025/gem5_o3_learning/image-20250403194314969_hu8329042262570232517.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:111;flex-basis:267px><a href=/2025/gem5_o3_learning/v2-a7fbd423b30b21d3cc046cd0936617c7_1440w.jpg data-size=1004x900><img src=/2025/gem5_o3_learning/v2-a7fbd423b30b21d3cc046cd0936617c7_1440w.jpg width=1004 height=900 srcset="/2025/gem5_o3_learning/v2-a7fbd423b30b21d3cc046cd0936617c7_1440w_hu3094215347825233840.jpg 480w, /2025/gem5_o3_learning/v2-a7fbd423b30b21d3cc046cd0936617c7_1440w_hu8360682057680467044.jpg 1024w" loading=lazy></a></figure></p><p>各种算数的重载都是在更新 buffer 和 index , 包括 = ， + ， - ， ++ ， &ndash; ，+= ， -= ， -> , *</p><p>其中 * 和 -></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>&amp;</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>*</span>() <span style=color:#c678dd>const</span> { <span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>buffer</span><span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>access</span>(<span style=color:#e06c75>index</span>); } <span style=color:#7f848e>//返回 T 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>-&gt;</span>() <span style=color:#c678dd>const</span> { <span style=color:#c678dd>return</span> <span style=color:#e06c75>buffer</span><span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>access</span>(<span style=color:#e06c75>index</span>); } <span style=color:#7f848e>// 返回 T *  
</span></span></span><span style=display:flex><span><span style=color:#7f848e>//access 返回的是 T* 类型的 ， 返回的就是 idx + base 对应的 内存 地址 ， 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*</span><span style=color:#61afef;font-weight:700>access</span>(<span style=color:#e5c07b>int</span> <span style=color:#e06c75>idx</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#e5c07b>int</span> <span style=color:#e06c75>vector_index</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>calculateVectorIndex</span>(<span style=color:#e06c75>idx</span>); <span style=color:#7f848e>// idx + base
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#c678dd>reinterpret_cast</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*&gt;</span>(<span style=color:#e06c75>index</span>[<span style=color:#e06c75>vector_index</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#7f848e>//
</span></span></span></code></pre></div><h3 id=advance>advance()</h3><p>advance() 函数，是负责timebuff时间推进的api, 一般有持有timebuff对象的parent负责调用，没调用一次，上文提到的base索引，向数据增值的方向(future方向)移动一个元素的位置，</p><p><figure class=gallery-image style=flex-grow:181;flex-basis:435px><a href=/2025/gem5_o3_learning/v2-f0954e5bf9842644ab7679e39f986ad7_1440w.jpg data-size=285x157><img src=/2025/gem5_o3_learning/v2-f0954e5bf9842644ab7679e39f986ad7_1440w.jpg width=285 height=157 srcset="/2025/gem5_o3_learning/v2-f0954e5bf9842644ab7679e39f986ad7_1440w_hu17772927455913905115.jpg 480w, /2025/gem5_o3_learning/v2-f0954e5bf9842644ab7679e39f986ad7_1440w_hu16655150562502060186.jpg 1024w" loading=lazy></a></figure></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e5c07b>void</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>advance</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 清理“未来”最远的数据（因为时间推进后它变成无效数据）
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#c678dd>if</span> (<span style=color:#56b6c2>++</span><span style=color:#e06c75>base</span> <span style=color:#56b6c2>&gt;=</span> <span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>base</span> <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 模拟时间步进，更新 base 并清理过期数据。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e5c07b>int</span> <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>base</span> <span style=color:#56b6c2>+</span> <span style=color:#e06c75>future</span>;
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> (<span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>&gt;=</span> (<span style=color:#e5c07b>int</span>)<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>-=</span> <span style=color:#e06c75>size</span>;
</span></span><span style=display:flex><span>        (<span style=color:#c678dd>reinterpret_cast</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*&gt;</span>(<span style=color:#e06c75>index</span>[<span style=color:#e06c75>ptr</span>]))<span style=color:#56b6c2>-&gt;~</span><span style=color:#e06c75>T</span>();
</span></span><span style=display:flex><span>        <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>memset</span>(<span style=color:#e06c75>index</span>[<span style=color:#e06c75>ptr</span>], <span style=color:#d19a66>0</span>, <span style=color:#c678dd>sizeof</span>(<span style=color:#e06c75>T</span>));
</span></span><span style=display:flex><span>        <span style=color:#c678dd>new</span> (<span style=color:#e06c75>index</span>[<span style=color:#e06c75>ptr</span>]) <span style=color:#e06c75>T</span>; <span style=color:#7f848e>// 在已经分配的内存上直接构造对象
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    }
</span></span></code></pre></div><h3 id=wire-getwireint-idx>wire getWire(int idx)</h3><p>上文已经说过 wire类型是对 timebuff 某一元素的封装，wire类型核心成员变量包括 指向timebuff的指针 和 确定元素位置的index，从而使用通过getWire得到的wire对象，都是指向当前timebuff的某一元素，特别的，此元素也是相对于base偏移index的元素，随着advance的执行，wire指向的元素也在移动，与设计硬件中随着时间的推移，统一寄存器承载不同的值 异曲同工，但从软件编程角度看，移动数组索引的代价远小于将整个数组时间平移而保持索引不变</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#e06c75>wire</span> <span style=color:#61afef;font-weight:700>getWire</span>(<span style=color:#e5c07b>int</span> <span style=color:#e06c75>idx</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>valid</span>(<span style=color:#e06c75>idx</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#e06c75>wire</span>(<span style=color:#c678dd>this</span>, <span style=color:#e06c75>idx</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>wire 包括 buffer 和 index ,</p><p>比方说getWire(-1) , 返回的是 wire(this,-1)</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>        <span style=color:#e06c75>TimeBuffer</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>buffer</span>;
</span></span><span style=display:flex><span>        <span style=color:#e5c07b>int</span> <span style=color:#e06c75>index</span>;
</span></span></code></pre></div><p><figure class=gallery-image style=flex-grow:259;flex-basis:623px><a href=/2025/gem5_o3_learning/v2-3e95487e41fc13905c3e2d59134612b2_1440w.jpg data-size=639x246><img src=/2025/gem5_o3_learning/v2-3e95487e41fc13905c3e2d59134612b2_1440w.jpg width=639 height=246 srcset="/2025/gem5_o3_learning/v2-3e95487e41fc13905c3e2d59134612b2_1440w_hu7665833910306396044.jpg 480w, /2025/gem5_o3_learning/v2-3e95487e41fc13905c3e2d59134612b2_1440w_hu14551924278376815349.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><h3 id=t-accessint-idx>T *access(int idx)</h3><p>access api 基本只会在wire中被调用，当需要获取wire对象的值，即其指向的timebuff中的元素的值时，会通过timebuff::access 方法来获取，该方法做两件事情：</p><ol><li>通过timebuff::calculateVectorIndex 计算元素位置：因为timebuff的数据结构是一个数组，需要通过调整索引使其具有ringbuffer的特征，主要是在涉及数组收尾时的索引调整</li><li>返回数据元素：前提到timebuff具有一个元素类型的模板参数，而timebuff的数据是char型数组，需要根据元素类型和占用空间大小，返回对应存储位置上的数据</li></ol><p>access 返回的是 T* 类型的 ， 返回的就是 idx + base 对应的 内存 地址 ，</p><h3 id=timebuff-延迟模型>TimeBuff 延迟模型</h3><p>通过前面的描述，我们已经知道了如何使用native C++实现一个移位寄存器，进而可以实现硬件电路中的延迟行为，因为时序电路的核心特点之一就是“寄存”</p><p>cpu的流水线中，各个stage是一个比较紧耦合的状态，各stage的间的交互信号也比较多，并且会涉及到很多信号的前向传播和后项传播:</p><ol><li>典型的前向传播例如fetch取值后，传递给下一级decoder, 其行为可抽象成移位寄存器，</li><li>典型的后向传播例如分支指令的执行结果传递到前级fetch单元，一边更新更新预测期，修正取值PC</li></ol><p>后向传播行为，本质上可以抽象为一个移位寄存器，举例来说，fetch单元拿到了执行阶段的分支指令的执行结果，可以是执行阶段当前时刻或是延迟N个cycle的值。</p><p>因而在gem5的<a class=link href="https://zhida.zhihu.com/search?content_id=232363274&amp;content_type=Article&amp;match_order=1&amp;q=O3%e5%a4%84%e7%90%86%e5%99%a8&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDM4NDUxNTMsInEiOiJPM-WkhOeQhuWZqCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIzMjM2MzI3NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.vwcoJie_Mr6G_ntxgi1JjL0CvSRVZ8itWqNubf6fTXs&amp;zhida_source=entity" target=_blank rel=noopener>O3处理器</a>中，就分别定了了各stage间的前向传播timebff与后项传播timebuff, 其中，timebuff作为容器，其承载的数据元素为各stage需要传播的所有数据的结构体类型、</p><p>在gem5中，cpu功能的实现，因为timebuff的存在，划分为两个部分， <strong>功能实现和延迟模型</strong>，其中功能实现完成每个stage的功能逻辑并生产数据，比如decder完成指令的解码，而延迟模型单纯负责实现的处理，将功能实现中产生的数据放入timebuff,再有后级通过 wire类型(参见前面章节) 获取对应延迟周期的数据。</p><p><figure class=gallery-image style=flex-grow:412;flex-basis:990px><a href=/2025/gem5_o3_learning/v2-d972d73b0ebc059dcf40f0acb091f4a7_1440w.jpg data-size=1090x264><img src=/2025/gem5_o3_learning/v2-d972d73b0ebc059dcf40f0acb091f4a7_1440w.jpg width=1090 height=264 srcset="/2025/gem5_o3_learning/v2-d972d73b0ebc059dcf40f0acb091f4a7_1440w_hu13207120455469315893.jpg 480w, /2025/gem5_o3_learning/v2-d972d73b0ebc059dcf40f0acb091f4a7_1440w_hu6137225920010514055.jpg 1024w" loading=lazy alt=img></a><figcaption>img</figcaption></figure></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#7f848e>// 在cpu初始化的时候调用setQueue同步了不同module的queue 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>fetch</span>.<span style=color:#e06c75>setFetchQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>fetchQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>decode</span>.<span style=color:#e06c75>setFetchQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>fetchQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>commit</span>.<span style=color:#e06c75>setFetchQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>fetchQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>decode</span>.<span style=color:#e06c75>setDecodeQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>decodeQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>rename</span>.<span style=color:#e06c75>setDecodeQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>decodeQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>rename</span>.<span style=color:#e06c75>setRenameQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>renameQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>iew</span>.<span style=color:#e06c75>setRenameQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>renameQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>iew</span>.<span style=color:#e06c75>setIEWQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iewQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>commit</span>.<span style=color:#e06c75>setIEWQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iewQueue</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>commit</span>.<span style=color:#e06c75>setRenameQueue</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>renameQueue</span>);
</span></span><span style=display:flex><span><span style=color:#e5c07b>void</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>Commit</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>setFetchQueue</span>(<span style=color:#e06c75>TimeBuffer</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>FetchStruct</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>fq_ptr</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e06c75>fetchQueue</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>fq_ptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 此时是已经对fromFetch 之类的值 按照 延时 getWire 了 ， 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#7f848e>// 比方说fromFetch 得到的就是 (*TimeBuffer, -1) , 即 index 是 -1 ， timebufer 成功连接上了cpu 总体的timebuff 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#7f848e>// Setup wire to get instructions from rename (for the ROB).
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#7f848e>// buffer 的赋值还是同一个buffer , 主要就是index进行了改变 
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>fromFetch</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>fetchQueue</span><span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>getWire</span>(<span style=color:#56b6c2>-</span><span style=color:#e06c75>fetchToCommitDelay</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#7f848e>// 在set之后，后续的操作就是调用advance , 在advance 的时候，主要是base 在增加 
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// 因为都是指针的运算 ， fromFetch里面是一个TimeBuffer的指针，指向cpu的那边TimeBuffer , 在后续访问FromFetch 的时候，都是通过access来访问 ， 即通过base 和 index 计算出需要取的数据的地址，然后去取 
</span></span></span></code></pre></div><blockquote><p>这样只要在初始的时候确定好 index ， 就能狗稳定取出当前时间轴的前面或者后面的数据了</p></blockquote><h2 id=gem5-event>gem5 event</h2><h3 id=role>role</h3><p>gem5是一个event-driven类型的仿真器，从而可以更高效的处理每个“动作/响应”，而不需要轮询全局时间，判断event是否该被执行了，从而减少了大量的执行时间.</p><p>Gem5中的基础class <a class=link href="https://zhida.zhihu.com/search?content_id=218596916&amp;content_type=Article&amp;match_order=1&amp;q=SimObject&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDQxNjUyMzQsInEiOiJTaW1PYmplY3QiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMTg1OTY5MTYsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.pc6Lo1rC1NmnL6G2OzxHE8DME6lPG0I8NE6q7FQardQ&amp;zhida_source=entity" target=_blank rel=noopener>SimObject</a> 就继承自EventManager, 因而每个有SimObject派生而来的对象，都可以承担EventManager的职责，特别的，SimObject将持有：</p><ol><li>一个EventQueue对象的指针，指向一个全局EventQueue（参见<em><strong>Event tree</strong></em>）</li><li>Schedule 方法</li></ol><p>其中schdule方法将对象的Event排序插入到全局EventQueue中，而这就是创建全局Event tree的过程，参见<em><strong>Event tree</strong></em>。</p><h3 id=event-queue>Event Queue</h3><p>event的执行又是基于when+priority值排序的，通过 EventManager.schedule &mdash;> EventQueue.schedule 最终将某个Event排序并插入到EventQueue中，而EventQueue 在gem5中是全局变量，所有simObject的Event最终都将被注册到这几个queue中的某一个</p><p>未完</p><h2 id=o3-流水线的详细分析>o3 流水线的详细分析</h2><h3 id=以某一条指令为例子>以某一条指令为例子</h3><p>可以看出来是8发射的</p><p><figure class=gallery-image style=flex-grow:282;flex-basis:678px><a href=/2025/gem5_o3_learning/image-20250413002549372.png data-size=1193x422><img src=/2025/gem5_o3_learning/image-20250413002549372.png width=1193 height=422 srcset="/2025/gem5_o3_learning/image-20250413002549372_hu11228186284351161241.png 480w, /2025/gem5_o3_learning/image-20250413002549372_hu14795775061635398957.png 1024w" loading=lazy></a></figure></p><p>以这条c_li为例子， 500作为单位粒度</p><p><figure class=gallery-image style=flex-grow:474;flex-basis:1137px><a href=/2025/gem5_o3_learning/image-20250413002621824.png data-size=640x135><img src=/2025/gem5_o3_learning/image-20250413002621824.png width=640 height=135 srcset="/2025/gem5_o3_learning/image-20250413002621824_hu9230471427412902551.png 480w, /2025/gem5_o3_learning/image-20250413002621824_hu941025651433306006.png 1024w" loading=lazy alt=image-20250413002621824></a><figcaption>image-20250413002621824</figcaption></figure></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> 135000: system.cpu.decoder: Requesting bytes 0x433db525 from address 0x10928
</span></span><span style=display:flex><span> 135000: system.cpu.decoder: Decoding instruction 0x0000433d at address 0x1092a
</span></span><span style=display:flex><span> 135000: global: DynInst: <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> Instruction created. Instcount <span style=color:#c678dd>for</span> system.cpu <span style=color:#56b6c2>=</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> created <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Instruction is: c_li t1, <span style=color:#d19a66>15</span>
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Fetch queue entry created <span style=color:#56b6c2>(</span>1/32<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> 135500: system.cpu.decode: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Sending instruction to rename.
</span></span><span style=display:flex><span> 135500: system.cpu.decode: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Processing instruction <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Sending instructions to IEW.
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Processing instruction <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 136000: global: Renamed reg integer<span style=color:#56b6c2>[</span>6<span style=color:#56b6c2>]</span> to physical reg <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>41<span style=color:#56b6c2>)</span> old mapping was <span style=color:#d19a66>6</span> <span style=color:#56b6c2>(</span>6<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Renaming arch reg <span style=color:#d19a66>6</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span> to physical reg <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>41<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> Adding instruction to <span style=color:#e5c07b>history</span> buffer <span style=color:#56b6c2>(</span><span style=color:#e06c75>size</span><span style=color:#56b6c2>=</span>1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 136500: system.cpu.commit: Getting instructions from Rename stage.
</span></span><span style=display:flex><span> 136500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> Inserting PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> into ROB.
</span></span><span style=display:flex><span> 136500: system.cpu.rob: Adding inst PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> to the ROB.
</span></span><span style=display:flex><span> 136500: system.cpu.rob: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Now has <span style=color:#d19a66>1</span> instructions.
</span></span><span style=display:flex><span> 136500: system.cpu.commit: Trying to commit instructions in the ROB.
</span></span><span style=display:flex><span> 136500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Can<span style=color:#98c379>&#39;t commit, Instruction [sn:13] PC (0x1092a=&gt;0x1092c).(0=&gt;1) is head of ROB and not ready
</span></span></span><span style=display:flex><span><span style=color:#98c379>
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.iew: Issue: Processing [tid:0]
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.iew: [tid:0] Not blocked, so attempting to run dispatch.
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.iew: [tid:0] Issue: Adding PC (0x1092a=&gt;0x1092c).(0=&gt;1) [sn:13] [tid:0] to IQ. ## dispatch inst 
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.iq: Adding instruction [sn:13] PC (0x1092a=&gt;0x1092c).(0=&gt;1) to the IQ. # instruction_queue.insert() inst_queue.cc 
</span></span></span><span style=display:flex><span><span style=color:#98c379>  137000: system.cpu.iq: Instruction is ready to issue, putting it onto the ready list, PC (0x1092a=&gt;0x1092c).(0=&gt;1) opclass:1 [sn:13]. ## 在instruction_queu.insert()中如果不是访存指令会执行addIFReady , 判断指令是否ready to issue ,是的话会加入readyInsts 
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.iq: Thread 0: Issuing instruction PC (0x1092a=&gt;0x1092c).(0=&gt;1) [sn:13] # InstructionQueue::scheduleReadyInsts() inst_queue.cc , 选取readyInsts中的insts issue  
</span></span></span><span style=display:flex><span><span style=color:#98c379> 137000: system.cpu.commit: [tid:0] Can&#39;</span>t commit, Instruction <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> is head of ROB and not ready
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Execute: Executing instructions from IQ.## 这里就是executeinst中的指令会被执行 
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Execute: Processing PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 137500: global: RegFile: Setting int register <span style=color:#d19a66>41</span> to 0xf  <span style=color:#7f848e>## 调用inst-&gt;execute 执行指令 </span>
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Sending instructions to commit, <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>. <span style=color:#7f848e>## writebackInsts() </span>
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking dependents of completed instruction.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking any dependents on register <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking up a dependent instruction, <span style=color:#56b6c2>[</span>sn:15<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092e</span><span style=color:#56b6c2>=</span>&gt;0x10932<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Can&#39;t commit, Instruction <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> is head of ROB and not ready
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 138000: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Marking PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> ready within ROB.
</span></span><span style=display:flex><span> 138000: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Instruction <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> is head of ROB and ready to commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 138500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> Committing instruction with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 138500: system.cpu.rob: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Retiring head instruction, instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span> 138500: system.cpu: Removing committed instruction <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span> 138500: system.cpu: Removing instruction, <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span></code></pre></div><p>再找一条addi</p><p><figure class=gallery-image style=flex-grow:453;flex-basis:1088px><a href=/2025/gem5_o3_learning/image-20250413151104704.png data-size=608x134><img src=/2025/gem5_o3_learning/image-20250413151104704.png width=608 height=134 srcset="/2025/gem5_o3_learning/image-20250413151104704_hu8381175566214838772.png 480w, /2025/gem5_o3_learning/image-20250413151104704_hu18106490195205124056.png 1024w" loading=lazy></a></figure></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> 135000: system.cpu.decoder: Decoding instruction 0x00f77793 at address 0x10932
</span></span><span style=display:flex><span> 135000: system.cpu.decoder: Decode: Decoded andi instruction: 0x5000010000f77793
</span></span><span style=display:flex><span> 135000: global: DynInst: <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> Instruction created. Instcount <span style=color:#c678dd>for</span> system.cpu <span style=color:#56b6c2>=</span> <span style=color:#d19a66>4</span>
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> created <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Instruction is: andi a5, a4, <span style=color:#d19a66>15</span>
</span></span><span style=display:flex><span> 135000: system.cpu.fetch: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Fetch queue entry created <span style=color:#56b6c2>(</span>4/32<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 135500: system.cpu.decode: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Sending instruction to rename.
</span></span><span style=display:flex><span> 135500: system.cpu.decode: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Processing instruction <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Sending instructions to IEW.
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Processing instruction <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Looking up integer arch reg 14, got phys reg <span style=color:#d19a66>42</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Register <span style=color:#d19a66>42</span> <span style=color:#56b6c2>(</span>flat: 42<span style=color:#56b6c2>)</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span> is not ready.
</span></span><span style=display:flex><span> 136000: global: Renamed reg integer<span style=color:#56b6c2>[</span>15<span style=color:#56b6c2>]</span> to physical reg <span style=color:#d19a66>43</span> <span style=color:#56b6c2>(</span>43<span style=color:#56b6c2>)</span> old mapping was <span style=color:#d19a66>15</span> <span style=color:#56b6c2>(</span>15<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Renaming arch reg <span style=color:#d19a66>15</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span> to physical reg <span style=color:#d19a66>43</span> <span style=color:#56b6c2>(</span>43<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 136000: system.cpu.rename: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> Adding instruction to <span style=color:#e5c07b>history</span> buffer <span style=color:#56b6c2>(</span><span style=color:#e06c75>size</span><span style=color:#56b6c2>=</span>3<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 136500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> Inserting PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> into ROB.  // getinst<span style=color:#56b6c2>()</span> from commit.cc 
</span></span><span style=display:flex><span> 136500: system.cpu.rob: Adding inst PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> to the ROB. // insertinst<span style=color:#56b6c2>()</span> rob.cc 
</span></span><span style=display:flex><span> 136500: system.cpu.rob: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Now has <span style=color:#d19a66>4</span> instructions.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 137000: system.cpu.iew: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Issue: Adding PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> to IQ. // dispatch 
</span></span><span style=display:flex><span> 137000: system.cpu.iq: Adding instruction <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> to the IQ.
</span></span><span style=display:flex><span> 137000: system.cpu.iq: Instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> has src reg <span style=color:#d19a66>42</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span> that is being added to the dependency chain. <span style=color:#7f848e># 这里体校了和前面的不同，前面直接发射了 </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Sending instructions to commit, <span style=color:#56b6c2>[</span>sn:13<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092a</span><span style=color:#56b6c2>=</span>&gt;0x1092c<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking dependents of completed instruction.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking any dependents on register <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking up a dependent instruction, <span style=color:#56b6c2>[</span>sn:15<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092e</span><span style=color:#56b6c2>=</span>&gt;0x10932<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Instruction is ready to issue, putting it onto the ready list, PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092e</span><span style=color:#56b6c2>=</span>&gt;0x10932<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> opclass:1 <span style=color:#56b6c2>[</span>sn:15<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 137500: global: <span style=color:#56b6c2>[</span>sn:15<span style=color:#56b6c2>]</span> has <span style=color:#d19a66>2</span> ready out of <span style=color:#d19a66>2</span> sources. RTI 0<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Setting Destination Register <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 137500: system.cpu.scoreboard: Setting reg <span style=color:#d19a66>41</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span> as ready
</span></span><span style=display:flex><span> 137500: system.cpu.iew: Sending instructions to commit, <span style=color:#56b6c2>[</span>sn:14<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x1092c</span><span style=color:#56b6c2>=</span>&gt;0x1092e<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking dependents of completed instruction.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking any dependents on register <span style=color:#d19a66>42</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Waking up a dependent instruction, <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 137500: global: <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> has <span style=color:#d19a66>1</span> ready out of <span style=color:#d19a66>1</span> sources. RTI 0<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Instruction is ready to issue, putting it onto the ready list, PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> opclass:1 <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 137500: system.cpu.iq: Thread 0: Issuing instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 138000: system.cpu.iew: Execute: Executing instructions from IQ.
</span></span><span style=display:flex><span> 138000: system.cpu.iew: Execute: Processing PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>.
</span></span><span style=display:flex><span> 138000: global: RegFile: Access to int register 42, has data 0x1fda0
</span></span><span style=display:flex><span> 138000: global: RegFile: Setting int register <span style=color:#d19a66>43</span> to <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span> 138000: system.cpu.iew: Current wb cycle: 0, width: 8, numInst: <span style=color:#d19a66>1</span>  <span style=color:#7f848e>## InsttoCommit()</span>
</span></span><span style=display:flex><span> 138000: system.cpu.iew: Sending instructions to commit, <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 138000: system.cpu.iq: Waking dependents of completed instruction.
</span></span><span style=display:flex><span> 138000: system.cpu.iq: Waking any dependents on register <span style=color:#d19a66>43</span> <span style=color:#56b6c2>(</span>integer<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span> 138000: system.cpu.iq: Waking up a dependent instruction, <span style=color:#56b6c2>[</span>sn:17<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10936</span><span style=color:#56b6c2>=</span>&gt;0x10938<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 138500: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Marking PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> ready within ROB.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 139000: system.cpu.commit: Trying to commit head instruction, <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span> 139000: system.cpu.commit: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> Committing instruction with PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span><span style=display:flex><span> 139000: system.cpu.rob: <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> Retiring head instruction, instruction PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>, <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span> 139000: system.cpu: Removing committed instruction <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span>
</span></span><span style=display:flex><span> 139000: system.cpu: Removing instruction, <span style=color:#56b6c2>[</span>tid:0<span style=color:#56b6c2>]</span> <span style=color:#56b6c2>[</span>sn:16<span style=color:#56b6c2>]</span> PC <span style=color:#56b6c2>(</span><span style=color:#e06c75>0x10932</span><span style=color:#56b6c2>=</span>&gt;0x10936<span style=color:#56b6c2>)</span>.<span style=color:#56b6c2>(</span><span style=color:#e06c75>0</span><span style=color:#56b6c2>=</span>&gt;1<span style=color:#56b6c2>)</span>
</span></span></code></pre></div><p>可以通过log 来看一下，一条简单的算数指令会调用什么函数 ，</p><p>所以在rename 的第二个周期，确实是会去输入rob 的 ， 在commit 里有调用 rob 的insertrob</p><h3 id=iew>iew</h3><p>在iew 阶段 ， 先做sorInsts() ,把从rename 获取的指令(fromRename)写入inst 队列 ，</p><p>然后再做dispatch ,把inst队列的数据派到发射队列里去，instqueue , ldstrqueue，直接是insert ,这里会去赋值toRename ，这个inst_queue 的insert里干了很多事情 ， 包括根据源寄存器标记 dependencies（那些没有ready的), addIfReady , 对于ready 的指令可以直接加入readyInst队列，scheduleReadyInst 就是去调度readyInst队列，在下一个周期进行issue 的</p><p>然后是executeInsts ，</p><p>在executeInsts时，获取instQueue的首条指令 ，进行执行 ，size 是从fromIssue获取的,getInstToexecute获取的是instsToExecute的开头 ， instsToExecute 是在scheduleReadyInst的时候更新的，和size是同步更新的，</p><p>然后是writebackinsts , 根据toCommit中的指令(toCommit 是 iewqueue的内容，是在insttocommit 函数进行设置toCommit (这是在executeinst调用的) ， executeinsts 会对函数进行调用 ， 对发射队列进行wakeDepentends (根据目的寄存器更新依赖), 设置scordboard(目标寄存器已经ready了) ,</p><p>然后是inst_queue.scheduleReadyInst ， 是获取新的可以进行执行的指令，就是从readyInst[]队列中进行获取，要赋值instsToexecute和相应的size , 然后是issueToExecQueue .advance , 去把队列前进一步(其实这里不前进获取的也是对的，新的size 本身就会被executeinst检测到，但是如果前进的话，赋值就会赋值新的size , 然后execute是调用旧的size,唯一的差距就是size在赋值之后不会被替换) 。</p><p>按照流水线的顺序正常执行 ， 这个cycle 赋值了 torename , 然后会advance , 所以rename 得到的正好就是上一个周期获得的数据 ，但是这样的话，即使没有timebuffer 也能够实现 ，不过这样的话会进行覆盖 。</p><p>TimeBuffer 是往前传输数据的 ， 各种queue是往后传输数据的</p><p>对于gem5 o3 , dispatch 和 issue 可以在同一个时钟周期 ，这是最极致的</p><h3 id=commit>commit</h3><p>在 commit 阶段 ， 通过 markCompletedInsts 可以标记指令已经完成了，fromIEW->insts， 就是iewqueue的内容 ， 此时如果发现头部的指令是标记为commit 的话，也会log ready to commit , 反之 log it not ready , commit 是在 markcommit 之前的 ， 所以这周期标记commit 的下一周期才能commit</p><p>如果是ready to commit 的话 ， commit 函数会调用 commitinst 函数 ， 调用commithead , (多说一句，getinst是从rename 里取了inst ,), commithead 里也有rob 调用的 retirehead函数 ， 肯定会更新rob ， 然后也会调用cpu removeFrontInst , 一条指令彻底结束 。</p><h2 id=gem5-流水线的状态控制>gem5 流水线的状态控制</h2><p>就以rename 作为例子 ， 对于每一个流水线 ，都有一个变量 ， 比方说rename 就是renamestatus</p><pre tabindex=0><code>1. 阶段整体状态
所有阶段都有一个整体状态变量_status，通常包含：

Active：阶段活跃，正在处理指令
Inactive：阶段空闲，没有工作要做
Blocked：阶段被阻塞，等待下游资源可用
2. 线程级状态
每个阶段为每个线程维护一个更细粒度的状态变量，如decodeStatus[tid]，包含：

Running：正常处理指令
Idle：线程没有指令需要处理
Blocked：线程被下游阶段阻塞
Unblocking：线程正从阻塞状态恢复
Squashing：线程正在处理分支预测错误或异常的恢复
</code></pre><p>当下游资源不足的时候，流水线会进行阻塞状态 ，下游会显式的通过 fromRename 之类的去向流水线发送block 状态</p><p>比方说 rename , 它在tick 的时候 ，首先就会对所有线程进行 checkSignalsAndUpdate(tid)</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#c678dd>while</span> (<span style=color:#e06c75>threads</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>end</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>ThreadID</span> <span style=color:#e06c75>tid</span> <span style=color:#56b6c2>=</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>threads</span><span style=color:#56b6c2>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#e06c75>DPRINTF</span>(<span style=color:#e06c75>Rename</span>, <span style=color:#98c379>&#34;Processing [tid:%i]</span><span style=color:#98c379>\n</span><span style=color:#98c379>&#34;</span>, <span style=color:#e06c75>tid</span>);
</span></span><span style=display:flex><span>        <span style=color:#e06c75>status_change</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>checkSignalsAndUpdate</span>(<span style=color:#e06c75>tid</span>) <span style=color:#56b6c2>||</span> <span style=color:#e06c75>status_change</span>;
</span></span><span style=display:flex><span>        <span style=color:#e06c75>rename</span>(<span style=color:#e06c75>status_change</span>, <span style=color:#e06c75>tid</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>checkSignalAndUpdate</p><p>其中会检查资源是否不足（IQ , ROB , LQ , SQ , FreeList ， iew 是否向 rename 发送了 block 信号</p><blockquote><p>它的一系列资源的检查都是from_iew 里获取的 ， why ?</p><p>fromiew 是iew 上一个周期处理获得的一些数据 ， 从寄存器角度这周期确实应该得到了</p><p>它获取的freeIQEntries ， freeLQEntries ，之类的都是通过from_iew 获取的 ， freeROBEntries , 是在commit 阶段获取的</p><p>然后rename 在calcFreeROBEntries 的时候， 计算公式是这样的 ，</p><p>其实from哪里是无所谓的，主要是要获得上一周期的数据 ， fromcommit 主要是commit 阶段有上个周期的rob 数据 ， fromiew 是因为有上个周期dispatch 的数据</p><p>这种统计说明上周期dispatch 的还没被commit 感知到 ， 因为它获取的也是上周期的robEntries</p><p>这周期commit 是能够知道dispatch 的 ， 但是在rename 这个阶段是没有进行更新的</p><p>上面的2句话是错误的 ， 因为实际上不是dispatch 的时候发送给rob , 而是rename的时候发送给rob ,</p><p>所以freeEnties 是已经减去了dispatch的指令数的</p><p>其实不用考虑的这么复杂 ， instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched) 才是本周期已经重命名但是没有发射的 ， 所以需要预留位置</p><p>int num_free = freeEntries[tid].robEntries -
(instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);</p><p>已经经过rename 但是还未分发的指令已经消耗了ROB空间 ， 需要从总空闲条目中减去</p><p>对于instInProgress , 当指令通过rename阶段的时候，计数器增加，当指令从iew成功分发到指令队列的时候，计数器减少 instinprogress跟踪正在流水线中移动但是尚未进入指令队列/load-store 队列的指令</p><p>其实也是从freeIEW处获取的 ，</p></blockquote><pre tabindex=0><code>    // Check if there&#39;s a squash signal, squash if there is
    // Check stall signals, block if necessary.
    // If status was blocked
    //     check if stall conditions have passed
    //         if so then go to unblocking
    // If status was Squashing
    //     check if squashing is not high.  Switch to running this cycle.
    // If status was serialize stall
    //     check if ROB is empty and no insts are in flight to the ROB
</code></pre><pre tabindex=0><code>                 +----------+
                 |   Idle   |&lt;--------+
                 +-----+----+         |
                       |              |
                       | 有指令需处理  |
                       V              |
                 +----------+         |
                 |  Running |         | 没有指令
                 +-----+----+         |
                       |              |
                       |              |
        +--------+-----+-----+--------+
        |        |           |        |
    资源不足    分支预测错误   正常处理完成
        |        |           |
        V        V           |
   +--------+ +----------+   |
   | Blocked | | Squashing| &lt;+
   +----+---+ +-----+----+
        |           |
   阻塞条件消失   清除完成
        |           |
        V           |
   +-----------+    |
   | Unblocking|    |
   +-----+-----+    |
         |          |
    skid buffer空   |
         |          |
         +----------+
</code></pre><p>block 状态的转变有两种 ， 一种是在前面发现资源的时候根据前面周期的就判断出来资源不足， 还有一种是在renameInst的时候发现当前需要重命名的指令数是&lt;资源数的</p><p>在sortInsts 时是不需要判断状态的 ，所以即使是阻塞 ， 实际也是inst 先从 fromdecode -> inst 到 inst , 再到 skidbuffer</p><p>cycle 0 , 先在更新状态是发现要block , 然后inst 会从 inst buffer 移动到skidbuffer , 状态进入block ,</p><p>在cycle 1 , 此时状态是block 了 ， decode 也不会产出新的inst 了 ， 不过decode 上周期产出的inst 也会输入到skidbuffer ,</p><p>block 在硬件中是相当于ready 信号 ， 不过有一些不一样的就是，比方说cycle 0 , rename 发现无法dispatch 了 ，它会把ready 信号拉低 ， 在下一周期rename 输入的inst 就是不变的</p><p>但是 ，在gem5 中 ， cycle 0 判断出无法dispatch 了 ， 设置为block , 此时会把inst 输入到 skidbuffer , 不过此时decode已经对指令进行了处理，并且放在了torename队列上 ，所以正常来说 cycle 1 周期 ， rename 还是能够接受到 decode 传入的数据 ，这个数据还是会被输入到skidbuffer</p><p>decode 唯一block 的理由就是 rename block 了 ， decode 无法发送到下一级</p><p>在unblock 的时候，会把skid buffer 的数据发送完 ，发完之后，再进入running mode</p><p>看这里decode 是Blocking 状态 ， 但是rename 还是接收了inst 到 skidbuffer , 和上面的分析是一致的 ，是上个周期进行decode 的 数据</p><p><figure class=gallery-image style=flex-grow:186;flex-basis:446px><a href=/2025/gem5_o3_learning/image-20250419142008614.png data-size=1410x758><img src=/2025/gem5_o3_learning/image-20250419142008614.png width=1410 height=758 srcset="/2025/gem5_o3_learning/image-20250419142008614_hu5005971208709278762.png 480w, /2025/gem5_o3_learning/image-20250419142008614_hu17172815589540901216.png 1024w" loading=lazy></a></figure></p><p>硬件上 ， 把数据全都dispatch 之后会把ready 拉高 ， 下一周期就可以获取到新的数据了</p><p>对于gem5 , 在block 之后会先转为unblock , 把skidbuffer 的数据发完 ， 然后再让decode 提供新的数据 ， 本身 skidbuffer 里多了一组数据 ， 在硬件能够ready 的那个周期，它去发送skidbuffer 的数据 ， 不过如果能在周期发完，就是running了 ，此时decode 感知到unblock 了 ， 下个周期decode可以放数据了，但是下一周期rename 感知到的是decode 无数据吧，</p><blockquote><p>总感觉会有性能的损失 ， rename 在 cycle 0 通知 decode unblock 了 ，cycle1 的时候 decode 开始获取新的指令 ， rename 会在cycle 2 的时候得到那一组指令 ， 对的， 在可以running 的那个周期，实际上空跑了 ？</p><p>如果此时decode 是没有指令的，那就是合理的 ， 确实是 ， decode 阻塞了 ， fetch 应该</p></blockquote><p><figure class=gallery-image style=flex-grow:320;flex-basis:770px><a href=/2025/gem5_o3_learning/image-20250419164832711.png data-size=1425x444><img src=/2025/gem5_o3_learning/image-20250419164832711.png width=1425 height=444 srcset="/2025/gem5_o3_learning/image-20250419164832711_hu12862425231972313929.png 480w, /2025/gem5_o3_learning/image-20250419164832711_hu5502443116281225258.png 1024w" loading=lazy></a></figure></p><h3 id=一条load-指令的所有-log>一条load 指令的所有 log</h3><p>这应该是一条load hit 的load 指令</p><p><figure class=gallery-image style=flex-grow:3516;flex-basis:8438px><a href=/2025/gem5_o3_learning/image-20250423102946586.png data-size=1090x31><img src=/2025/gem5_o3_learning/image-20250423102946586.png width=1090 height=31 srcset="/2025/gem5_o3_learning/image-20250423102946586_hu7852976632522816433.png 480w, /2025/gem5_o3_learning/image-20250423102946586_hu7587512065775351436.png 1024w" loading=lazy></a></figure></p><pre tabindex=0><code class=language-assembly data-lang=assembly>7775500: system.cpu.decoder: Requesting bytes 0x681cfcbf from address 0x30100
7775500: system.cpu.decoder: pc 30102 , vl 0 vsew 0 vlmul0
7775500: system.cpu.decoder: Decoding instruction 0x0000681c at address 0x30102
7775500: system.cpu.decoder: Decode: Decoded c_ld instruction: 0x500001000000681c
7775500: global: DynInst: [sn:10846] Instruction created. Instcount for system.cpu = 38
7775500: system.cpu.fetch: [tid:0] Instruction PC (0x30102=&gt;0x30104).(0=&gt;1) created [sn:10846].
7775500: system.cpu.fetch: [tid:0] Instruction is: c_ld a5, 16(s0)
7775500: system.cpu.fetch: [tid:0] Fetch queue entry created (1/32).

7776000: system.cpu.decode: Processing [tid:0]
7776000: system.cpu.decode: [tid:0] Not blocked, so attempting to run stage.
7776000: system.cpu.decode: [tid:0] Sending instruction to rename.
7776000: system.cpu.decode: [tid:0] Processing instruction [sn:10846] with PC (0x30102=&gt;0x30104).(0=&gt;1)

7776500: system.cpu.rename: [tid:0] Sending instructions to IEW.
7776500: system.cpu.rename: calcFreeLQEntries: free lqEntries: 27, loadsInProgress: 3, loads dispatchedToLQ: 3
7776500: system.cpu.rename: [tid:0] Processing instruction [sn:10846] with PC (0x30102=&gt;0x30104).(0=&gt;1).
7776500: system.cpu.rename: [tid:0] Looking up integer arch reg 8, got phys reg 12 (integer)
7776500: system.cpu.rename: [tid:0] Register 12 (flat: 12) (integer) is ready.
7776500: global: [sn:10846] has 1 ready out of 1 sources. RTI 0)
7776500: global: Renamed reg integer[15] to physical reg 255 (255) old mapping was 222 (222)
7776500: system.cpu.rename: [tid:0] Renaming arch reg 15 (integer) to physical reg 255 (255).
7776500: system.cpu.rename: [tid:0] Renaming arch reg 15 (integer) to physical reg 255 (255). flat dest 15
7776500: system.cpu.rename: [tid:0] [sn:10846] Adding instruction to history buffer (size=20).

7777000: system.cpu.iew: Activity this cycle.
7777000: system.cpu.commit: Getting instructions from Rename stage.
7777000: system.cpu.commit: [tid:0] [sn:10846] Inserting PC (0x30102=&gt;0x30104).(0=&gt;1) into ROB.
7777000: system.cpu.rob: Adding inst PC (0x30102=&gt;0x30104).(0=&gt;1) to the ROB.

7777500: system.cpu.iew: [tid:0] Not blocked, so attempting to run dispatch.
7777500: system.cpu.iew: [tid:0] Issue: Adding PC (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846] [tid:0] to IQ.
7777500: system.cpu.iew: [tid:0] Issue: Memory instruction encountered, adding to LSQ.
7777500: system.cpu.iew.lsq.thread0: Inserting load PC (0x30102=&gt;0x30104).(0=&gt;1), idx:1394 [sn:10846] # ldq.insertLoad()
7777500: system.cpu.iq: Adding instruction [sn:10846] PC (0x30102=&gt;0x30104).(0=&gt;1) to the IQ.
7777500: memdepentry: Memory dependency entry created. memdep_count=6 (0x30102=&gt;0x30104).(0=&gt;1) # memdequnit::insert()
7777500: global: Inst 0x30102 with index 64 had no SSID
7777500: system.cpu.memDep0: No dependency for inst PC (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846].
7777500: system.cpu.memDep0: Adding instruction [sn:10846] to the ready list.
7777500: system.cpu.iq: Instruction is ready to issue, putting it onto the ready list, PC (0x30102=&gt;0x30104).(0=&gt;1) opclass:52 [sn:10846]. ## InstructionQueue::addReadyMemInst()
7777500: system.cpu.iq: Thread 0: Issuing instruction PC (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846]# 调用的是scheduleReadyInst()选择需要被issue 的指令，下一周期指令会发射到执行单元 
7777500: system.cpu.memDep0: Issuing instruction PC 0x30102 [sn:10846]. # 这里也调用了memDep issue 主要是更新store-sets的 


7778000: system.cpu.iew: Execute: Processing PC (0x30102=&gt;0x30104).(0=&gt;1), [tid:0] [sn:10846].
7778000: system.cpu.iew: Execute: Calculating address for memory reference.
7778000: system.cpu.iew.lsq.thread0: Executing load PC (0x30102=&gt;0x30104).(0=&gt;1), [sn:10846] # ldq.executeLoad()
7778000: global: RegFile: Access to int register 12, has data 0xa0ad8
7778000: system.cpu.iew.lsq.thread0: Read called, load idx: 1394, store idx: 1942, storeHead: 1930 addr: 0x90ae8 ## 这里是lsq_unit.read(), 但是实际上经历了相当长的调用链
7778000: system.cpu.iew.lsq.thread0: Doing memory access for inst [sn:10846] PC (0x30102=&gt;0x30104).(0=&gt;1) ## lsq_unit.read()
7778000: system.cpu.iew.lsq.thread0: Memory request (pkt: ReadResp [90ae8:90aef]) from inst [sn:10846] was sent (cache is blocked: 0, cache_got_blocked: 0)
7778000: global: update entry for pc:(0x30102=&gt;0x30104).(0=&gt;1) new_addr : a0ae8
7778000: system.cpu.iew: Load: PC=(0x30102=&gt;0x30104).(0=&gt;1),&lt;extra arg&gt;%

7779000: system.cpu.iew: Sending instructions to commit, [sn:10846] PC (0x30102=&gt;0x30104).(0=&gt;1). # writebackinsts
7779000: system.cpu.iq: Waking dependents of completed instruction.
7779000: system.cpu.memDep0: Completed mem instruction PC (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846].
7779000: memdepentry: Memory dependency entry deleted. memdep_count=5 (0x30102=&gt;0x30104).(0=&gt;1)
7779000: system.cpu.iq: Completing mem instruction PC: (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846] # MemDepUnit::completed(）
7779000: system.cpu.iq: Waking any dependents on register 255 (integer).
7779000: system.cpu.iq: Waking up a dependent instruction, [sn:10848] PC (0x30106=&gt;0x30108).(0=&gt;1).
7779000: global: [sn:10848] has 1 ready out of 1 sources. RTI 0)

7779500: system.cpu.commit: [tid:0] Marking PC (0x30102=&gt;0x30104).(0=&gt;1), [sn:10846] ready within ROB. # commit::markCompletedInsts() , 这里已经做好了提交的准备，但是前面的指令还没有提交完全 


7781500: system.cpu.commit: Trying to commit head instruction, [tid:0] [sn:10846] ## 前面的指令提交完了，
7781500: system.cpu.commit: [tid:0] [sn:10846] Committing instruction with PC (0x30102=&gt;0x30104).(0=&gt;1)
7781500: system.cpu.rob: [tid:0] Retiring head instruction, instruction PC (0x30102=&gt;0x30104).(0=&gt;1), [sn:10846]
7781500: system.cpu: Removing committed instruction [tid:0] PC (0x30102=&gt;0x30104).(0=&gt;1) [sn:10846]
7781500: system.cpu: Removing instruction, [tid:0] [sn:10846] PC (0x30102=&gt;0x30104).(0=&gt;1)
</code></pre><p>load store 指令还是会被加入到iq</p><p>在dispatch 的时候也会调用ldstQueue.insertLoad(inst)去插入load</p><p>在iq.insert 里还会调用 memdequnit .insert 去生成mem 的entry</p><p>lsq_unit.read 是在调用 lsq_initiateAcc()的时候经过一层一层调用的 ， 是和inst 相关的</p><p><figure class=gallery-image style=flex-grow:374;flex-basis:898px><a href=/2025/gem5_o3_learning/image-20250426100747055.png data-size=760x203><img src=/2025/gem5_o3_learning/image-20250426100747055.png width=760 height=203 srcset="/2025/gem5_o3_learning/image-20250426100747055_hu10669214937265287552.png 480w, /2025/gem5_o3_learning/image-20250426100747055_hu16144696394555657848.png 1024w" loading=lazy></a></figure></p><h3 id=mem_dep_unit>mem_dep_unit</h3><p>（Memory Dependency Unit）是 gem5 O3 CPU 模型中的关键组件，负责预测和管理内存指令（加载和存储）之间的依赖关系。它的主要目的是确保在乱序执行环境中维护正确的内存访问顺序，同时最大限度地提高指令级并行性。</p><p>其核心功能包括：</p><ul><li>预测并跟踪内存指令间的依赖关系</li><li>管理内存屏障指令</li><li>处理内存依赖违规情况</li><li>决定内存指令何时可以安全地执行</li></ul><p>每次在dispatch 的时候都会生成一个mem_dep_entry ,</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>MemDepEntry</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>DynInstPtr</span> <span style=color:#e06c75>inst</span>;               <span style=color:#7f848e>// 被跟踪的指令
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>ListIt</span> <span style=color:#e06c75>listIt</span>;                 <span style=color:#7f848e>// 指令在列表中的位置迭代器
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>MemDepEntryPtr</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>dependInsts</span>;  <span style=color:#7f848e>// 依赖于此指令的其他指令列表
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>regsReady</span> <span style=color:#56b6c2>=</span> <span style=color:#e5c07b>false</span>;        <span style=color:#7f848e>// 寄存器是否就绪
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>int</span> <span style=color:#e06c75>memDeps</span> <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0</span>;               <span style=color:#7f848e>// 需要满足的内存依赖数量
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>completed</span> <span style=color:#56b6c2>=</span> <span style=color:#e5c07b>false</span>;        <span style=color:#7f848e>// 指令是否完成
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>bool</span> <span style=color:#e06c75>squashed</span> <span style=color:#56b6c2>=</span> <span style=color:#e5c07b>false</span>;         <span style=color:#7f848e>// 指令是否被挤出
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>};
</span></span></code></pre></div><p>使用store-sets 判断内存依赖 ， 如果没有内存依赖了 ， 调用InstructionQueue 加入到readyInsts队列里面 ，</p><p>判断内存依赖之前，实际上是检查过是否出现寄存器依赖的</p><h2 id=inst_queue>inst_queue</h2><h3 id=list_order>list_order</h3><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 是一个包含 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>ListOrderEntry</a> 对象的链表，每个 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>ListOrderEntry</a> 记录了一个操作类别队列的信息：</p><pre tabindex=0><code>struct ListOrderEntry {
    OpClass queueType;         // 队列类型（操作类别）
    InstSeqNum oldestInst;     // 该队列中最老指令的序列号
};
</code></pre><p>该列表按照指令的年龄（序列号）排序，包含了各种操作类型的就绪指令队列。它的主要作用有：</p><ol><li><strong>维护发射优先级</strong>：确保最老的指令最先发射，实现按程序顺序发射的策略</li><li><strong>操作类型选择</strong>：通过遍历 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a>，按顺序选择不同操作类型的指令进行发射</li><li><strong>发射带宽分配</strong>：在 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>totalWidth</a>（总发射带宽）范围内，尽可能多地发射指令</li></ol><p>所以说readyInsts[op_class]也是按照op_class 进行分类的</p><p>order_list 每一个op_class 条目只会存在一项 ，</p><p><strong>添加条目</strong>：当一个操作类型（OpClass）的就绪队列从空变为非空时，会向 <code>listOrder</code> 添加一个新条目</p><p>queueOnList 就是标记该op_class 对应的list是否已经在列表中了</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>        <span style=color:#c678dd>if</span> (<span style=color:#56b6c2>!</span><span style=color:#e06c75>queueOnList</span>[<span style=color:#e06c75>op_class</span>]) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>addToOrderList</span>(<span style=color:#e06c75>op_class</span>);
</span></span><span style=display:flex><span>        } <span style=color:#c678dd>else</span> <span style=color:#61afef;font-weight:700>if</span> (<span style=color:#e06c75>readyInsts</span>[<span style=color:#e06c75>op_class</span>].<span style=color:#e06c75>top</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>seqNum</span>  <span style=color:#56b6c2>&lt;</span>
</span></span><span style=display:flex><span>                   (<span style=color:#56b6c2>*</span><span style=color:#e06c75>readyIt</span>[<span style=color:#e06c75>op_class</span>]).<span style=color:#e06c75>oldestInst</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>listOrder</span>.<span style=color:#e06c75>erase</span>(<span style=color:#e06c75>readyIt</span>[<span style=color:#e06c75>op_class</span>]);
</span></span><span style=display:flex><span>            <span style=color:#e06c75>addToOrderList</span>(<span style=color:#e06c75>op_class</span>);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>删除条目</strong>：当一个操作类型的就绪队列变为空时，会从 <code>listOrder</code> 中移除其条目</p><pre tabindex=0><code>// 在 scheduleReadyInsts() 函数中
if (!readyInsts[op_class].empty()) {
    moveToYoungerInst(order_it);
} else {
    // 队列为空，从 listOrder 中移除
    readyIt[op_class] = listOrder.end();
    queueOnList[op_class] = false;
}

// 删除原条目
listOrder.erase(order_it++);
</code></pre><h4 id=schedulereadyinsts函数解析>scheduleReadyInsts()函数解析</h4><pre tabindex=0><code>首先处理被延迟或阻塞的内存指令
按照指令队列的顺序尝试发射指令
为每条指令分配适当的功能单元（Functional Unit）
根据指令特性安排立即执行或延迟执行
更新指令状态和相关统计信息
</code></pre><p>调度的时候获取的是readyInst指令的top</p><p>readyInst 是在一些地方调用了 AddIfReady 函数获取的</p><p>AddIfReady 有以下情景被调用</p><ol><li>在加入指令队列的时候，如果不是mem 指令 ，会调用 addIfReady (insert), 判断是否ready</li><li>当一条指令执行完成之后，标记自己的目标寄存器为可用 ， 并唤醒所有依赖该寄存器的指令 ， 这些指令如果所有源寄存器就绪就会添加到readyInsts队列中 ， （wakeupDependents)</li><li>内存指令在寄存器就绪后，还需要通过内存依赖单元 (MemDepUnit) 解决可能的内存依赖问题。当内存依赖解决后，会通过 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>addReadyMemInst</a> 函数将内存指令添加到 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>readyInsts</a> 队列</li></ol><p>在选择指令的时候，通过order_list 的op_class 去访问readyInst , 获取指令， 然后更新 order_list ,把最老的指令拉出来 ，然后就是获取功能单元 ， 具体会获取功能单元的idx 和 latency ,</p><p>对于单周期的指令 ， 可以加入到执行队列 ， 然后在下周期释放 fu ,</p><p>在下周期释放的方法比较简单 ， 就是这周期先加入到一个队列 ， 然后下周期通过processFreeUnit 读取队列的内容free fu , processFreeUnit是在 schedulereadyinst 之前就调用了 ， 所以完全可行 。</p><p>对于多周期的指令 ， 是创建了一个事件 ， 然后设置事件触发时间为 op_latency - 1 ，然后到了触发时间，才会把指令放到instsToExecute 队列 ， 所以它的延迟实际上不是执行的时候产生的，是schedule到inststoExecute 的时候产生的</p><p>issue 的指令会setIssue()</p><p>所以它的发射逻辑是尽可能发射多的指令，从readyInst里， 而且越老的指令越早发送</p><h3 id=movetoyoungerinst>moveToYoungerInst()</h3><p>当一个操作类型（OpClass）的就绪队列顶部指令变化时（如最老的指令被发射出去），该函数负责重新定位该操作类型在 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 列表中的位置，确保不同操作类型的就绪队列按照其顶部指令的序列号（程序顺序）排序。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#e5c07b>void</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>InstructionQueue</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>moveToYoungerInst</span>(<span style=color:#e06c75>ListOrderIt</span> <span style=color:#e06c75>list_order_it</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 获取下一个列表项的迭代器
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>ListOrderIt</span> <span style=color:#e06c75>next_it</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>list_order_it</span>;
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>++</span><span style=color:#e06c75>next_it</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 保存需要重新定位的队列类型
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>OpClass</span> <span style=color:#e06c75>op_class</span> <span style=color:#56b6c2>=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>list_order_it</span>).<span style=color:#e06c75>queueType</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 创建新的列表条目
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>ListOrderEntry</span> <span style=color:#e06c75>queue_entry</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>queue_entry</span>.<span style=color:#e06c75>queueType</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>op_class</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>queue_entry</span>.<span style=color:#e06c75>oldestInst</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>readyInsts</span>[<span style=color:#e06c75>op_class</span>].<span style=color:#e06c75>top</span>()<span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>seqNum</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 在列表中寻找正确的插入位置
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#7f848e>// 向后遍历，直到找到序列号大于当前队列顶部指令的位置
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#c678dd>while</span> (<span style=color:#e06c75>next_it</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>listOrder</span>.<span style=color:#e06c75>end</span>() <span style=color:#56b6c2>&amp;&amp;</span>
</span></span><span style=display:flex><span>           (<span style=color:#56b6c2>*</span><span style=color:#e06c75>next_it</span>).<span style=color:#e06c75>oldestInst</span> <span style=color:#56b6c2>&lt;</span> <span style=color:#e06c75>queue_entry</span>.<span style=color:#e06c75>oldestInst</span>) {
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>++</span><span style=color:#e06c75>next_it</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 在找到的位置插入新条目，并更新该操作类型的迭代器引用
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>readyIt</span>[<span style=color:#e06c75>op_class</span>] <span style=color:#56b6c2>=</span> <span style=color:#e06c75>listOrder</span>.<span style=color:#e06c75>insert</span>(<span style=color:#e06c75>next_it</span>, <span style=color:#e06c75>queue_entry</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假设我们有以下状态：</p><ol><li>整数操作队列：序列号为 [100, 110, 120]（最老指令序列号是100）</li><li>浮点操作队列：序列号为 [105, 115, 125]（最老指令序列号是105）</li><li>当前的发射顺序列表 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a>：[整数队列, 浮点队列]（因为100 &lt; 105）</li></ol><p>现在，如果整数队列的最老指令（序列号100）被发射出去，则整数队列变为 [110, 120]，<strong>最老的指令变成了序列号110</strong>。这时需要调用 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>moveToYoungerInst</a> 重新调整整数队列在 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 中的位置。</p><p>由于110 > 105，调整后的 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 应该变成 [浮点队列, 整数队列]。</p><h3 id=readyit>readyIt</h3><ol><li><strong>快速访问</strong>：提供对每个操作类型在 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 中位置的直接访问，无需遍历整个 <a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>listOrder</a> 列表</li><li><strong>位置追踪</strong>：当操作类型的就绪队列状态变化时，快速找到并修改它在发射顺序中的位置</li><li><strong>优化性能</strong>：避免在更新发射顺序时进行重复查找，提高调度效率</li></ol><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span> <span style=color:#e06c75>readyIt</span>[<span style=color:#e06c75>op_class</span>] <span style=color:#56b6c2>=</span> <span style=color:#e06c75>listOrder</span>.<span style=color:#e06c75>insert</span>(<span style=color:#e06c75>next_it</span>, <span style=color:#e06c75>queue_entry</span>);
</span></span></code></pre></div><p>所以使用readyIt[op_class]应该可以直接访问到插入的那个表项的指针 ，访问就会比较方便，不需要通过链表遍历来实现 ，erase 的时候也会比较方便 。</p><p><figure class=gallery-image style=flex-grow:221;flex-basis:530px><a href=/2025/gem5_o3_learning/image-20250423152137923.png data-size=473x214><img src=/2025/gem5_o3_learning/image-20250423152137923.png width=473 height=214 srcset="/2025/gem5_o3_learning/image-20250423152137923_hu16149300792399966226.png 480w, /2025/gem5_o3_learning/image-20250423152137923_hu8174389800356719600.png 1024w" loading=lazy></a></figure></p><h3 id=instlist>instList</h3><p>instList 的主要功能是存储和跟踪所有在指令队列中的指令</p><p>当指令从重命名阶段进入到指令队列的时候，他们被加入到对应线程的instList中</p><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>instList</a>维护了指令按程序顺序(序列号)的列表，这对于实现精确异常和正确的指令提交非常重要（commit 是根据fromCommit->commitInfo 的信号在iew作commit 的 ）</p><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>instList</a>在处理分支预测错误等需要刷新指令流水线的情况时扮演关键角色，doSquash 时是依赖instList 的</p><h2 id=fu_pool>fu_pool</h2><h3 id=getunit>getUnit</h3><ul><li>首先检查池中是否有能执行该操作的功能单元</li><li>然后在具有该能力的功能单元中轮询查找空闲单元</li><li>如果找到，将其标记为繁忙并返回索引</li><li>返回值：<ul><li>功能单元索引（≥0）：成功分配功能单元</li><li><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>NoCapableFU</a> (-2)：池中没有能执行该操作类型的功能单元</li><li><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>NoFreeFU</a> (-1)：有能力但当前都在使用中</li></ul></li></ul><p>是否有执行该功能是经过配置的 ， 可以通过python 来进行相应的配置</p><h3 id=fupercaplist>fuPerCapList</h3><p>FuPerCapList是一个向量 ， 可以通过op_class 进行索引 ，</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>FUIdxQueue</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#c678dd>private</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>int</span> <span style=color:#e06c75>idx</span>;                      <span style=color:#7f848e>// 当前索引位置
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e5c07b>int</span> <span style=color:#e06c75>size</span>;                     <span style=color:#7f848e>// 队列大小
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e5c07b>int</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>funcUnitsIdx</span>; <span style=color:#7f848e>// 功能单元索引向量
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    
</span></span><span style=display:flex><span>  <span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ...方法定义...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>};
</span></span></code></pre></div><p>funcUnitsIdx 有多大就代表有多少个执行单元 ， funcUnitsIdx [i] 是递增的，但是有一下对应的是同一个序号 ，</p><p>不同的序号代表不同的执行单元，所以funcUnitsIdx 的大小总数 是 > 执行单元的数量的</p><p>比方说 IntMult 和 IntDiv 是不同的op_class , 但是实际上是用的同一个执行单元</p><p><figure class=gallery-image style=flex-grow:32;flex-basis:76px><a href=/2025/gem5_o3_learning/image-20250423161351759.png data-size=214x668><img src=/2025/gem5_o3_learning/image-20250423161351759.png width=214 height=668 srcset="/2025/gem5_o3_learning/image-20250423161351759_hu13371034812060869134.png 480w, /2025/gem5_o3_learning/image-20250423161351759_hu4606734674716903772.png 1024w" loading=lazy></a></figure></p><div class=table-wrapper><table><thead><tr><th style=text-align:left>功能单元类型</th><th style=text-align:left>操作类型</th><th style=text-align:left>延迟(周期)</th><th style=text-align:left>是否流水线</th><th style=text-align:left>单元数量</th></tr></thead><tbody><tr><td style=text-align:left><strong>IntALU</strong></td><td style=text-align:left>IntAlu</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>6</td></tr><tr><td style=text-align:left><strong>IntMultDiv</strong></td><td style=text-align:left>IntMult</td><td style=text-align:left>3</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left></td><td style=text-align:left>IntDiv</td><td style=text-align:left>20</td><td style=text-align:left>否</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>FP_ALU</strong></td><td style=text-align:left>FloatAdd</td><td style=text-align:left>2</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatCmp</td><td style=text-align:left>2</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatCvt</td><td style=text-align:left>2</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>FP_MultDiv</strong></td><td style=text-align:left>FloatMult</td><td style=text-align:left>4</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatMultAcc</td><td style=text-align:left>5</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatMisc</td><td style=text-align:left>3</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatDiv</td><td style=text-align:left>12</td><td style=text-align:left>否</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatSqrt</td><td style=text-align:left>24</td><td style=text-align:left>否</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>SIMD_Unit</strong></td><td style=text-align:left>SimdAdd</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdAddAcc</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdAlu</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdCmp</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdCvt</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdMisc</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdMult</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>其他SIMD操作&mldr;</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>Matrix_Unit</strong></td><td style=text-align:left>Matrix</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left></td><td style=text-align:left>MatrixMov</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>MatrixOP</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>PredALU</strong></td><td style=text-align:left>SimdPredAlu</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left><strong>ReadPort</strong></td><td style=text-align:left>MemRead</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>0</td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatMemRead</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdUnitStrideLoad</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>其他读操作&mldr;</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>WritePort</strong></td><td style=text-align:left>MemWrite</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>0</td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatMemWrite</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>SimdUnitStrideStore</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>其他写操作&mldr;</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>RdWrPort</strong></td><td style=text-align:left>MemRead/Write</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left></td><td style=text-align:left>FloatMemRead/Write</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>所有SIMD读写操作</td><td style=text-align:left>1 (默认)</td><td style=text-align:left>是 (默认)</td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>IprPort</strong></td><td style=text-align:left>IprAccess</td><td style=text-align:left>3</td><td style=text-align:left>否</td><td style=text-align:left>1</td></tr></tbody></table></div><h2 id=lsq>LSQ</h2><h3 id=lsqcheckviolations>LSQ::checkViolations</h3><p>检查内存依赖冲突，检查地址范围重叠， 对于加载，标记可能的依赖违反 ， 对于存储，标记是否有加载指令错误的先于它执行</p><h2 id=o3-指令的squash>o3 指令的squash</h2><h3 id=squash-调用>squash 调用</h3><h4 id=从commit-阶段出发的squash>从commit 阶段出发的squash</h4><ol><li><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>Commit::squashAll(ThreadID tid)</a> - 在提交阶段触发的全面squash</p></li><li><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>IEW::checkSignalsAndUpdate(ThreadID tid)</a> - 接收并处理来自Commit的squash信号</p></li><li><p><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>IEW::squash(ThreadID tid)</a> - 在执行阶段处理squash</p></li></ol><h4 id=从分支预测错误触发的squash>从分支预测错误触发的squash</h4><ol><li><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>IEW::squashDueToBranch(const DynInstPtr& inst, ThreadID tid)</a> - 分支预测错误触发squash</li><li><code>BPredUnit::squash(const InstSeqNum &amp;squashed_sn, ...)</code> - 分支预测器处理squash</li></ol><h4 id=从内存顺序错误触发的squash>从内存顺序错误触发的squash</h4><ol><li><a class=link href=vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html>IEW::squashDueToMemOrder(const DynInstPtr& inst, ThreadID tid)</a> - 内存顺序违反触发squash</li></ol><h4 id=fetch-阶段的squash>fetch 阶段的squash</h4><p>从提交阶段发来的squash信号，通常由分支预测错误或内存依赖违反触发。
从解码阶段发来的squash信号，例如由译码阶段检测到的指令格式错误触发。</p><p>这是实际执行squash操作的核心函数，doSquash</p><ol><li>更新PC</li><li>重置解码器</li><li>清除未完成的缓存访问</li><li>清空fetch队列(fetch队列会传输到toDecode队列，然后传递给decode)</li><li>更新统计计数器</li></ol><p>在checkSignalsAndUpdate的时候会去调用squash , 如果 fromCommit->commitInfo.squash(这是其中一种情况)，deocde, iew (还有一种是robSquashing), rename 只有这一种情况(都是从commit 那边传递过来的squash 信号) ， fetch 有commit , decode 导致的squash</p><p>对于iew 导致的squash , 会调用instQueue.squash 和 ldstQueue.squash , 然后还是要清空RenameInst 队列中的数据（就是从rename传递过来的)，</p><h2 id=指令的seqnum>指令的seqNum</h2><p>序列号的实际递增和分配发生在CPU的Fetch阶段</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#7f848e>// src/cpu/o3/fetch_impl.hh
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Impl</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#e5c07b>void</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>DefaultFetch</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>Impl</span><span style=color:#56b6c2>&gt;::</span><span style=color:#e06c75>fetch</span>(<span style=color:#e06c75>ThreadID</span> <span style=color:#e06c75>tid</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#c678dd>while</span> (...) {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 获取新的序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>InstSeqNum</span> <span style=color:#e06c75>seq</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>cpu</span><span style=color:#56b6c2>-&gt;</span><span style=color:#e06c75>getAndIncrementInstSeq</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 创建新的动态指令并分配序列号
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>DynInstPtr</span> <span style=color:#e06c75>instruction</span> <span style=color:#56b6c2>=</span> <span style=color:#c678dd>new</span> <span style=color:#e06c75>DynInst</span>(
</span></span><span style=display:flex><span>            <span style=color:#e06c75>staticInst</span>, <span style=color:#e06c75>curMacroop</span>, <span style=color:#e06c75>pc</span>, <span style=color:#e06c75>nextPC</span>, <span style=color:#e06c75>seq</span>, <span style=color:#e06c75>cpu</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>}
</span></span></code></pre></div><p>序列号在CPU的多个组件中用于：</p><ol><li><strong>确定程序顺序</strong>：尽管指令可能乱序执行，但通过序列号可以确定原始程序顺序</li><li><strong>识别依赖关系</strong>：较早的指令(较小的序列号)可能被较晚的指令(较大的序列号)依赖</li><li><strong>分支预测恢复</strong>：在分支预测错误时，可以确定哪些指令需要被丢弃(序列号大于错误分支的指令)</li><li><strong>精确异常处理</strong>：确保只有序列号小于或等于引发异常指令的指令被提交</li></ol><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><p><a class=link href=https://www.icfgblog.com/index.php/riscv/351.html target=_blank rel=noopener>https://www.icfgblog.com/index.php/riscv/351.html</a></p><p><a class=link href=https://jianyue.tech/posts/gem5/ target=_blank rel=noopener>https://jianyue.tech/posts/gem5/</a></p><p><a class=link href=https://blog.csdn.net/ivy_reny/article/details/54289190 target=_blank rel=noopener>https://blog.csdn.net/ivy_reny/article/details/54289190</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/702348447 target=_blank rel=noopener>gem5 c++/python co-binding</a></p><p><a class=link href=https://deep-learning.feishu.cn/wiki/YAmkwBlzkiTGlnkQQXMctS1bnse target=_blank rel=noopener>https://deep-learning.feishu.cn/wiki/YAmkwBlzkiTGlnkQQXMctS1bnse</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/495960488 target=_blank rel=noopener>gem5指令定义实现剖析</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/350219725 target=_blank rel=noopener>gem5如何处理不定长指令</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/649049616 target=_blank rel=noopener>gem5 源码阅读timebuff</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/587079919 target=_blank rel=noopener>gem5 event</a></p><p>649f680 10d60 access to int register 22 has data 0x7fffffffffd60</p><p>4294</p><p>中间要是有s</p></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2024/gem5_learning/><div class=article-details><h2 class=article-title>Gem5_learning</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了394.9k字·共 103篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#gem5-的启动流程>gem5 的启动流程</a></li><li><a href=#仿真前的初始化>仿真前的初始化</a></li><li><a href=#计算指令>计算指令</a></li><li><a href=#访存指令>访存指令</a><ol><li><a href=#load-指令>load 指令</a></li><li><a href=#store-指令>store 指令</a></li><li><a href=#memory-order-fail>memory order fail</a></li></ol></li><li><a href=#staticinst>staticinst</a></li><li><a href=#dyninsts>DynInsts</a></li><li><a href=#rename>rename</a><ol><li><ol><li><a href=#正常重命名><strong>正常重命名</strong></a></li><li><a href=#钉住寄存器重命名><strong>钉住寄存器重命名</strong></a></li></ol></li></ol></li><li><a href=#gem5-timebuff>gem5 timebuff</a><ol><li><a href=#wire>wire</a></li><li><a href=#advance>advance()</a></li><li><a href=#wire-getwireint-idx>wire getWire(int idx)</a></li><li><a href=#t-accessint-idx>T *access(int idx)</a></li><li><a href=#timebuff-延迟模型>TimeBuff 延迟模型</a></li></ol></li><li><a href=#gem5-event>gem5 event</a><ol><li><a href=#role>role</a></li><li><a href=#event-queue>Event Queue</a></li></ol></li><li><a href=#o3-流水线的详细分析>o3 流水线的详细分析</a><ol><li><a href=#以某一条指令为例子>以某一条指令为例子</a></li><li><a href=#iew>iew</a></li><li><a href=#commit>commit</a></li></ol></li><li><a href=#gem5-流水线的状态控制>gem5 流水线的状态控制</a><ol><li><a href=#一条load-指令的所有-log>一条load 指令的所有 log</a></li><li><a href=#mem_dep_unit>mem_dep_unit</a></li></ol></li><li><a href=#inst_queue>inst_queue</a><ol><li><a href=#list_order>list_order</a><ol><li><a href=#schedulereadyinsts函数解析>scheduleReadyInsts()函数解析</a></li></ol></li><li><a href=#movetoyoungerinst>moveToYoungerInst()</a></li><li><a href=#readyit>readyIt</a></li><li><a href=#instlist>instList</a></li></ol></li><li><a href=#fu_pool>fu_pool</a><ol><li><a href=#getunit>getUnit</a></li><li><a href=#fupercaplist>fuPerCapList</a></li></ol></li><li><a href=#lsq>LSQ</a><ol><li><a href=#lsqcheckviolations>LSQ::checkViolations</a></li></ol></li><li><a href=#o3-指令的squash>o3 指令的squash</a><ol><li><a href=#squash-调用>squash 调用</a><ol><li><a href=#从commit-阶段出发的squash>从commit 阶段出发的squash</a></li><li><a href=#从分支预测错误触发的squash>从分支预测错误触发的squash</a></li><li><a href=#从内存顺序错误触发的squash>从内存顺序错误触发的squash</a></li><li><a href=#fetch-阶段的squash>fetch 阶段的squash</a></li></ol></li></ol></li><li><a href=#指令的seqnum>指令的seqNum</a></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom/ class=category-list-link>boom<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/c++/ class=category-list-link>c++<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gpgpu%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ class=category-list-link>gpgpu读书笔记<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/prefetch/ class=category-list-link>prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=category-list-link>分支预测<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/ class=category-list-link>基础概念<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class=category-list-link>操作系统<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83/ class=category-list-link>环境<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>5</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>17</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BF%E5%AD%98/ class=category-list-link>访存<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1/ class=category-list-link>香山<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>3</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>55</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/prefetch/ class=font_size_4>Prefetch
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>