<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测 abstract 数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。
'><title>ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers</title>
<link rel=canonical href=https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers'><meta property='og:description' content='ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测 abstract 数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。
'><meta property='og:url' content='https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='安全处理器'><meta property='article:published_time' content='2024-12-07T20:28:43+08:00'><meta property='article:modified_time' content='2024-12-07T20:28:43+08:00'><meta name=twitter:title content="ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers"><meta name=twitter:description content="ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测 abstract 数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></header><h2 class=article-title><a href=/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/>ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 07, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>14836字</time></div></footer></div></header><section class=article-content><h1 id=paraverser利用异构并行性实现数据中心中经济实惠的故障检测>ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测</h1><h2 id=abstract>abstract</h2><p>数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。</p><h2 id=简介>简介</h2><p>随着数据中心规模的扩大，静默数据损坏的威胁已日益频繁，无法再被忽视。Meta [41] 和 Google [52] 警告称，随着晶体管的尺寸缩小和分布式计算规模扩大，尽管已有可靠性、可用性和可维护性（RAS）机制 [13], [30], [67]，但CPU仍然持续无提示地产生错误结果，既无崩溃也无外部错误迹象。为应对这一问题，解决方案已经分化为两极：一端是软件诊断技术 [40]，另一端是全硬件锁步机制 [17]。</p><p>在数据中心，软件扫描器 [16], [40], [82] 已广泛用于测试生产系统中的永久性故障。尽管这些工具部署简单，但需要长时间暂停对资源的访问，或只能检测少量故障。因此，清除生产中的故障硬件可能需要长达六个月 [40]。相比之下，汽车系统长期采用双核和三核锁步机制 [17], [57]，通过核心完全同步来比较输出，以实现全面的硬件错误检测。然而，这种方法会导致在相同面积和功耗预算下计算性能减半，对于数据中心而言并不现实。</p><p>尽管如此，仍然存在可行的替代方案。例如，为容错目的重复运行计算，其并行度通常高于原始运行 [2]–[4]。可以根据初始运行中的数据依赖性，将程序划分为多个段，然后通过归纳法重建完整的容错计算轨迹。这些段可以在缓慢、高效的并行硬件上运行 [2]。</p><p>此外，服务器环境中的核心大小异构性已经开始出现 [72], [81]。然而，现有的错误检测系统通常采用最慢的核心 [4]，这意味着每个运行计算的主核心需要多达16个检查核心。虽然这在效率上可行，但如果服务器运行对容错需求较低的工作负载，微型检查核心将无法运行实际应用。而实际的异构系统中的“较小”核心通常是更大的超标量核心 [81]。</p><p>我们证明，通<strong>过调整可靠性和性能功能，可以在微架构级别实现服务器级SoC中的错误检测</strong>，在必要时几乎不影响性能，并通过异构并行性将开销降至最低。我们提出 <strong>ParaVerser</strong>，一种硬件机制，用于机会性并行错误检测，利用备用CPU资源（异构或同构）高效地重复计算，所需的核心修改最小化。</p><p><strong>我们的贡献如下：</strong></p><ol><li><strong>新型微架构设计</strong>：用于检测硬件中的永久性和瞬时性故障，复用常规服务器级芯片中的核心。我们的设计引入了归纳并行性机制 [2]，将运行分段，并在多个较慢的并行核心上重放和检查执行的代码。异构SoC中的每个核心均可用于运行工作负载或冗余验证。</li><li>两种运行模式<ul><li><strong>全覆盖模式</strong>：能够捕获所有永久性和瞬时性错误；</li><li><strong>机会性模式</strong>：只在资源空闲时检查尽可能多的计算，提供部分覆盖。</li></ul></li><li>设计优化<ul><li>设计混合的加载-存储日志和数据缓存以降低SRAM开销；</li><li>实现加载-存储推送单元，直接将数据推送至检查核心，消除主核心缓冲造成的本地缓存压力和一致性开销；</li><li>启用推测性的乱序检查；</li><li>通过新的哈希机制最小化跨芯片网络流量。</li></ul></li><li><strong>性能评估</strong>：ParaVerser在全覆盖模式下的性能开销根据检查核心的类型、数量和频率不同，几何均值范围为1%至4%。在这些极端之间，能耗开销从95%减少到仅29%。机会性模式仅引入1%的开销，资源分配不同可覆盖94%至99%的执行指令。</li><li><strong>比较分析</strong>：与现有研究 [2], [4] 相比，ParaVerser提供更合理和详细的核心模型。我们证明12个专用检查核心 [2] 无法满足需求（9%开销），而16个专用检查核心 [4] 在低延迟下达成35%的面积开销。</li></ol><p><strong>ParaVerser</strong> 能以最小的性能和面积影响，在微架构级别实现对硬件中永久性和瞬时性故障的全面检测，其能耗仅为同构锁步方案的三分之一。该设计还支持硬件预测性维护 [88]，通过识别可能因老化 [62] 而变得易出错的CPU，提前预防故障。其灵活性还允许在系统负载较高时自动停用错误检测机制。ParaVerser 是数据中心在追求高质量服务的同时，实现可靠故障检测能力的理想解决方案。</p><h3 id=ii-动机><strong>II. 动机</strong></h3><h4 id=a-数据中心规模的错误><strong>A. 数据中心规模的错误</strong></h4><p>在大规模数据中心中，<strong>硅级故障</strong>日益普遍，通常表现为<strong>静默数据损坏（SDC）</strong>，且不会触发系统崩溃或警告。Meta [41] 和 Google [52] 的报告表明，这些错误经常绕过内置的**可靠性、可用性和可维护性（RAS）**功能。</p><h5 id=现有解决方案及其局限性><strong>现有解决方案及其局限性</strong></h5><ol><li>软件扫描工具<ul><li><strong>FleetScanner</strong>：执行离线测试，将服务器置于维护模式。尽管它在六个月内实现了 93% 的故障覆盖率，但这导致了长时间的漏洞窗口，在此期间错误可能影响实际运行的工作负载。</li><li><strong>Ripple</strong>：在生产环境中进行测试，可以在实际工作负载同时运行，但覆盖率显著较低，仅能捕捉一小部分错误。</li><li><strong>不足</strong>：这些工具通常运行模拟代码以代替实际工作负载，但错误往往依赖于具体数据输入 [41]，且受温度/电压变化的影响 [27]，因此覆盖率不可避免地不完整。</li></ul></li></ol><h4 id=b-异构并行错误检测><strong>B. 异构并行错误检测</strong></h4><p>为了实现可接受的功耗开销，可以使用类似 <strong>ParaMedic</strong> 的方法 [2], [3]，通过<strong>异构并行错误检测</strong>来提高效率。</p><h5 id=关键思想><strong>关键思想</strong></h5><p>如果记录 CPU 的所有存储操作及其观察到的所有加载值，则可以将工作负载分解为多个独立的“检查点”，并通过重叠运行这些片段来验证错误（详见图 1）。每个检查点的执行依赖于前一个检查点的寄存器文件及加载/存储日志。通过归纳式方法，可以验证以下条件：</p><ol><li>所有加载/存储操作正确；</li><li>存储值与原始运行一致；</li><li>每个片段的终态寄存器文件与下一片段的初态寄存器文件一致。</li></ol><h5 id=限制与改进><strong>限制与改进</strong></h5><p>以往研究 [2]-[4] 提出的方案围绕主核部署了大量微控制器级小核进行检测，这些小核虽高效，但不适合系统在非容错需求场景下的使用。解决方法是复用系统中的现有核，通过<strong>异构并行</strong>处理实现能效优化。例如，利用 <strong>Arm big.LITTLE</strong> [28], [81]、AMD Zen4/Zen4c [55], [72] 或 Intel P-/E-核 [56] 的现有架构。</p><h4 id=c-机会性并行错误检测><strong>C. 机会性并行错误检测</strong></h4><p>目标是比软件扫描工具更快速、更高效地检测服务器中的不可靠计算。具体方法：</p><ul><li><strong>动态调整检测覆盖率</strong>：当闲置资源不足时，通过降低覆盖率以维持性能；在系统负载较轻时，利用多余资源实现全面覆盖。</li><li><strong>无需完全锁步</strong>：与基于采样的锁步方法 [69] 类似，但不需要完全相同的硬件或周期同步，降低实现复杂性。</li><li><strong>硬错误优先检测</strong>：专注于检测硬错误和半硬错误（服务器系统的主要问题 [41]），而非瞬态错误（如宇宙射线引发的位翻转）。</li></ul><h4 id=d-检测核的设计考量><strong>D. 检测核的设计考量</strong></h4><h2 id=paraverser>PARAVERSER</h2><p>如果我们正在重复利用备用的服务器核心，而这些核心有时更适合用于调度用户代码，而非用于小型、低性能的专用容错引擎[4]，则校验核心不可避免地不会像先前关于高效错误检测的研究[2]中那样小或高度并行化——在这些研究中，1216个微型校验核心被部署在每个主核心旁边。在我们的研究中，我们主要关注异构的big.LITTLE风格[28]微架构，因为（i）这使得在小核心上实现能量高效的错误检测成为可能，并且（ii）未来的数据中心SoC预计将包含异构核心[72]、[81]、[87]，尽管我们在第VI节中展示了ParaVerser也可以高效地在同构核心上实现。如果每个校验核心具有更高的吞吐量，我们需要的核心数量将会减少，即使每个核心在功耗和面积上更大。由于我们扩展的硬件功能并非始终被使用，因此其面积影响必须最小化，并尽可能重复利用现有硬件：例如，重新利用现有的SRAM缓存存储器而非专用存储器[2]来进行容错日志记录，重新利用现有的片上网络（NoC）布局而非专用布线[2]来转发中间结果。</p><p>如果我们在为转发中间结果使用现有的NoC（片上网络）布局[2]，则第三部分介绍了ParaVerser的设计。图2展示了ParaVerser对次级核心的轻微修改。这些修改允许任意核心作为主核心1或校验核心运行，目的是使校验核心更加数量庞大、并行且能效更高。对于缓存和主存储器的错误，我们假设使用了ECC（纠错码）[13]或奇偶校验。</p><ul><li>我们描述了在全覆盖模式和机会模式之间如何不同地管理和分配校验资源（详见第III-A节）。前者在校验核心集体较慢时暂停主计算，让其赶上进度，而后者则跳过多余指令的校验。</li><li>我们增强了每个L1数据缓存，以允许校验核心存储记录的内存访问和寄存器检查点，从而能够并行重放计算片段（详见第III-B节）。</li><li>我们新增了一个单元，可以通过现有的NoC将记录的加载、存储以及其他不可重复事件直接推送到任意校验核心的日志中，从而避免共享存储和一致性开销（详见第III-C节）。</li><li>我们新增了一个寄存器检查点单元（详见第III-D节），用于在主核心生成起始和结束寄存器检查点，并在校验核心上存储并比较结束寄存器检查点。同时还新增了一个加载-存储比较器（详见第III-E节），比较内存地址和存储数据与加载-存储日志缓存中的记录版本。</li><li>最后，我们新增了一个计数器单元（详见第III-F节），用于在相同的指令计数下中断主核心和校验核心，以支持重放操作。片段通过寄存器检查点单元生成的检查点进行分割。我们还设计了新的机制，以处理可能为乱序和/或超标量的校验核心，这些核心的微架构可能与主核心完全不同（详见第III-G节）。这需要在支持主核心执行的推测和重新排序的同时，仍然观察到原始运行的正确且等效的加载和存储行为日志。</li></ul><p>我们通过允许校验核心在主核心完成相关检查点之前启动执行（详见第III-H节）来提高设计效率，同时提出了对加载和存储行为的约束，以避免两者之间可能产生的不一致。此外，我们提出了一种减少跨核心数据传输的方法，以避免在资源不足的NoC上导致减速（详见第III-I节）。最后，我们解释了如何处理多进程和多核工作负载行为（详见第III-J节）。</p><p><figure class=gallery-image style=flex-grow:221;flex-basis:532px><a href=/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/image-20241208104051744.png data-size=1538x693><img src=/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/image-20241208104051744.png width=1538 height=693 srcset="/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/image-20241208104051744_hu1962981438195543932.png 480w, /2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/image-20241208104051744_hu15157017937507976736.png 1024w" loading=lazy></a></figure></p><h3 id=a-basic-operation>A. Basic Operation</h3><p>对于给定的主核心，将选择一个空闲的校验核心。寄存器文件的副本会被获取（详见第III-D节）并推送到校验核心，后者从同一点开始执行。加载和存储由主核心记录并发送到校验核心以重放内存访问。当加载-存储日志缓存（详见第III-B节）已满、超时或接收到中断时，会获取一个结束检查点并发送到校验核心以供后续验证。由于主核心故意具有比校验核心更高的单线程吞吐量，因此前一个检查点的完整验证会在主核心创建后的一段时间才完成。为了避免阻塞，它通过为下一个时间间隔选择新的校验核心来并行化错误检测过程，而之前的检查点仍在被验证中。</p><p>在全覆盖模式中，如果所有可能的目标都忙于错误检测（例如，由于可用的校验核心无法集体跟上主核心）或被调度运行其他程序，主核心将暂停执行。一旦有可用资源，一个新的起始检查点会被发送到新的校验核心，计算继续进行。在机会模式中，如果没有剩余的校验资源，寄存器检查点和日志记录会被短暂关闭。之前的片段会继续被检查，但当前检查点不会被转发，主核心继续执行以避免性能下降。一旦之前的检查点被检查并释放了校验核心，主核心会立即获取一个新的检查点，从该点重新开始检查。</p><p>我们让操作系统根据当前负载决定分配哪些CPU作为校验核心，哪些作为主核心2。优先分配空闲核心以及较低性能的核心作为校验核心，因为校验不需要高单线程性能。如果操作系统决定当前校验核心数量超过所需或需要更多主核心计算，核心可以在每个检查点结束时从校验核心切换回主核心3。</p><h3 id=b-load-store-log-cache>B. Load-Store Log Cache</h3><p>先前的技术（例如，Ainsworth和Jones[2]）使用了专用的SRAM加载-存储日志，但引入了内存存储开销。相比之下，我们轻微修改并重新利用通用核心上已经可用的数据缓存，用于存储数据以重新生成计算并验证正确性（除了在第III-I节的Hash模式下，当验证元数据未存储在缓存中时）。我们称这种新结构为加载-存储日志缓存（LSL$）。</p><p>LSL$中存储的用于计算重放的数据包括加载的数据和其他不可重复指令的值，例如条件存储、计时器、系统寄存器的读写以及随机数生成器。这使得无论中间存在任何多核通信，都可以精确重放。用于验证正确性的存储数据包括加载/存储地址、大小和存储数据。</p><p>一个典型的LSL$条目由一个7字节的地址、一个1字节的大小以及一个为数据对齐到最近的8字节的可变长度负载组成（例如在Arm架构中，如果加载和存储同时需要，则数据先加载后存储）。这些条目首先在提交时按顺序由主核心的LSPU（详见第III-C节）填充，并在校验核心上被解释为相同的序列。然后，条目的缓存行（每行512位缓存存储4个条目，每个条目通常为64位结果）通过NoC推送到LSL$。</p><p>如图3所示，LSL$的结构中每个缓存行的标签增加了一个额外的位，用于指示存储的数据是日志（L）还是主存数据的缓存副本（C）。当核心开始被用作校验时，其缓存被重新用作线性日志，而不是地址的内容可寻址存储器。我们从校验核心缓存的第一个索引和集合开始填充，并逐出当前位置的缓存行（如果有效且尚未是日志条目）。存储在新加载-存储日志结束寄存器中的一个字指示当前结束元素所在的行。</p><h3 id=c-加载-存储推送单元>C. 加载-存储推送单元</h3><p>我们为核心新增了一个加载-存储推送单元（LSPU），以便通过通用NoC在主核心和校验核心之间传送加载-存储日志（LSL）条目。与之前的异构错误检测技术[2]–[4]不同，ParaVerser需要核心之间的全互联通信（任何核心可以检查其他核心）。这种跨核心通信的开销通过在每个主核心的LSPU中本地缓冲一个缓存行的LSL条目得以缓解。此外，由于LSL$条目被视为临时存储，而不是一致性流量，它们可以直接发送，而无需经过目录或最后一级缓存（LLC）。除非条目本身大于一个缓存行，否则无法容纳在当前缓存行剩余空间的条目会被放入下一个缓存行。</p><p>为了允许大核心和小核心的微架构有所不同，LSL$以ISA格式存储数据。这需要在流水线提交时将多个微操作的数据融合在一起。对于提交时的每个加载/存储微操作，当访问来自相同指令时，主核心继续在LSPU中更新相同的LSL条目。合并的条目涵盖了从单一基址开始的所有加载数据，随后是基址的任何存储数据。在访问LSL$时，访问地址和大小会与LSL$条目中的地址和大小范围进行比较，并使用地址作为偏移量进入LSL$条目的数据段以检索或检查相应数据。要推送到日志的数据（详见第III-B节）在提交时从核心的加载-存储队列（LSQ）访问。</p><p>为了避免限制覆盖范围，我们对LSQ进行了轻微修改：任何到达内存的存储中的错误也必须到达校验核心。相反，任何加载值中的错误不得到达校验核心，从而确保至少有一个核心接收到正确的值。对于加载操作，来自缓存的ECC或奇偶校验位（无论系统中使用哪种方式）会被转发到加载队列，并在转发到LSPU之前进行检查。对于存储操作，在存储传播到本地缓存和LSL$之前，会生成ECC或奇偶校验位。主核心和校验核心之间以及寄存器文件中的错误不会传播，因为这些组件中的错误仅限于主核心或校验核心。</p><p>LSPU的大小与缓存行、NoC宽度或目标ISA单条指令可能生成的最大LSL$条目相同（以较大者为准），并在其满时或获取结束检查点时推送到NoC（从而切换校验核心）。虽然在LSPU中的中间状态可能违反ISA兼容性，但推送到NoC的所有数据均遵守ISA兼容性。</p><h3 id=d-register-checkpointing-unit>D. Register Checkpointing Unit</h3><p>寄存器检查点单元（RCU）用于在主核心上获取起始和结束寄存器检查点，并在校验核心上存储结束寄存器检查点。在检查点的开始，RCU会复制架构寄存器文件，通过NoC转发到选定的校验核心，该核心更新其寄存器文件并开始校验。在检查点结束时，主核心的RCU将新的架构寄存器文件副本转发到选定的校验核心的RCU，并更新新分配的校验核心（如果有）。最后，一旦校验核心被指令计数器中断，架构寄存器文件将与RCU副本进行比较。</p><p>虽然系统可见状态通过LSL中的加载和存储或Hash模式中的哈希值（详见第III-I节）进行检查，但还需要在每个检查点的开始和结束进行寄存器文件检查，以通过归纳法[2]验证完整的程序序列的正确性。</p><h3 id=e-load-store-comparator>E. Load-Store Comparator</h3><p>负载存储比较器（LSC）将检查器核心生成的地址和大小与记录中存储的每个负载和存储的地址和大小进行比较。对于存储，它还将记录的值与检查器核心的结果进行比较。对于负载，这个过程是无序进行的（第III-G节）：当访问LSL条目时，数据负载被复制到负载队列中，并且负载队列中存储的地址与来自LSL$的值进行比较。对于存储，这在提交时发生：当存储被提交时，LSL$条目与存储队列中的地址和数据进行比较。为了避免减慢速度，每个负载或存储单元都有一个比较器。</p><h3 id=f-instruction-counter>F. Instruction Counter</h3><p>该计数器用于精确匹配主核心和检查器核心之间的检查点结束时间。在主核心一侧，当发生以下情况时，会生成检查点：(i) LSL$满了，(ii) 有中断或上下文切换，或(iii) 达到超时。此时，RCU会拍摄一份架构寄存器文件，并将其转发到检查器核心。在检查器核心一侧，我们在主核心提交的指令数与主核心检查点的时间点匹配时完成检查，并比较寄存器文件。</p><h3 id=g-speculative-out-of-order-checker-cores>G. Speculative Out-Of-Order Checker Cores</h3><p>LSL按程序顺序填充，在主核心提交时，如之前的工作[2]–[4]所示。然而，之前的工作依赖于按顺序访问LSL进行检查，限制了检查器仅能用于最简单的按顺序核心，在这些核心中，错误的预测永远不会到达数据路径，并且内存访问无法重新排序。这对于典型的可编程服务器核心来说是一个错误假设，即使是我们评估中最小的核心。为了解决这个问题，我们为LSL$使用了索引访问方案。无序检查器核心不再按顺序访问日志。当检查器核心解码负载/存储时，我们根据预期的LSL$负载的大小在按顺序前端增加一个猜测计数器（第III-B节），以便索引将指向程序顺序中的适当条目（见图4）。对于负载，这个猜测索引跟随指令进入负载队列，并在数据负载字段中，直到被返回的数据覆盖。对于存储，它没有显式存储，而是在提交时重新生成，当访问日志时进行处理。当负载/存储指令被分解为微操作时，这些微操作共享相同的索引。由于索引是猜测性质的，即使没有发生错误，访问LSL$时，访问的条目也可能与索引条目不匹配：猜测错误的指令将被压扁，并且访问的条目是预定用于返回到正确执行的指令。因此，怀疑的故障必须作为精确异常来处理：我们记录LSL$访问时的错误，但直到提交时才引发它们。当指令被压扁时，猜测的索引必须进行调整，以匹配提交顺序。我们通过在每个被压扁的指令上从前端的猜测索引中扣除来处理这一点。此外，当检查器开始检查新的LSL$段/检查点时，这个索引会被重置为0。</p><h3 id=h-eager-checker-core-waking>H. Eager Checker-Core Waking</h3><p>在之前的工作[2]–[4]中，检查器核心仅在检查点完成后被唤醒，以确保执行的一致性。如果检查器核心足够简单，几乎不占用资源，这是合理的，但如果检查器核心的大小与常规核心相当，这样会浪费资源，因为至少有一个核心总是等待检查点完成而停滞。检查器核心可以提前启动，只要它从不执行超出主核心的指令，且因此不会读取无效的LSL$条目，也不能执行主核心从未执行的指令（由于达到超时或发生中断，第III-J节）。为了实现这一点，同时确保匹配行为并防止检查器核心提前执行，我们使用LSL$作为限制器。检查器核心不能执行任何超出当前推送到检查器核心的最后LSL$条目的指令。如果它尝试这样做，并且RCU检查点尚未设置，检查器核心将睡眠，直到向其LSL$推送一个缓存行或设置RCU检查点。试图读取LSL$中最后有效条目的内存访问指令会导致所有后续指令被压扁（除了作为相同宏操作的一部分的微操作）。当新的日志缓存行到达或接收到检查点寄存器文件以指示检查点结束时，取指从第一个被压扁的指令重新开始。如果读取最后有效条目的操作本身被压扁，指令取指也会重新开始，任何随后的尝试读取当前最后LSL$条目的操作都会使核心重新进入睡眠状态。</p><h3 id=i-hash-mode>I. Hash Mode</h3><p>ParaVerser使用大量的NoC流量将LSL$条目从主核心发送到检查器核心。为了限制这一点，我们还提供了哈希模式，其中仅记录执行所需的数据（例如，加载的数据）并将其传输到LSL$条目中，并通过NoC传输（条目仍按顺序连续存储）。仅用于验证正确性的数据（例如，地址和存储数据）会进行校验和处理，只有哈希值被传输到NoC并在检查点结束时进行比较。哈希模式将负载流量减少50%，并完全消除了存储的流量，但可靠性将取决于哈希函数的属性。不能检测相同位上的重复错误或重排序的哈希函数应避免使用——在这里我们使用SHA-256[29]。哈希模式需要对之前提到的机制进行一些修改。在哈希模式下，LSL$条目仅包含按提交顺序重现执行所需的数据，因此无序核心的猜测索引只有在指令具有这些数据时才会增加。对于微操作，偏移量在解码时计算并与索引一起存储，直到访问LSL$。主核心和检查器核心都使用LSPU来缓冲要用于哈希计算的数据，在指令提交时保持访问顺序。检查器核心不再使用LSC来检测LSL$访问错误。相反，哈希值在RCU中计算，并与寄存器检查点一起发送到检查器的RCU进行比较。</p><h3 id=j-multiprocess-and-multicore>J. Multiprocess and Multicore</h3><p>为了避免在主核心和检查器核心之间同时重播中断的需求，每当发生中断时都会进行寄存器检查点。这对于上下文切换也是如此：因此，每个寄存器检查点只与一个进程相关联。多个进程在一个主核心上的检查可以在多个检查器核心上并行进行，就像多个进程在多个主核心上的检查也可以并行进行一样。如果在任何特定进程的检查点中发生错误，则会引发该进程的异常。ParaVerser不是一个错误修正系统，因为它在执行和检查之间会产生延迟，以实现线程级并行性，因此，如果发现错误，软件必须自行清理（第II-C节）。ParaVerser使用的日志系统可以在不做修改的情况下扩展到多核共享内存工作负载[3]。由于主核心看到的确切负载和存储然后传播到检查器核心，任何由此产生的跨线程通信也会被准确地模拟和检查。在检查器核心分配方面，我们将每个主核心视为一个单独的检查任务，并将其分配到多个检查器中。</p><h2 id=sphere-of-replication>SPHERE OF REPLICATION</h2><p>ParaVerser 是一种计算冗余机制，因此复制的范围是处理器核心本身，边界位于负载存储队列（LSQ），其内容被复制并通过负载存储日志（LSL）传输到检查核心。缓存位于复制范围之外，需要使用奇偶校验或错误更正码（ECC）来确保其正确性，以及缓存系统内部任何计算（如一致性）的冗余。</p><p>检查核心上的冗余执行不会重复数据地址转换，并假设记录在 LSL 中的加载数据是正确的；如果希望覆盖核心的每个晶体管，应该在页表遍历器和 LSQ 中增加额外的冗余。在这种情况下，这涉及在数据发送到 LSL 之前传播和检查奇偶校验位，以及冗余机制来捕捉来自 LSQ 逻辑本身的故障错误（例如，由于位翻转而错误地检测到访问顺序违规）。</p><p>在完全覆盖模式下，ParaVerser 可以检测系统中的硬错误和软错误。机会模式仅针对最终可以检测到的硬错误，但也会在检查的片段中检测到软错误。由于我们不区分硬错误和软错误，操作员需要在我们检测到错误后运行自己的测试，以确定核心是否存在硬故障并需要退役。如果需要更精确的故障分析，我们的起始寄存器检查点允许重复回放以识别故障原因，代价是每个核心额外 776B 的开销。不会改变执行的错误仍然可以被检测到，如果 LSL 的内容、哈希模式中的哈希值，或者寄存器检查点开始或结束时的寄存器值发生变化，我们无法直接区分错误来自主核心还是检查核心。这些可以被认为是假阳性，因为检测到的错误并不影响主核心的执行。然而，这些仍然代表系统中某个地方发生的真实错误；因此，它们仍然有助于在发生硬错误时尽早退役故障核心。在哈希模式下，我们使用 SHA-256 哈希，因为具有和不具有错误的值产生的哈希值碰撞的可能性极低，具有 128 位碰撞抗性安全性。</p><h2 id=experimental-setup>EXPERIMENTAL SETUP</h2><p>为了评估ParaVerser，我们将ParaDox模拟器[4]移植到了gem5 v22.0.0.1版本。我们添加了第III节中描述的新机制，并设计了高性能服务器风格的Arm核心CPU模型（见表I），基于公开的Cortex-X2 [6]，[11]，[92]和Cortex-A510 [10]，[91]核心的信息，这些核心分别构成了Arm异构数据中心Neoverse V2和E2的基础[81]。我们的主核心始终为3GHz的乱序核心；我们在不同的时钟频率下运行不同数量和类型（大核心、小核心）的检查核心。先前的工作[2]，[4]在原始评估中使用了gem5的通用MinorCPU模型，该模型例如为所有浮点运算提供了不现实的6周期延迟，而诸如除法等指令的延迟可能长达22周期[10]，[12]。即便是整数运算，该模型也缺乏共享相同功能单元的操作的可变延迟建模，而gem5的HPI核心则为我们的A510模型提供了这方面的改进。这意味着先前工作的核心模型并未提供合理的比较基础，因此我们采用了基于Cortex-A55 [12]的专用检查核心模型，并限制其为标量核心，以模拟Cortex-A34/35 [5]核心的性能（由于文档缺失）。这些是支持AArch64 [14]的最小乱序Cortex-A处理器。</p><p>我们使用SPECspeed 2017基准进行评估，统计数据来自详细仿真，仿真1B指令，除非另有说明，模拟将跳过初始化并运行PARSEC至完成，慢速执行时相对于没有检查的基准来展示。在评估完全覆盖模式时，我们评估性能开销；在评估机会模式时，我们也评估检查覆盖率。</p><p>我们通过将gem5网络参数输入到MM1排队网络模型中，模拟了NoC延迟，该模型采用2D网格布局。图5展示了我们实验中使用的4x4网格布局，核心作为主核心用阿拉伯数字0-3表示，作为相同颜色主核心的检查核心用罗马数字iiv表示。NoC配置为256位宽，时钟频率为2GHz，除非另有说明，类似于ARM Neoverse CMN-700网格网络的能力[7]。网格中间的4个交叉点每个都连接一个LLC切片和一个核心，每个LLC切片假定为每个主核心提供1/4的需求数据。除了角落的4个交叉点，其他交叉点每个连接2个核心。我们选择没有LLC切片的交叉点上的核心作为主核心，因为这种情况在我们的布局中更常见，而与主核心相邻的核心则作为检查核心使用。当使用异构主核心和检查核心时，该布局表示一个带有大核心和小核心分布的平铺系统，而不是同质核心的聚集。仅使用1个主核心时，使用核心0作为主核心；使用2个主核心时，使用核心0和核心1。在选择检查核心时，首先选择检查核心i，因为它会导致需求流量的争用并带来更大的性能开销。如果需要更多检查核心，则使用核心ii–iv。未使用的主核心和检查核心假定为空闲，不产生流量。我们通过回传从额外的LSL$流量中观察到的平均延迟，进入gem5的LLC访问延迟，以估算开销，并在第VI-D节中探讨NoC带宽的影响。</p><h2 id=evaluation评估>EVALUATION(评估)</h2><h3 id=a-完全覆盖模式><strong>A. 完全覆盖模式</strong></h3><p>图6显示了在完全覆盖模式下（所有动态指令都被检查）不同检查核心配置下主核心的性能下降，相比于先前的工作，DSN18 [2]配置了12个检查核心，Paradox [4]配置了16个专用检查核心。通过将检查核心配置为与3GHz主核心相同的异构系统，检查核心能够跟上主核心的执行进度，几何平均性能下降为1.6%。而DSN18的配置显示出9%的几何平均性能下降，无法跟上我们X2主核心的性能。虽然Paradox在16个专用检查核心的配置下显示出仅1.2%的性能下降，但这需要35%的面积开销（第VI-E节），限制了可用于计算的硅区域。ParaVerser提供了利用已有核心的检查功能，当检查功能关闭时，它不影响性能。采用2个运行在半频率（1.5GHz）的X2检查核心时，性能下降几乎与异构系统相同。虽然LSL流量与NoC的需求流量发生争用，但这一优势被由未共享组件（如icache预取和分支预测训练）带来的额外性能开销所抵消，导致略微增加的未命中率和预测错误率。使用4个运行在2GHz的A510核心作为检查核心时，性能下降为3.4%。检查核心的集体性能通常与主核心相匹配，除了bwaves。在bwaves中，大量的浮点除法指令和大核心X2 [11]与小核心A510 [10]之间在浮点除法性能上的巨大差异，导致最差的检查核心无法跟上最好的主核心。通过DVFS，我们还将A510检查核心的频率从2GHz调整至1.4GHz，并相应调整电压，以寻找每个基准的最佳ED2P点，性能下降仍仅为4.3%。</p><p>接下来，我们考虑开销的原因：</p><ul><li><strong>寄存器检查点</strong>
在之前的工作[2]中，寄存器检查点由于延迟主核心的提交来复制寄存器文件而产生显著开销，而在ParaVerser中，这种开销可以忽略不计。通过重新利用常规核心的缓存，我们拥有更大的LSL（64KiB对比3KiB [2]），因此检查点的频率大大降低。</li><li><strong>停顿开销</strong>
在完全覆盖模式下，当检查核心无法跟上主核心时，主核心必须停顿，直到有检查核心可用。这是主核心减少时钟频率、数量和乱序能力时的主要因素。</li><li><strong>指令获取</strong>
虽然检查核心永远不会引起对主内存或共享缓存的访问，因为它们的加载和存储通过LSL$提供服务，但它们仍然会通过LSL$访问指令。这在完全覆盖模式和机会模式下会导致轻微的争用效应，特别是在如gcc这样的工作负载中，其中频繁发生L1 icache未命中。</li><li><strong>NoC开销</strong>
加载和存储会根据总线宽度（第III-C节）分组，记录并转发到检查核心。虽然这不会对检查核心造成显著延迟（因为它们是推送消息而不是请求消息），但它会对同一网络上其他请求造成次要争用效应，尤其是LLC访问。</li></ul><h3 id=b-机会模式><strong>B. 机会模式</strong></h3><p>图7显示了与第VI-A节相同的检查核心配置，但启用了机会模式，机会模式在资源不足时减少覆盖，而不是停顿。出乎意料的是，开销低于完全覆盖模式，对于异构系统，几何平均性能下降为1.4%，对于2个X2或4个A510，性能下降不到1%。开销主要来自于NoC争用，因此无论核心频率如何，性能下降都保持平稳。为了研究机会模式的硬错误覆盖率，我们根据文献中的标准模型[59]注入了硬错误，图8展示了不同检查核心配置下的结果。由于错误检测是对称的，为避免注入的错误妨碍主核心的执行，错误被注入到检查核心。我们将硬错误建模为单比特卡住错误，并将错误注入到gem5模型中的功能单元输出值。
在完全覆盖模式下，我们注入了10M条指令，发现76%的注入错误在完全覆盖模式下被检测到，其余错误（正确地）被掩盖，因为它们没有改变执行。图8中，几乎所有未被掩盖的注入错误都能在运行100M条指令内被检测到，即使只有一个A510运行在500MHz。对于大多数工作负载，这种配置能检测到所有有效错误；只有bwaves、deepsjeng、imagick和perlbench的检测率较低，为87-99%。除imagick外，其他所有工作负载在1GHz时可以达到100%的检测率，imagick在2个A510运行在2GHz时也能达到100%的检测率。</p><p>我们还发现，在机会模式下，运行时指令覆盖率（即被检查的主核心指令的比例）在有足够的检查核心时较高。使用3GHz的X2检查核心时，几何平均覆盖率高达98%以上，且几乎没有性能开销。当检查核心频率降低至2.7GHz时，覆盖率降至94%。使用4个A510检查核心时，在2GHz、1.8GHz和1.6GHz时，几何平均覆盖率分别为97%、96%和95%。与完全覆盖模式中的性能下降类似，bwaves的运行时指令覆盖率显著低于其他基准，即使使用2GHz的A510，覆盖率也仅为71%，这是由于其大量的浮点指令。</p><h3 id=c-数据导向并行和多进程工作负载><strong>C. 数据导向、并行和多进程工作负载</strong></h3><p>为了展示更广泛的服务器端工作负载，我们还看了图形工作负载的GAP套件[20]。GAP如此依赖内存，以至于即使是少数几个检查核心也能跟上主核心的执行；图9显示，即使在完全覆盖模式下，2个A510也足以应对，除了PageRank之外。ParaVerser还能够处理并行工作负载。图9还显示了在2线程的PARSEC [23]上，ParaVerser在完全覆盖模式下的性能下降。虽然PARSEC不像GAP那样严重依赖内存，但当每个主核心使用3个A510时，性能下降仅为7.6%。</p><p>为了评估ParaVerser对多进程工作负载的影响，我们运行了SPECspeed 2017基准的随机混合测试14，模拟了4个主核心的1亿条总指令（在最快的核心上快速转发10亿条指令后），每个核心至少运行250百万条指令（混合1-4）或至少100百万条指令（混合5），以应对模拟时间限制。图10显示了在不同检查核心配置下的总CPI性能下降。虽然来自一个进程的额外LSL流量与其他进程的需求流量发生争用，但整体性能开销较小，几何平均仅为1%，对于1.5GHz的异构检查核心或2个X2检查核心，性能下降不到0.6%，对于2GHz的4个A510检查核心，性能下降不到0.6%。</p><h3 id=d-noc-灵敏度研究>D. NoC 灵敏度研究</h3><p>为了评估 LSL 流量的影响，我们进行了灵敏度研究，将检查器核心配置为最高频率，并采用128位宽、1.5GHz频率的较慢 NoC 配置。同时，我们还展示了启用哈希模式（参见章节 III-I）对这一较慢 NoC 的影响。图11显示，一些基准测试受到了显著影响，导致几何平均开销超过15%。启用哈希模式后，LSL 流量至少减少一半，NoC 压力大幅缓解，使得几何平均开销降至仅比较快 NoC（256位宽、2GHz 时钟频率）高0.8%。较快 NoC 对同构检查器核心的 NoC 开销为1.5%，而对异构核心的开销低于1%。</p><h3 id=e-功耗与面积开销>E. 功耗与面积开销</h3><p>ParaVerser 修改仅增加了每个核心1064B的存储开销：包括2宽 LSC 的48B，每个加载和存储队列项的2位奇偶校验位（如果尚未存在）、前后端 LSL$ 索引的16位、用于 LSPU 的512位（或一个缓存行）、LSL$ 中每个缓存行的1位、指令计时器的13位以及RCU的776B。
此前研究【4】估算专用检查器核心的面积开销低于2014年 Cortex A57 的三分之一，但其基于 RISCV 核心，并与 ARM 主核心对比，尽管该技术需要相同的 ISA。我们基于 X2 和 A510 核心的晶圆照片像素计算【8】，使用三星 4LPE 工艺得出其面积分别约为 2.43mm² 和 0.44mm²。通过推算【32】【33】基于 28nm TSMC 的 A35 核心【5】，我们估算16个 A35 核心的面积约为 0.84mm²，导致35%的面积开销。
尽管检查器核心是从现有计算单元中复用而非新增，但每个检查器核心的开启势必比闲置状态消耗更多功率。我们通过 McPAT【60】在22nm下评估其开销。对于4个2GHz运行的 A510 检查器，静态和动态功耗加时间的能量开销几何平均值比全部检查器核心电源关闭的基线高49%。对于2个1.5GHz运行的 X2 检查器，能量开销为45%；而1个3GHz运行的 X2 检查器（同构，可比双核锁步【57】【58】【90】），能量开销为95%。
通过降低4个 A510 核心的频率和电压以减少运行至2GHz以下，我们实现了 ED2P 最小配置，其能量开销为29%，性能减速为4.3%（相比于全速下的49%能量开销和3.4%减速）。相比之下，针对先前研究中的专用检查器核心【2】【4】，我们观察到其能量开销为25%。考虑到额外的35%面积开销，与系统中现有的4个 A510 核心实现 ED2P 最小配置相比，这并未提供显著的能量节省。</p><h3 id=f-计算机会成本>F. 计算机会成本</h3><p>从另一种角度来看，用于检查的核心可以执行额外的计算。对于包括大多数 SPEC 应用程序在内的单线程工作负载，这无关紧要：程序在多核上并不更快。对于并行工作负载，直观上重复所有计算会导致2倍的减速。然而，并行应用程序的扩展性通常不如检查，且更依赖内存，导致竞争进而减慢所有核心的运行速度。例如，在1个大核心和2个小核心上运行 GAP，仅比单独运行1个大核心快1.52倍：相同数量的小核心可以在10%性能开销下实现全面检查。同样，对于在1个大核心和3个小核心上运行的 PARSEC，仅观察到1.44倍的加速，而将小核心用于检查的同一设置下的开销仅为7.6%。相比之下，同构设置下使用两个大核心时，GAP 和 PARSEC 的加速分别为1.9倍和1.8倍。</p><h2 id=conclusion>CONCLUSION</h2><p>ParaVerser 是第一个能够在满足 HPC 和数据中心严格的功耗/性能/面积（PPA）限制的条件下，实现高覆盖率、低成本错误检测能力的系统。通过微小的改动，下一代服务器能够在性能不受损的情况下，同时实现强大的全面保障和高覆盖率采样。相较于仅依赖软件扫描器，硬件级的静默错误检测更能有效缓解日益严重的问题；通过归纳并行实现的异构性，则提供了此前仅能通过高成本锁步机制实现的高效保障。由于 ParaVerser 是通过重新利用计算单元，而非增加专用的高开销组件来实现检测功能，既需要保障的系统与无需保障的系统均可使用同一设备。ParaVerser 首次为大规模静默数据损坏问题提供了实用的解决方案。</p><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><h3 id=版权信息>版权信息</h3><p>本文原载于 <a class=link href=https://vastcircle.github.io target=_blank rel=noopener>vastcircle.github.io</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86%E5%99%A8/>安全处理器</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2025/scalar_vector_runahead/><div class=article-details><h2 class=article-title>Scalar_vector_runahead</h2></div></a></article><article><a href=/2024/vector_runahead/><div class=article-details><h2 class=article-title>Vector_runahead</h2></div></a></article><article><a href=/2024/decoupled_vector_runahead/><div class=article-details><h2 class=article-title>Decoupled_Vector_Runahead</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2025 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了210.7k字·共 71篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>abstract</a></li><li><a href=#简介>简介</a><ol><li><a href=#ii-动机><strong>II. 动机</strong></a><ol><li><a href=#a-数据中心规模的错误><strong>A. 数据中心规模的错误</strong></a></li><li><a href=#b-异构并行错误检测><strong>B. 异构并行错误检测</strong></a></li><li><a href=#c-机会性并行错误检测><strong>C. 机会性并行错误检测</strong></a></li><li><a href=#d-检测核的设计考量><strong>D. 检测核的设计考量</strong></a></li></ol></li></ol></li><li><a href=#paraverser>PARAVERSER</a><ol><li><a href=#a-basic-operation>A. Basic Operation</a></li><li><a href=#b-load-store-log-cache>B. Load-Store Log Cache</a></li><li><a href=#c-加载-存储推送单元>C. 加载-存储推送单元</a></li><li><a href=#d-register-checkpointing-unit>D. Register Checkpointing Unit</a></li><li><a href=#e-load-store-comparator>E. Load-Store Comparator</a></li><li><a href=#f-instruction-counter>F. Instruction Counter</a></li><li><a href=#g-speculative-out-of-order-checker-cores>G. Speculative Out-Of-Order Checker Cores</a></li><li><a href=#h-eager-checker-core-waking>H. Eager Checker-Core Waking</a></li><li><a href=#i-hash-mode>I. Hash Mode</a></li><li><a href=#j-multiprocess-and-multicore>J. Multiprocess and Multicore</a></li></ol></li><li><a href=#sphere-of-replication>SPHERE OF REPLICATION</a></li><li><a href=#experimental-setup>EXPERIMENTAL SETUP</a></li><li><a href=#evaluation评估>EVALUATION(评估)</a><ol><li><a href=#a-完全覆盖模式><strong>A. 完全覆盖模式</strong></a></li><li><a href=#b-机会模式><strong>B. 机会模式</strong></a></li><li><a href=#c-数据导向并行和多进程工作负载><strong>C. 数据导向、并行和多进程工作负载</strong></a></li><li><a href=#d-noc-灵敏度研究>D. NoC 灵敏度研究</a></li><li><a href=#e-功耗与面积开销>E. 功耗与面积开销</a></li><li><a href=#f-计算机会成本>F. 计算机会成本</a></li></ol></li><li><a href=#conclusion>CONCLUSION</a></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li><li><a href=#版权信息>版权信息</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/a_prime_on_hardware_prefetch/ class=category-list-link>a_prime_on_hardware_prefetch<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>boom代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cache/ class=category-list-link>cache<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/chisel/ class=category-list-link>chisel<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/riscv/ class=category-list-link>riscv<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ class=category-list-link>环境搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>8</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81/ class=category-list-link>香山源代码<span class=category-list-count>7</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2025><span class=year>2025</span>
<span class=count>24</span></a></div><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>47</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_6>Runahead
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/diplomacy/ class=font_size_2>Diplomacy
</a><a href=/tags/in-order/ class=font_size_2>In-Order
</a><a href=/tags/prefetch/ class=font_size_2>Prefetch
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>