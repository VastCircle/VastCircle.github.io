<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='概述 虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中
'><title>虚拟存储器</title>
<link rel=canonical href=https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='虚拟存储器'><meta property='og:description' content='概述 虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中
'><meta property='og:url' content='https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='虚拟存储器'><meta property='article:published_time' content='2024-11-12T20:12:09+08:00'><meta property='article:modified_time' content='2024-11-12T20:12:09+08:00'><meta name=twitter:title content="虚拟存储器"><meta name=twitter:description content="概述 虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/>超标量处理器</a></header><h2 class=article-title><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/>虚拟存储器</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 12, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>6790字</time></div></footer></div></header><section class=article-content><h2 id=概述>概述</h2><p>虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中</p><p>虚拟存储器空间的大小由处理器的位数决定,对于32位处理器,地址范围就是0~0xFFFFFFFF,就是4GB ,这些地址就是虚拟地址</p><p>和虚拟存储器相对应的就是物理存储器,是在现实世界中能够使用的存储器,其中的地址就是物理地址</p><p><figure class=gallery-image style=flex-grow:173;flex-basis:416px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891.png data-size=580x334><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891.png width=580 height=334 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891_hu9392279268069119721.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891_hu7023267616482017088.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:176;flex-basis:424px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094.png data-size=569x322><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094.png width=569 height=322 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094_hu14335039875351292116.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094_hu7954957040857737702.png 1024w" loading=lazy></a></figure></p><p>MMU(memory manage unit,MMU)内存管理单元</p><p>使用物理地址,运行程序时需要为每个程序分配一块地址空间,每个程序需要在地址空间中进行运行</p><p>使用虚拟地址,每个程序会认为它独占了整个地址空间,这样在编写程序时不需要考虑地址的限制,由操作系统负责调度,将物理存储器动态分配给各个程序,将每个程序的虚拟地址转为物理地址.</p><p>虚拟地址还可以带来保护(protect)和共享(share)</p><h3 id=地址转化--基于分页page的虚拟存储器>地址转化 -基于分页(page)的虚拟存储器</h3><p>典型的页大小是4KB ,物理地址中称为frame,page和frame的大小必须相等</p><p>程序运行时会进行把程序从硬盘搬移到物理内存中,每次搬移的单位就是一个页</p><p>VA[11:0]表示页内的位置,称为page offset ,VA剩余的部分表示哪个页,称为VPN(Virtual Page Number)</p><p>PA[11:0]表示frame的位置,称为frame offset,剩余部分表示哪个frame,称为PFN(Physical Frame Number)</p><p>从VPN到PFN,offset不需要变化</p><p>比方说 page0 -> frame 2 ,offset = 4 , 那只需要把VPN换成PFN ,就是把0换成2,</p><p>如果程序的内容没有存储在物理内存中,MMU就会产生Page Fault的异常给处理器,处理器通过异常处理程序(操作系统的一部分代码)找到替换的frame ,需要先解除frame 和 page的映射,然后把硬盘的内容搬移到frame,然后添加frame和page的映射,如果被替换的frame是dirty的,还需要先将内容搬移到硬盘中,处理完成之后返回发生异常的指令重新执行</p><p><figure class=gallery-image style=flex-grow:159;flex-basis:383px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257.png data-size=717x449><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257.png width=717 height=449 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257_hu844777046950357857.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257_hu1495159615354411353.png 1024w" loading=lazy></a></figure></p><h4 id=单级页表线性页表>单级页表(线性页表)</h4><p>页表(page Table,PT)用来存储从虚拟地址到物理地址的映射关系,一般页表是放在物理内存中的,需要使用虚拟地址寻址,页表内被寻址到的内容就是这个虚拟地址对应的物理地址,处理器中会有一个页表寄存器(Page Table Register,PTR)来存放当前运行程序的页表在物理内存中的起始位置,每次操作系统将程序调入物理内存都会去将PTR设置好</p><p>两次内存访问,先使用虚拟地址访问页表,再使用物理地址进行寻址</p><p>使用PTR和虚拟地址共同寻址页表,相当于使用它们共同组成一个地址,用来寻址物理内存</p><p>valid用来指示当前的page是否在物理内存中</p><p>下图展示如何通过PTR从物理内存中定位一个页表,并且使用虚拟地址来寻址页表,从而找到物理地址,</p><p>具体来说就是一个虚拟地址VPN[31:12],页表的起始物理地址是addr,那这个虚拟地址对应的物理地址就是addr + VPN[31:12]所对应的entry的值,就完成了相应的映射</p><p>页表的表项数为2^32 / 4K = 2 ^20 = 1M ,需要20位来寻址,在页表中包括的所有VPN的映射关系,页表的大小是4B * 1M = 4M , 一个entry 需要32位,因为物理内存的数据位宽是32位</p><p><figure class=gallery-image style=flex-grow:198;flex-basis:476px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106.png data-size=808x407><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106.png width=808 height=407 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106_hu9820542538462257665.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106_hu11134552561278830943.png 1024w" loading=lazy></a></figure></p><p>程序对应的页表,连同pc和通用寄存器,组成了程序的状态,在切换程序时,需要去保存状态,该程序称为进程,用户打开程序,操作系统会分配物理内存的空间,创建页表和堆栈等,进程的页表指定了能够在物理内存中访问的地址空间</p><p>可以通过页表通过相同的虚拟地址访问不同的物理地址 ,通过不同的虚拟地址访问相同的物理地址,实现进程的保护和共享</p><p><figure class=gallery-image style=flex-grow:137;flex-basis:329px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256.png data-size=639x465><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256.png width=639 height=465 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256_hu4352988920381212314.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256_hu15938731263752335312.png 1024w" loading=lazy></a></figure></p><h4 id=多级页表>多级页表</h4><p>将4MB的线性页表划分为若干个更小的页表,称为子页表.操作系统在处理进程的时候,根据需求逐步放入子页表,并且子页表不再占用连续的物理内存空间.需要一个表格记录子页表在物理内存中存储的位置,称为第一级页表(level1 page Table),子页表称为第二级页表(level2 Page Table)</p><p><figure class=gallery-image style=flex-grow:118;flex-basis:285px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578.png data-size=557x469><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578.png width=557 height=469 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578_hu13967031774116966010.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578_hu15170062433743167635.png 1024w" loading=lazy></a></figure></p><p>一个2^20的entry的页表可以划分为2^10 entry的一级页表+2^10个2^10大小的二级页表,一个页表的表项称为PTE(Page Table Entry),当操作系统创建一个进程,就在物理内存找一块4KB空间存放一级页表,并将基地址放在PTR寄存器中,一个虚拟地址肯定能够对应一个一级页表的表项,用后10位寻址一级页表,获取二级页表,然后再用前10位获取二级页表的表项,</p><p>页表的映射关系应该都是操作系统分的,是在异常那边进行处理的</p><p><figure class=gallery-image style=flex-grow:130;flex-basis:314px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760.png data-size=817x624><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760.png width=817 height=624 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760_hu2940597119313810523.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760_hu11773006285468692535.png 1024w" loading=lazy></a></figure></p><p>不同的虚拟地址会导致出现不同的页表,极端情况为(1)4M程序连续,会建立一个一级页表和一个二级页表=8KB ,(2)都是离散的,并且全部都在4MB的边界上,这样需要建立1024个二级页表+一个一级页表=4100kB</p><p>增加级数,一级页表寻址二级页表,寻址3级页表&mldr;</p><p>2^64entry -> 4096个2^40entry</p><p>​ -> 4096个4096个2^28 entry</p><p>​ -> 4096 4096 4096 2^16 entry &mldr;</p><p><figure class=gallery-image style=flex-grow:177;flex-basis:425px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927.png data-size=866x489><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927.png width=866 height=489 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927_hu8599081119763294452.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927_hu8742420021551640479.png 1024w" loading=lazy></a></figure></p><p>需要多次访问物理内存,</p><p><figure class=gallery-image style=flex-grow:131;flex-basis:314px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228.png data-size=669x510><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228.png width=669 height=510 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228_hu10601366518261350491.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228_hu2163039551090256012.png 1024w" loading=lazy></a></figure></p><p>处理器多个进程时,为进程分配的物理内存之和可能大于实际可用的物理内存,部分页可能临时存在在下一级的硬盘中,成为swap空间 ,需要用到这些页时才会被调入到物理内存</p><p>把页从物理内存写入硬盘称为Page out ,从硬盘写入swap空间称为Page In</p><p><figure class=gallery-image style=flex-grow:108;flex-basis:260px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087.png data-size=387x356><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087.png width=387 height=356 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087_hu17650543691703514328.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087_hu4548535786874561091.png 1024w" loading=lazy></a></figure></p><p>利用虚拟存储器,可以管理每一个页的访问权限,只需要在页表中去设置每一个页的属性就可以了,</p><h4 id=page-fault>Page Fault</h4><p>Page Fault是异常的一种,通过操作系统来进行完成</p><p>(1)Page Fault需要访问硬盘,通常为毫米级别,与Page Fault对应的异常处理程序来说是微乎其微的</p><p>(2)使用软件可以根据实现情况实现灵活的替换算法,找到最合适的页进行替换</p><p>直接使用虚拟地址不能知道页位于硬盘的哪个位置,只能知道物理内存的,需要操作系统在开辟swap空间的同时,会使用一个表格记录每个页在硬盘中存储的位置,可以和页表进行合并</p><p>如果valid为0,代表页在硬盘中,反之在物理内存里</p><p>但是实际上物理上仍然是分开的,因为不管一个页是不是在物理内存中,操作系统都必须记录一个进程的所有页在硬盘中的位置</p><p><figure class=gallery-image style=flex-grow:120;flex-basis:288px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162.png data-size=563x468><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162.png width=563 height=468 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162_hu16669049199911691540.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162_hu12050019672886567113.png 1024w" loading=lazy></a></figure></p><p>(1)写通(Write Through),将改变的内容马上写回到硬件中去</p><p>(2)写回(Write Back),只有等到地址的内容在物理内存中要被替换时,才将内容写回到硬盘</p><p>在PTE中增加一个dirty的状态位,当页内的某个地址被写入是,dirty的状态会被置1.在需要被替换时,根据dirty位去决定是否要先写回到硬盘中去</p><p>替换算法可以在硬件上提供支持,在PTE中增加一位来记录每个页最近是否被访问过,称为"使用位(use)",可以周期性的去将使用位清零</p><p>为了处理Page Fault,硬件需要</p><p>(1)在发现Page Fault,能够产生对应类型的异常,并跳转到异常处理程序</p><p>(2)当写入物理内存时,需要将页表中对应PTE的脏状态置1.</p><p>(3)当store/load物理内存时,将use位置1</p><p><figure class=gallery-image style=flex-grow:227;flex-basis:547px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875.png data-size=677x297><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875.png width=677 height=297 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875_hu16875898927542427658.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875_hu5836178382668034331.png 1024w" loading=lazy></a></figure></p><h4 id=小结>小结</h4><h5 id=没有page-fault时>没有Page Fault时</h5><ol><li>处理器送出的VA送到MMU</li><li>MMU使用PRT和VA[31:12]组成访问页表的地址,送到物理内存</li><li>将寻址到的PTE返回给MMU</li><li>MMU判断valid=1,使用PA={PFN,VA[11:0]}访问物理地址</li></ol><p><figure class=gallery-image style=flex-grow:169;flex-basis:407px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566.png data-size=615x362><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566.png width=615 height=362 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566_hu9843346056032092035.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566_hu14508332668482389946.png 1024w" loading=lazy></a></figure></p><h5 id=发生page-fault>发生Page Fault</h5><p>1~3一致</p><ol start=4><li>MMU发现valid=0,触发Page Fault,处理器会跳转到Page Fault对应的异常程序中,此时MMU还会吧发生Page Fault的虚拟地址VA保存到专业的处理器,供异常处理程序使用</li><li>如果物理内存没有空闲空间,异常处理程序会根据替换算法,从物理内存找出未来可能不被使用的页,将其替换,页称为Victim Page,如果dirty为1,需要写入到硬盘</li><li>Page Fault异常处理程序会使用MMU保存的虚拟地址VA寻址硬盘,找到对应的页,将其写入到Victim page所在的位置</li><li>从异常程序返回时,引发Page Fault的指令会被重新取到流水线中,处理器会重新发送虚拟地址到MMU</li></ol><p><figure class=gallery-image style=flex-grow:226;flex-basis:542px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412.png data-size=807x357><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412.png width=807 height=357 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412_hu6221575889162077024.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412_hu8021151083403226446.png 1024w" loading=lazy></a></figure></p><h2 id=程序保护>程序保护</h2><p>操作系统的内容不允许被用户进程随意修改,操作系统中的有一部分允许用户进程读取.操作系统相对于普通用户进程来说,应该有足够多的权限,来保证操作系统对于系统的控制权;不同进程之间一个加以保护,一个进程不能让其他的进程随便修改自己的内容</p><p>上述条件需要操作系统和用户进程对于不同的页有不同的访问权限,通过页表可以实现,</p><p>操作系统一般不会使用页表,而是直接访问物理内存,物理内存中的专门一部分供操作系统来使用</p><p>ARMv7架构,AP部分决定每个页的访问权限</p><p><figure class=gallery-image style=flex-grow:232;flex-basis:558px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838.png data-size=836x359><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838.png width=836 height=359 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838_hu16735024332026684348.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838_hu8986040596683524870.png 1024w" loading=lazy></a></figure></p><p>一旦发现当前的访问不符合规定,会产生非法访问异常,使得处理器跳转到异常处理程序,由操作系统决定如何处理非法的访问</p><p><figure class=gallery-image style=flex-grow:190;flex-basis:456px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861.png data-size=747x393><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861.png width=747 height=393 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861_hu2288858152837664721.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861_hu8963100368267186447.png 1024w" loading=lazy></a></figure></p><p>也可以对一级页表设置权限控制,每个一级页表可以映射4KB*1024=4MB的地址范围,可以</p><p>00 -> 4MB空间不允许访问, 11 -> 对应的4MB空间不设限制 , 01 -> 需要产看第二级页表的PTE,获得页访问的权限,通过粗粒度和细粒度的组合,可以提高处理器的执行效率</p><p>在有dcache的处理器中,在虚拟地址转化为物理地址之后先去访问dcache,需要有一部分空间是不允许缓存的</p><p>PTE包含</p><p>(1)PFN,表示虚拟地址对应的物理地址的页号</p><p>(2)Valid,表示对应页当前是否在物理内存中</p><p>(3)Dirty,表示对应页中内容是否被修改</p><p>(4)Use,表示对应页中的内容是否被修改过</p><p>(5)AP,访问权限控制,表示操作系统和用户程序对当前页的访问权限</p><p>(6)Cacheable,表示对应页是否被缓存</p><h2 id=tlb和cache>TLB和Cache</h2><h3 id=tlb>TLB</h3><p>TLB(Translation Lookaside Buffer)用来缓存页表中最近使用的PTE,这样就不需要每次都去访问两次物理内存</p><p>TLB只有时间相关性,空间相关性没有明显的规律</p><p>一般TLB使用全相连的方式来设计</p><p>现代处理器采用两级TLB,一级TLB采用哈佛结构,分为I-TLB和D-TLB,采用全相联,二级TLB是指令和数据共用,一般采用组相连</p><p>TLB命中,直接返回从TLB中得到的物理地址,TLB缺失,需要访问物理内存中的页表</p><ol><li>页表中的PTE有效,直接从页表中得到对应的物理地址</li><li>页表中的PTE无效,需要从硬盘中去将相应的页搬移到物理内存中</li></ol><p><figure class=gallery-image style=flex-grow:260;flex-basis:624px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233.png data-size=484x186><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233.png width=484 height=186 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233_hu8864321583826033378.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233_hu16150349096023952055.png 1024w" loading=lazy></a></figure></p><p>现代处理器中都支持大小可变的页,由操作系统进行管理,根据不同应用的特点选用不同大小的页</p><h4 id=tlb缺失>TLB缺失</h4><p>(1)虚拟地址对应的页不再物理内存中</p><p>(2)虚拟地址对应的页在物理内存中,但是PTE没有放在TLB中</p><p>Page Table Walk:从页表中找到对应的映射关系,并将其写回到TLB中</p><ol><li>软件实现Page Table Walk.当发生TLB缺失,硬件把产生TLB缺失的虚拟地址保存到特殊寄存器中,产生TLB缺失的异常,在异常处理程序中,软件使用虚拟地址去寻址物理内存中的页表,找到对应的PTE,并且写回到TLB中 .为了防止在异常处理程序中又发生TLB缺失,这个程序会放在不需要进行地址转化的物理内存上 ,软件处理会冲说流水线</li></ol><p><figure class=gallery-image style=flex-grow:115;flex-basis:277px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171.png data-size=434x375><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171.png width=434 height=375 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171_hu6588184095300100579.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171_hu7411631538644157319.png 1024w" loading=lazy></a></figure></p><ol start=2><li>硬件实现Page Table Walk. 当发生TLB缺失时,自动使用当前的虚拟地址去寻址页表.硬件进行逐级寻址是比较方便的.这种方式比较适合超标量处理器,不需要打断流水线,但是如果操作系统没有在物理内存中建立好了页表,那硬件没有办法,还是得通过操作系统</li></ol><p>采用硬件处理TLB缺失需要使用硬件状态机来寻址页表,还需要将整个流水线暂停等待MMU处理缺失,但是在处理完之后就可以直接去执行.采用软件处理,需要执行异常处理程序,而且从异常处理程序退出后,将流水线恢复到TLB缺失发生之前的状态</p><p><figure class=gallery-image style=flex-grow:189;flex-basis:454px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186.png data-size=720x380><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186.png width=720 height=380 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186_hu10080609097408610238.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186_hu9383525678854467250.png 1024w" loading=lazy></a></figure></p><p>发生TLB缺失,如果需要的PTE在页表中,则TLB缺失的处理时间需要十几个周期,如果发生Page Fault异常,则需要成百上千个周期</p><p>对于TLB来说,随机替换算法是比较合适的,可以采用称为时钟算法的方法,就是通过计数器去随机取值,128的表项就可以通过7位的计数器来随机编号</p><h4 id=tlb的写入>TLB的写入</h4><p>在使用TLB作为页表的缓存,处理器送出的虚拟缓存会访问TLB,如果直接从TLB得到物理地址的话,会使得TLB对应的"use"set,如果是store,会使得dirty=1.但是,如果TLB采用写回,那此时不会去更新页表,所以页表的信息可能是过时的,一种方法是在Page Fault的时候,把所有TLB的表项写回到页表</p><p>但实际上没有必要,可以认为被TLB记录的页都是要被使用的,是无法被替换的,操作系统可以记录哪些PTE被放到了TLB中,这样实际上也能够避免当物理内存中一个页被踢出了之后,还需要查找它在TLB中是否被记录了,如果有还需要置0</p><p>操作系统也需要有能够控制dcache的能力,因为操作系统在物理内存中选择一个页进行替换的时候,如果这个页是脏的,它最新的内容不一定是在物理内存中,还有可能在dcache中.虽然说,存在在TLB的页不会被替换,那按理来说,存在在dcache的数据所对应的页也不会被替换.但是也有例外,比方说,发生TLB缺失之后,有TLB表项的会被替换,但是此时D-cache是没有发生变化的,</p><h4 id=对tlb进行控制>对TLB进行控制</h4><p>TLB是页表的缓存,如果一个页的映射关系在页表中不存在了,那么它在TLB中也不应该存在</p><p>(1)当一个进程结束,进程的指令(code),数据(data)和堆栈(stack)占据的页表置为无效,此时TLB中可能还存在对应的PTE,可以通过ASID去吧I-TLB和D-TLB的内容置为无效</p><p>(2)当一个进程占用的物理内存过大时,操作系统可能将进程中一部分不经常使用的页写回到硬盘中,也需要将TLB置为无效</p><p>对TLB的管理需要包括,1.能够将I-TLB和D-TLB的所有表项置为无效 2. 能够将I-TLB和D-TLB中的某一个ASID对应的所有表项置为无效 3.能够将某个VPN对应的表项置为无效</p><h5 id=arm的tlb管理>ARM的TLB管理</h5><p>(1)用来管理I-TLB的控制寄存器</p><ol><li>将VPN匹配的表项(entry)置为无效的控制寄存器</li></ol><ul><li>VPN相等</li><li>如果TLB中一个表项的Global位无效,需要ASID相等,如果Global有效,则不需要</li></ul><p><figure class=gallery-image style=flex-grow:503;flex-basis:1209px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975.png data-size=635x126><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975.png width=635 height=126 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975_hu2455770362994303047.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975_hu15984741137560243802.png 1024w" loading=lazy></a></figure></p><p>进程中某些地址的映射信息被改变时,需要将TLB对应的表项置为无效</p><ol start=2><li>将TLB中ASID匹配的所有表项置为无效的控制寄存器</li></ol><p><figure class=gallery-image style=flex-grow:483;flex-basis:1159px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169.png data-size=657x136><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169.png width=657 height=136 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169_hu3854128643418782147.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169_hu15103547143579885177.png 1024w" loading=lazy></a></figure></p><p>​ 当一个进程退出的时候,需要将当前进程在TLB中的所有内容都置为无效</p><ol start=3><li>将TLB中所有未锁定(unlocker)状态的表项置为无效,锁定状态的表项不发生改变.为了加快处理器某些关键程序的执行时间,可以吧一些表项设为锁定状态</li></ol><p>(2) 用来管理D-TLB的控制寄存器同理</p><p>(3)用于将TLB的内容进行读出和写入</p><p><figure class=gallery-image style=flex-grow:216;flex-basis:518px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210.png data-size=510x236><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210.png width=510 height=236 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210_hu1808296226409048137.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210_hu13257119095023359013.png 1024w" loading=lazy></a></figure></p><p>使用两个寄存器来对应一个表项,data1和data0,当读取TLB时,被读取表项的内容会放在寄存器中,</p><p>上面的寄存器都位于系统控制协处理器中,只需要通过访问协处理器的指令(MCR和MRC)就可以了</p><h5 id=mips风格的tlb管理>MIPS风格的TLB管理</h5><p>MIPS,TLB缺失通过软件来解决,MIPS定义了专门操作TLB的指令,使用这些指令可以直接对TLB进行操作</p><p><figure class=gallery-image style=flex-grow:134;flex-basis:321px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933.png data-size=845x630><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933.png width=845 height=630 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933_hu14168470725230903113.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933_hu6626241744745778815.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:292;flex-basis:701px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426.png data-size=555x190><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426.png width=555 height=190 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426_hu14294742867446194869.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426_hu3988204457967568634.png 1024w" loading=lazy></a></figure></p><p>MIPS处理器中,为了加快寻址页表的过程,硬件会自动将这两个部分(页表的基地址和偏移地址)放在context寄存器中,位于协处理器CP0.由于load指令无法直接使用CP0中的寄存器,首先要把context寄存器放在通用寄存器$k1中,在MIPS架构中,R26和R27只用在中断和异常中,也称为$k1和$k0</p><p>TLBWR将entryHi和EntryLo寄存器的内容写到TLB内随机指定的一个表项中,在发生TLB缺失,会自动将当前未能转换的虚拟地址的VPN以及当前进程的ASID写入到EntryHi寄存器中</p><h3 id=cache的设计>Cache的设计</h3><p>TLB只是加速了从虚拟地址到物理地址的转换,但是没有加速从物理内存中取数据的过程,也可以使用cache来加速</p><p>下面是物理Cache,和没有加入TLB其实是一样的</p><p><figure class=gallery-image style=flex-grow:390;flex-basis:937px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553.png data-size=578x148><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553.png width=578 height=148 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553_hu15455923065170511424.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553_hu1233705023164367393.png 1024w" loading=lazy></a></figure></p><p>因为要经过TLB,才能访问物理Cache,所以会增加流水线的延时,如果要获得和之前一样的运行频率,需要再加入一级流水线,但是这样增大了分支预测失败的惩罚,也增大了load指令的延迟</p><p>可以直接使用Virtual Cache来缓存数据</p><p><figure class=gallery-image style=flex-grow:368;flex-basis:884px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556.png data-size=538x146><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556.png width=538 height=146 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556_hu1682197753071144083.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556_hu6588021925935794266.png 1024w" loading=lazy></a></figure></p><p>虚拟Cache会导致两个问题</p><p>(1)同义问题(synonyms),也称为重名(aliasing),即多个不同的名字对应相同的物理位置,会出现Cache不同虚拟地址但实际上对应着相同的物理地址,这样就会浪费Cache的空间,而且load了数据了之后需要对其他虚拟地址的Cache都进行更改,因为实际上它们对应着同一个物理地址.</p><p>如果Cache的容量&lt;4KB,寻址的地址不会>12位,那么对应同一个物理地址的不同虚拟地址也会放在Cache的相同地址上,反之就可能出现同义</p><p><figure class=gallery-image style=flex-grow:218;flex-basis:523px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617.png data-size=587x269><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617.png width=587 height=269 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617_hu12388999493876051402.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617_hu12531450076396476628.png 1024w" loading=lazy></a></figure></p><p>要实现同时更新相同物理地址的Cache,就需要使用物理地址作为Cache的Tag部分,</p><p>下图的结构就可以解决同义的问题,</p><p><figure class=gallery-image style=flex-grow:141;flex-basis:339px><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874.png data-size=434x307><img src=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874.png width=434 height=307 srcset="/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874_hu12138166093619374866.png 480w, /2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874_hu6070767854557535341.png 1024w" loading=lazy></a></figure></p><p>未完待续</p><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><h3 id=版权信息>版权信息</h3><p>本文原载于 <a class=link href=https://vastcircle.github.io target=_blank rel=noopener>vastcircle.github.io</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/>虚拟存储器</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2024/cache/><div class=article-details><h2 class=article-title>Cache</h2></div></a></article><article><a href=/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/><div class=article-details><h2 class=article-title>rocket-src微架构代码解读</h2></div></a></article><article><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/><div class=article-details><h2 class=article-title>提交</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2024 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了123k字·共 37篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#概述>概述</a><ol><li><a href=#地址转化--基于分页page的虚拟存储器>地址转化 -基于分页(page)的虚拟存储器</a><ol><li><a href=#单级页表线性页表>单级页表(线性页表)</a></li><li><a href=#多级页表>多级页表</a></li><li><a href=#page-fault>Page Fault</a></li><li><a href=#小结>小结</a></li></ol></li></ol></li><li><a href=#程序保护>程序保护</a></li><li><a href=#tlb和cache>TLB和Cache</a><ol><li><a href=#tlb>TLB</a><ol><li><a href=#tlb缺失>TLB缺失</a></li><li><a href=#tlb的写入>TLB的写入</a></li><li><a href=#对tlb进行控制>对TLB进行控制</a></li></ol></li><li><a href=#cache的设计>Cache的设计</a></li></ol></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li><li><a href=#版权信息>版权信息</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>4</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>37</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_3>Runahead
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名
</a><a href=/tags/%E6%8F%90%E4%BA%A4/ class=font_size_2>提交
</a><a href=/tags/hugo/ class=font_size_1>Hugo
</a><a href=/tags/in-order/ class=font_size_1>In-Order
</a><a href=/tags/linux/ class=font_size_1>Linux</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>