<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='摘要 我们提出了解耦矢量预取 （DVR），这是一种内核内预取技术，与主应用程序线程分开执行，它利用大量内存级并行性来提高具有间接内存访问功能的应用程序的性能。DVR 在运行时动态推断循环边界，识别跨步负载，并矢量化作为间接链一部分的后续指令。它会主动为将来的负载发出内存访问，即使无序内核尚未停止，也会将其数据带入 L1 缓存，从而为主线程提供及时的预取。DVR 可以在运行时调整矢量化程度，在内部循环的多次调用中对同一间接内存访问链进行矢量化，并有效地处理沿矢量化链的分支发散。DVR 作为按需、推测性、按顺序、轻量级硬件子线程与内核内的主线程一起运行，并且产生的最小硬件开销仅为 1139 字节。相对于大型超标量 5 宽无序基线和 Vector Runahead（一种用于加速乱序处理器上的间接内存访问的最新微架构技术），DVR 为一组图形分析、数据库和 HPC 工作负载提供了 2.4× 和 2× 的性能。
'><title>Decoupled_Vector_Runahead</title>
<link rel=canonical href=https://VastCircle.github.io/2024/decoupled_vector_runahead/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='Decoupled_Vector_Runahead'><meta property='og:description' content='摘要 我们提出了解耦矢量预取 （DVR），这是一种内核内预取技术，与主应用程序线程分开执行，它利用大量内存级并行性来提高具有间接内存访问功能的应用程序的性能。DVR 在运行时动态推断循环边界，识别跨步负载，并矢量化作为间接链一部分的后续指令。它会主动为将来的负载发出内存访问，即使无序内核尚未停止，也会将其数据带入 L1 缓存，从而为主线程提供及时的预取。DVR 可以在运行时调整矢量化程度，在内部循环的多次调用中对同一间接内存访问链进行矢量化，并有效地处理沿矢量化链的分支发散。DVR 作为按需、推测性、按顺序、轻量级硬件子线程与内核内的主线程一起运行，并且产生的最小硬件开销仅为 1139 字节。相对于大型超标量 5 宽无序基线和 Vector Runahead（一种用于加速乱序处理器上的间接内存访问的最新微架构技术），DVR 为一组图形分析、数据库和 HPC 工作负载提供了 2.4× 和 2× 的性能。
'><meta property='og:url' content='https://VastCircle.github.io/2024/decoupled_vector_runahead/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='runahead'><meta property='article:tag' content='vector'><meta property='article:published_time' content='2024-12-17T12:28:27+08:00'><meta property='article:modified_time' content='2024-12-17T12:28:27+08:00'><meta name=twitter:title content="Decoupled_Vector_Runahead"><meta name=twitter:description content="摘要 我们提出了解耦矢量预取 （DVR），这是一种内核内预取技术，与主应用程序线程分开执行，它利用大量内存级并行性来提高具有间接内存访问功能的应用程序的性能。DVR 在运行时动态推断循环边界，识别跨步负载，并矢量化作为间接链一部分的后续指令。它会主动为将来的负载发出内存访问，即使无序内核尚未停止，也会将其数据带入 L1 缓存，从而为主线程提供及时的预取。DVR 可以在运行时调整矢量化程度，在内部循环的多次调用中对同一间接内存访问链进行矢量化，并有效地处理沿矢量化链的分支发散。DVR 作为按需、推测性、按顺序、轻量级硬件子线程与内核内的主线程一起运行，并且产生的最小硬件开销仅为 1139 字节。相对于大型超标量 5 宽无序基线和 Vector Runahead（一种用于加速乱序处理器上的间接内存访问的最新微架构技术），DVR 为一组图形分析、数据库和 HPC 工作负载提供了 2.4× 和 2× 的性能。
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></header><h2 class=article-title><a href=/2024/decoupled_vector_runahead/>Decoupled_Vector_Runahead</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 17, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>9315字</time></div></footer></div></header><section class=article-content><h2 id=摘要>摘要</h2><p>我们提出了解耦矢量预取 （DVR），这是一种内核内预取技术，与主应用程序线程分开执行，它利用大量内存级并行性来提高具有间接内存访问功能的应用程序的性能。DVR 在运行时动态推断循环边界，识别跨步负载，并矢量化作为间接链一部分的后续指令。它会主动为将来的负载发出内存访问，即使无序内核尚未停止，也会将其数据带入 L1 缓存，从而为主线程提供及时的预取。DVR 可以在运行时调整矢量化程度，在内部循环的多次调用中对同一间接内存访问链进行矢量化，并有效地处理沿矢量化链的分支发散。DVR 作为按需、推测性、按顺序、轻量级硬件子线程与内核内的主线程一起运行，并且产生的最小硬件开销仅为 1139 字节。相对于大型超标量 5 宽无序基线和 Vector Runahead（一种用于加速乱序处理器上的间接内存访问的最新微架构技术），DVR 为一组图形分析、数据库和 HPC 工作负载提供了 2.4× 和 2× 的性能。</p><h2 id=introduction>introduction</h2><p>Vector Runahead 不像早期的 runahead 提案那样跳过工作 [29,40,62,66] 来不断发现内存级并行性，而是将在 runahead 模式下执行的瞬态执行重新格式化为主要基于循环级并行性，遵循程序中未来循环迭代中许多不同依赖内存访问链的独立组，并以矢量化方式运行它们以减少前端和后端管道资源需求。</p><p>传统 Runahead 依赖于主线程的停滞条件，当处理器在 <strong>ROB（Reorder Buffer）</strong> 上停滞时才启动 Runahead 模式。DVR在一个轻量级,有序的子线程上下文中运行runahead进程 ,即使内核没有在完整的ROB上停滞,也允许启动,并允许主线程继续在其预期的计算上取得进展.</p><p>其次，它基于 VR 构建，在推测性提前上下文中的许多未来循环迭代产生的许多动态生成的 “通道” 上实现了 GPU 风格的发散和再收敛。<strong>发散</strong>：动态生成的通道可以独立执行，允许预取大量潜在的内存请求。<strong>再收敛</strong>：将这些发散的执行路径重新合并，从而有效组织内存请求，避免资源浪费。</p><p>第三，它在主计算的线程中执行发现模式，以精确预测将访问多少个未来的循环，以限制不准确的预取。当 DVR 发现 <strong>单个发现模式</strong>（仅外部循环）不足以覆盖足够的未来循环时，它进一步<strong>深入内部循环</strong>,然后可以有效地将所有这些输入矢量化在一起，以实现极端的内存级并行性.</p><p>DVR 技术可以<strong>大幅提前</strong>预取那些会导致缓存未命中的 load 指令,避免它们在 ROB 中长时间占据资源</p><p>DVR 意味着 runahead 不再是乱序处理器的超大指令窗口的替代品</p><h2 id=background>background</h2><h3 id=间接内存访问-indirect-memory-accesses>间接内存访问 (Indirect Memory Accesses)</h3><p><figure class=gallery-image style=flex-grow:341;flex-basis:819px><a href=/2024/decoupled_vector_runahead/image-20241217200930813.png data-size=645x189><img src=/2024/decoupled_vector_runahead/image-20241217200930813.png width=645 height=189 srcset="/2024/decoupled_vector_runahead/image-20241217200930813_hu18053708814167547954.png 480w, /2024/decoupled_vector_runahead/image-20241217200930813_hu15723172993509979074.png 1024w" loading=lazy></a></figure></p><p>数组A[i]是顺序访问的.但是,访问数组 B 的索引是通过对 A 的特定索引处的值进行哈希处理来计算的，而数组 C 的索引是通过对 B 的访问进行哈希处理来计算的。也就是说，对 C 的访问依赖于对 B 的访问，而对 B 的访问又依赖于对 A 的访问。对 B 和 C 的访问分别称为间接内存访问的第一级和第二级，数组 A 的访问和对数组 C 的访问之间的指令链称为间接链.</p><p>当访问需要多级间接寻址时，Runahead 的执行将因为前一级 Load 未完成而停滞，无法预取后续地址。对于图 1 中的示例，根据工作跳过技术，数组 C 的输入将无效，或者无法在提前终止之前返回.</p><p>受到处理器前端宽度和runahead 间隔的限制。</p><h3 id=vector-runahead>Vector runahead</h3><p><strong>自动生成不同索引</strong>,在遇到间接链开始的跨步 <code>load</code> 时，VR 会自动推测出多个不同偏移量的索引地址。这些地址会被解析并产生多个新的指令，模拟未来循环迭代中的不同访问位置。</p><p>将不同索引处的指令进行<strong>重排序</strong>，并同时发送多个 <code>load</code> 指令到内存系统。当处理器遇到 <code>load</code> 指令链时，不是按顺序执行一个接一个的加载，而是<strong>并行等待多个加载</strong>返回。</p><p>向量化标量指令以节约后端资源,将多个重排序的标量指令<strong>分组为向量</strong>指令。<strong>向量化</strong>使得多个 <code>load</code> 或计算操作可以同时发出，并通过一个向量操作完成。</p><p>延迟终止,生成完整的内存访问链.继续运行 Runahead 模式，直到生成完整的间接内存访问链。通过这种<strong>延迟终止</strong>，VR 能够覆盖更多的内存加载并提高预取的覆盖范围。</p><h2 id=motivation>Motivation</h2><h3 id=vector-runahead-的劣势>Vector Runahead 的劣势</h3><ol><li><p>ROB增大时性能提升减少 ,ROB的大小一直在增加,需要跟多周期才能填充,进入runahead模式的机会随着ROB大小的增大而减少 .因此为了能够最大限度的利用预取机会,</p><p><strong>VR不能等待full-ROB stall .</strong></p></li><li><p>在**矢量超前执行（Vector Runahead, VR）**中，超前执行模式的终止是基于将整个间接内存访问链中的所有加载指令进行矢量化并生成预取。这意味着，尽管原本导致重排序缓冲区（ROB）填满的加载指令可能已经从内存中返回，但 VR 依然保持超前执行状态，直到处理完所有相关的加载指令。</p></li><li><p>无法适应运行时特征。Vector Runahead 尝试为每个标量负载生成尽可能多的收集。**目标是通过保持所有未命中状态保持寄存器 （MSHR） 被未完成的内存访问占用来实现高内存级并行性。**对于类似于广度优先搜索,循环长度与图的大小和结构相关,这意味着Vector Runahead 会预取大量数据，而这些数据在真实执行中永远不会被访问.</p></li></ol><p>​ <strong>VR 需要 （i） 了解它运行的每个循环的数据依赖性的动态迭代次数，以避免获取无用的数据，以及 （ii） 每次运行时更新它以响应最新的运行时值</strong></p><ol start=4><li>无法矢量化同个循环的多个调用.希望不仅从循环内部运行许多加载，而且同时从不同的外部循环运行许多不同版本的内循环。</li></ol><p>如果动态确定单个循环太小而无法使内存系统饱和，VR 需要提前查看同一循环的许多未来迭代，方法是向前跳以发现来自将在不久的将来执行的不同外部循环迭代的相同代码的输入。</p><ol start=5><li>在 <strong>Vector Runahead (VR)</strong> 执行中，控制流分歧（Control-Flow Divergence）是一个挑战. 一旦在矢量化指令集中发生控制流分歧，VR 将失去对所有分支路径的跟踪，无法继续执行预取操作. 就是if 的存在会使得直接跳出循环,使得后续的预取全部失效.</li></ol><p>GPU的单指令多线程(SIMT)模型,支持分支重合和分支分歧</p><p><strong>分支分歧</strong>：当某个矢量化通道在执行过程中遇到控制流分歧时，VR 可以允许每个通道独立地执行不同的路径，就像在 GPU 中，线程可以在遇到分支时分别执行不同的路径。</p><p><strong>分支重合</strong>：在分支结束后，VR 可以重新将所有矢量化通道合并到一个统一的控制流中，避免各个通道分支的不同执行路径对整体性能的影响。</p><h2 id=dvr微架构>DVR微架构</h2><p><figure class=gallery-image style=flex-grow:271;flex-basis:652px><a href=/2024/decoupled_vector_runahead/image-20241217210543320.png data-size=1348x496><img src=/2024/decoupled_vector_runahead/image-20241217210543320.png width=1348 height=496 srcset="/2024/decoupled_vector_runahead/image-20241217210543320_hu9939517555593631683.png 480w, /2024/decoupled_vector_runahead/image-20241217210543320_hu10285306206105120918.png 1024w" loading=lazy></a></figure></p><p>跨步检测器(stride detector)从管道的调度和执行(dispatch and execute)阶段获取有关负载的信息。一旦检测到跨步，DVR 就会进入发现模式(Discovery Mode)，该模式使用污点跟踪器和循环绑定检测器(Taint Tracker and Loop-Bound Detector)来发现后续运行的信息。如果发现模式发现循环中需要向量化的元素太少，则将使用嵌套发现模式(Nested Discovery Mode)逻辑。一旦发现模式完成，向量程序计数器 vector program counter (PCv) 将填充跨步加载的 PC，VRAT 将填充跨步加载地址和主线程标量寄存器的副本，以及解耦的向量运行子线程将启动。再收敛堆栈(Reconvergence Stack)将在矢量通道之间的控制流出现分歧时进行处理。</p><p>DVR 通过引入一个与主线程并行执行的 <strong>专用子线程</strong>，来预取未来的内存访问，从而在不干扰主线程执行的情况下提高性能。</p><p>核发现它正在执行具有相关负载的循环时，基于可用于预测未来循环迭代的跨步负载，将在与当前正在执行的主线程相同的内核上激活专用的 vector-runahead 子线程。此子线程是动态生成的，用于将许多内存访问预取到将来，但不会影响主线程的语义。vector-runahead 子线程在同一内核上与主线程一起运行，很像线程在同步多线程 （SMT） [91] 中协同执行的方式，不同之处在于子线程是微架构生成的、瞬态的（预取到缓存中而不是实现实际计算）、推测性的、重新排序以实现极高的内存级并行性，并且明显更简单，即子线程按顺序执行。</p><p>为了从这个按顺序向量运行子线程实现高内存级并行性，即使遵循使子线程停顿的依赖负载链，我们使用单指令多线程 （SIMT） 数据级并行性 [54]，从前端执行大量每条指令，每条指令同时代表不同的循环迭代，从而预取到很远的未来。由于这种情况是连续发生的，并且与主线程的执行重叠，因此大多数主乱序线程的内存访问在到达 L1 时都会命中 - 因此，即使对于具有巨大窗口的超大型处理器，也可以实现显著的加速。</p><h3 id=41-discovery-mode>4.1 Discovery Mode</h3><p>系统需要识别一个合适的诱导变量加载（induction-variable load），以便从中派生出多个未来循环的副本.这个过程首先通过检测一个<strong>步幅加载</strong>来开始，步幅加载是指访问内存时采用规律的地址序列（即具有可预测步幅的加载）。Discovery Mode的目的（i） 检查跨步负载是否是最适合 DVR 的候选者，通过成为最内层的跨步负载，（ii） 派生循环边界，以确定要生成多少个推测性向量预取，以及 （iii） 发现是否有任何基于跨步负载的依赖负载可以由 vector-runahead 子线程适当地预取。Discovery Mode 通过循环的一次迭代跟踪主线程的执行，直到它再次达到跨步加载，此时它退出 Discovery Mode。</p><h4 id=411-最内层步幅加载检测>4.1.1 最内层步幅加载检测</h4><p>一旦检测到初始的步幅加载并进入<strong>发现模式（Discovery Mode）</strong>，系统会继续跟踪主线程的执行，检测其他可能更适合启动向量超前执行的步幅加载。特别是，系统可能会发现某个步幅加载属于一个更内层的循环，且如果在向量超前执行模式下预取它们的未来迭代，这些加载将更加及时。因此，<strong>步幅加载检测</strong>的目标是识别最合适的内层循环加载。(对于内层循环,确实会更快的进入steady状态)</p><h5 id=步幅加载检测流程>步幅加载检测流程：</h5><ol><li><strong>使用参考预测表（RPT）</strong>： 步幅加载检测是通过使用**参考预测表（RPT）**来完成的。RPT跟踪所有步幅加载及其对应的步幅。RPT中保存了每个步幅加载的位图（bit-map），每个条目对应一个加载，且每个条目中有一位用于表示该步幅加载的状态。</li><li><strong>检测新步幅加载</strong>： 系统会保持一个寄存器，初始值为零，并且每个RPT条目都有一个对应的位。当一个步幅加载被检测到时，它会将对应的位设置为1。如果在<strong>发现模式</strong>中，在当前目标步幅加载之前，已经见过相同的步幅加载地址（程序计数器PC），并且对应位已经被设置为1，则表示这个新步幅加载属于一个更内层的循环。</li><li><strong>切换到更内层步幅加载</strong>： 当检测到新的步幅加载属于更内层循环时，系统会切换到该步幅加载上继续执行<strong>发现模式</strong>。这时需要重置之前的寄存器和其他相关的状态信息，如<strong>VTT</strong>（向量目标表）和<strong>FLR</strong>（加载结果队列），以确保新的步幅加载被正确处理。</li><li><strong>选择触发步幅</strong>： 系统可以在同一个循环中向量化多个步幅加载（例如，因循环展开导致的多个步幅加载）。在这种情况下，系统会选择一个步幅加载作为向量化的触发器，通常优先选择最内层的步幅加载，因为它会更频繁且更及时地被执行。</li></ol><h5 id=补充rpt>补充(RPT)</h5><p><figure class=gallery-image style=flex-grow:148;flex-basis:355px><a href=/2024/decoupled_vector_runahead/image-20241218114917559.png data-size=680x459><img src=/2024/decoupled_vector_runahead/image-20241218114917559.png width=680 height=459 srcset="/2024/decoupled_vector_runahead/image-20241218114917559_hu1241057847065859796.png 480w, /2024/decoupled_vector_runahead/image-20241218114917559_hu6107072329876365025.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:130;flex-basis:314px><a href=/2024/decoupled_vector_runahead/image-20241218115252006.png data-size=588x449><img src=/2024/decoupled_vector_runahead/image-20241218115252006.png width=588 height=449 srcset="/2024/decoupled_vector_runahead/image-20241218115252006_hu9025556592825104260.png 480w, /2024/decoupled_vector_runahead/image-20241218115252006_hu13549264763494486546.png 1024w" loading=lazy></a></figure></p><p>correct : addr = prev_addr + stride , incorrect : addr != prev_addr + stride</p><p>A.1.没有对应的条目。指令输入到RPT中，prev addr字段设置为addr，stride设置为0，state设置为initial</p><p>A.2.有相应的条目。然后：</p><p>When incorrect and state = initial , Set prev_addr to addr , stride to (addr - prev_addr) ,and state to transient</p><p>when correct and (state = initial ,transient , or steady), set prev_addr to addr , leave stride unchanged ,and set state to steady</p><p>when incorrect and state = steady: set prev_addr to addr , leave stride unchanged , and set state to initial</p><p>when incorrect and state = transient , set prev_addr to addr , stride to addr - prev_addr and state = no prediction</p><p>when correct and state = no prediction , set prev_addr to addr , leave stride unchange , and set state to transient</p><p>when incorrect and state = no prediction : set prev_addr to addr , stride to addr - prv_addr , and leave state unchanged</p><p>和分支预测类似, 在 steady 状态时,两次连续的错误才会修改 stride</p><p>在initial , transient , 和 steady状态如果miss会去启动预取</p><h4 id=412-依赖加载检查dependent-load-checking>4.1.2 依赖加载检查（Dependent-Load Checking）</h4><p>为了使向量超前执行（DVR）触发有意义，它必须带来比简单的步幅预取器更有用的数据到缓存中。我们假设系统中总会有一个步幅预取器，并且始终保持启用（即使向量超前执行并未触发）。这意味着，必须有更多依赖于通过步幅检测器识别出的值的加载操作，才有必要启动向量超前执行。</p><p>为此，我们使用一个小型的<strong>向量污染跟踪器</strong>（Vector Taint Tracker，VTT），它为每个架构整数寄存器分配一个比特位，以标识将来会被向量化的指令。</p><p><strong>初始化VTT</strong>： 在进入发现模式（Discovery Mode）时，VTT被初始化为全零，除了触发步幅加载的目标架构寄存器，该寄存器的位被设置为1。也就是说，我们将初始步幅加载指令的目标寄存器的污染位设置为1，表示该寄存器将在未来的指令中被使用并可能被向量化。</p><p><strong>污染传播</strong>： 在发现模式中，污染通过指令进行传播。具体来说，如果某条指令的源寄存器已经被污染（VTT中的比特位为1），那么该指令的目标寄存器的污染位会被设置为1。这样，后续的指令就知道它们依赖于先前的污染寄存器。</p><p><strong>重置污染位</strong>： 如果某条指令写入的寄存器的污染位已经设置为1，但它的源寄存器并未被污染，那么该目标寄存器的污染位会被重置为0。这是因为该指令并没有依赖于污染寄存器的内容，所以它不需要向量化。</p><p><strong>最终加载寄存器（FLR）</strong>： 每当某个加载指令的输入被污染时，最终加载寄存器（Final-Load Register，FLR）会更新为该加载指令的程序计数器（PC）。FLR用于跟踪<strong>从触发步幅加载</strong>开始的依赖链中最后一个加载指令的PC。</p><h4 id=413-循环边界推断loop-bound-inference>4.1.3 循环边界推断(Loop-Bound Inference)</h4><p>它决定了在 <strong>Discovery Mode</strong> 阶段，应该为当前内循环执行多少次预测性的向量预取（speculative vector prefetches）。</p><ol><li><p><strong>检测循环开始</strong>：</p><ul><li>在 <strong>Discovery Mode</strong> 中，首先会检测到一个向后跳转的分支（backward branch），这个分支指示一个循环的开始。</li><li>通过该分支的比较指令（compare instruction）来确定循环的边界（loop bound）。具体而言，这个比较指令提供了控制流是否应继续执行的依据，并且它的操作数会帮助推断循环的边界。</li></ul></li><li><p><strong>重要数据结构</strong>：</p><ul><li><strong>LCR (Last-Compare Register)</strong>：用于保存上一个比较指令的源和目标寄存器的 ID。</li><li><strong>SBB (Seen-Branch Bit)</strong>：这个标志位用于记录是否已经处理过这个分支。每次更新 <strong>Final-Load Register (FLR)</strong> 时，<strong>LCR</strong> 和 <strong>SBB</strong> 都会被清零。</li></ul></li><li><p><strong>检查比较指令与分支</strong>：</p><ul><li>当发现一个比较指令并且 <strong>SBB</strong> 为零时，会将比较指令的源和目标寄存器的 ID 存入 <strong>LCR</strong>。</li><li>如果后续遇到一个分支，且该分支的源寄存器与 <strong>LCR</strong> 中保存的目标寄存器相匹配，并且该分支跳转的目标地址小于或等于 <strong>striding load</strong> 的程序计数器（PC），则表示当前分支属于该循环，更新 <strong>SBB</strong>，以指示不再修改 <strong>LCR</strong>，直到发现新的最终加载指令。</li></ul></li><li><p><strong>循环边界推断</strong>：</p><ul><li><p>通过进入 <strong>Discovery Mode</strong> 和离开 <strong>Discovery Mode</strong> 时的两个检查点，我们可以查看寄存器文件的状态。</p></li><li><p>比较指令的输入寄存器的映射关系：</p><ul><li><p>如果其中一个寄存器在 Discovery Mode期间保持不变，而另一个发生了变化，我们就可以推断出：</p><ul><li><strong>常量值</strong>（不变寄存器的值）作为循环的边界（loop bound）。</li></ul></li><li><p><strong>变化值的差异</strong>（变化寄存器的值）作为循环的增量（loop increment）。</p></li></ul></li><li><p>通过这些信息，我们可以准确推测出循环的剩余迭代次数。</p></li></ul></li><li><p><strong>失败的情况</strong>：</p><ul><li>如果在 <strong>Discovery Mode</strong> 中无法找到合适的匹配（即没有找到合适的比较指令或者无法推断出循环的边界），则默认为执行 <strong>128 次迭代</strong>，这是 DVR 的最大迭代次数。</li></ul></li></ol><h3 id=42-vector-runahead-subthread-operation>4.2 Vector-Runahead Subthread Operation</h3><p>一旦发现模式识别出跨步负载、其跨步、其依赖链以及内部循环的剩余迭代，一旦主线程再次达到候选跨步负载，就会生成向量运行超前子线程。子线程从<strong>跨步加载开始，到存储在 FLR 中的 PC 结束</strong>，其目标是推测性地预取大量（在我们的设置中最多 128 个）矢量化副本。特别是，矢量化器通过使用其步幅生成的矢量化副本来替换步幅负载。未来指令流中依赖于跨步负载的任何指令也会被矢量化。</p><p>对于下面这一段程序,Vector Runahead thread 应该是从lw r4,0(r2)到 lw r7,0(r1)</p><p><figure class=gallery-image style=flex-grow:146;flex-basis:351px><a href=/2024/decoupled_vector_runahead/image-20241218161358613.png data-size=530x362><img src=/2024/decoupled_vector_runahead/image-20241218161358613.png width=530 height=362 srcset="/2024/decoupled_vector_runahead/image-20241218161358613_hu10767954509094571583.png 480w, /2024/decoupled_vector_runahead/image-20241218161358613_hu8519797815985386616.png 1024w" loading=lazy></a></figure></p><p>子线程使用与主线程相同的获取、解码和执行单元。子线程指令是从前端缓冲区生成的，前端缓冲区通过保存解码的微操作（在我们的设置中为八个）将提取阶段与管道的其余部分解耦。虽然子线程指令使用相同的执行单元，但它们使用不同的向量发出寄存器（VIR）——而不是乱序指令队列，因为它是有序的——来处理向量指令副本的执行。每当主线程没有为同一执行端口准备好指令时，就会发出向量运行子线程的发出寄存器中的指令。</p><h4 id=421-vector-register-allocation-table>4.2.1 Vector Register Allocation Table</h4><p>VRAT（向量寄存器分配表）用于管理子线程（Vector Runahead Subthread）的<strong>标量架构寄存器到物理寄存器</strong>的映射关系。即使子线程是有序的，我们仍然需要重命名它的架构寄存器，因为它与<strong>主线程共享物理标量和向量寄存器文件</strong>.标量架构寄存器可以重命名为 （i） 所有矢量通道中的相同标量物理寄存器，如果架构寄存器未矢量化且通道之间没有控制流发散，或 （ii） 多个矢量物理寄存器，其中架构寄存器已矢量化或存在控制流发散。</p><p>为了初始化 VRAT，主线程中的所有架构寄存器都分配了一个新的物理标量寄存器，以将子线程与其主线程解耦,当跨步负载被发送到 VIR 时，我们分配 16 个向量（例如 AVX-512）物理寄存器来映射负载的目标架构寄存器。与乱序处理器不同，物理寄存器不会随每条新指令重新映射，因为重命名不会试图删除 WAW 或 WAR 依赖项，即子线程按程序顺序执行。</p><p>物理寄存器被覆盖后(指的是它的值被后续的指令取代了)，将返回到空闲列表。被覆盖的寄存器会立即释放，前提是它们不用作发射指令的源寄存器,and tracked in the Vector Issue Register via the ‘dead-source’ bits</p><p><strong>VRAT 的寄存器分配规则</strong></p><ol><li><p><strong>子线程中寄存器的分配触发条件</strong> 子线程的物理寄存器分配只发生在以下两种情况：</p><ul><li><strong>源寄存器被向量化，但目标寄存器尚未向量化</strong>：
在这种情况下，目标寄存器需要分配 <strong>16 个空闲的向量物理寄存器</strong>。</li><li><strong>目标寄存器已被向量化，但即将被标量指令覆盖</strong>：
这种情况可能是由于原始代码中的写后写（WAW）依赖导致，目标寄存器会被分配到<strong>空闲标量物理寄存器</strong>。</li></ul></li><li><p><strong>处理控制流分歧</strong> 当由于<strong>分支跳转（Branch Divergence）</strong>，部分向量 lanes 被禁用时：</p><ul><li>只有相关的 lanes 的寄存器会被重命名，而非所有 lanes。</li></ul></li><li><p><strong>寄存器释放策略</strong></p><ul><li>当寄存器被覆盖时，立即将其归还到空闲列表，前提是它不再被用作源寄存器。</li></ul></li></ol><h4 id=422-vector-issue-register>4.2.2 Vector Issue Register</h4><p>为了实现比单个向量寄存器（8 个 64 位加载，如 AVX-512）显着更高程度的内存级并行性，我们重叠执行同一指令的多个向量副本，目标是实现 16 个 AVX -512 个向量（或 16 × 8 = 128 个标量等效循环）同时进行。我们不使用标量发布队列，而是使用单个向量发布寄存器 (VIR)，负责发布标量指令的每个向量副本（图 5）。</p><p>如果指令的所有 inputs 都是标量，则只发出一条标量指令。如果指令被标记为步幅加载，我们使用步幅检测器填充所有 128 个值，并将这些值作为 16 个矢量化 AVX-512 加载发出。如果指令依赖于至少一个矢量化输入，我们同样会按顺序向执行单元发出指令的 16 个矢量化副本。每当有合适的单元空闲时（主线程未使用），就会向执行单元发出矢量化指令副本。在一个 AVX-512 指令中，我们有 8 个掩码位，用于指示其中一个源被标记为无效的通道，无论是由于故障、使用浮点寄存器还是通过控制流发散。如果 Discovery Mode 的 loop-bound inference 预测它可以获取的标量等效循环将少于 128 个，则某些通道可能会以掩码 out 开始。一旦所有指令副本都发出并执行，如果在任何源上设置了 &lsquo;dead-source&rsquo; 位，则释放物理寄存器。然后，我们获取下一条指令，并重复。</p><p>矢量化加载指令被视为矢量收集操作[87]：它们在 LSQ 中被拆分为标量加载并发送到单独缓存层次结构。内存系统与其他常规标量加载同时处理它们，分配不同的 MSHR。</p><h4 id=423-branch-reconvergence>4.2.3 Branch Reconvergence.</h4><p>相关负载可能是有条件的，即它们出现在某些控制流路径上，而不是内循环内的其他路径上。我们允许每个标量等效车道与其他车道分开。因此，我们使用类似 **GPU 的再收敛堆栈。**所有活动通道中的分支结果都会相互比较。如果任何通道的下一个 PC 与其他通道不同，我们会根据新的目的地分割通道，根据公共组生成掩码，并将掩码和目标 PC 放置到重新收敛堆栈上。我们沿着第一条路径一直到达重新收敛点(是不是相同的指令地址?)，我们将其设置为矢量超前运行终止点（第 4.2.4 节），以避免特殊跟踪。一旦我们到达一组匹配通道的终止点，我们就会将头从再收敛堆栈中弹出，重置掩码，然后从堆栈中的下一个 PC 继续。</p><p>每个车道同时映射到 VRAT 中。如果我们在标量重命名中存在分歧（因为我们使用不同的标量），并且这种分歧整齐地发生在 AVX-512 指令边界上，那么我们会根据 16 个 AVX-512 指令中的哪一个使用它来覆盖每个标量。如果 AVX-512 指令中的标量重命名存在分歧，我们会将目标转换为 AVX-512 物理寄存器，并复制要替换的标量值。</p><h4 id=424-termination>4.2.4 Termination.</h4><p>当(1)通道到达序列中的最终间接负载（由 FLR 识别）时，或者(2)在发散的情况下达到步幅 PC 的下一次迭代时，向量运行子线程终止，并(3)具有 200 条指令超时（如果我们离开以循环绑定检测器未拾取的方式完全循环，例如，通过中断）。主线程与向量运行子线程同时执行。一旦子线程终止，主线程下次执行跨步加载时将再次有资格进入发现模式，从而重新启动 DVR。此时主线程将取得重大进展，并且如果 DVR 子线程准确且及时，其大部分缓存访问将成为 L1 命中。</p><h3 id=43-嵌套向量运行nested-vector-runahead>4.3 嵌套向量运行(Nested Vector Runahead)</h3><p><strong>Nested Vector Runahead</strong> 通过分析嵌套循环结构，对外层和内层循环<strong>联合向量化</strong>,来解决内层循环次数不够的问题</p><p>Nested Vector Runahead 分两步工作。首先，它执行嵌套发现模式 （NDM） 以将指令链从外部跨步负载矢量化到内部跨步负载，并发现循环边界和数据输入到内部循环的多个调用。其次，在到达 inner striding loop 时，它会进一步扩展矢量化以覆盖 inner loop。</p><h4 id=431-nested-discovery-mode>4.3.1 Nested Discovery Mode</h4><p>NDM 的目标是同时找到内部循环的许多不同调用的起始跨步地址和循环边界。discovery 模式（第 4.1 节）期间，loop-bound detector 可能会发现 loop 的 Approximate 迭代少于 64 次。在这种情况下，一旦生成了 vector-runahead 子线程，我们不是立即执行 vector runahead，而是用backward edge 改变分支的方向(把跳转转为不跳转,那就直接跑到外部去了)，并通过将PCv设置为分支后面的指令（未采用路径指令）来在in-order subthread上开始 NDM。子线程与主线程同时运行。仍然将两个 source registers 保存在 LCR 中。跨步负载的常数循环增量和地址分别保存在两个新寄存器中，分别称为增量寄存器 （IR） 和内部负载寄存器 （ILR）。</p><p>NDM 子线程开始执行标量操作，但由于分支方向更改而跳过内部循环的所有即将进行的迭代，并执行内部循环外部的指令。<strong>当它发现一个外跨步负载的地址小于 ILR 中的地址时（例如，算法 1 中的第 4 行与第 8 行），它执行第一个向量化步骤：它对跨步负载进行向量化（乘以 16，以尝试找到至少 128 个可行的内循环迭代）并在污点向量中标记负载的目的地。</strong></p><p>对于每个外部跨步负载的依赖项，矢量化过程继续进行，直到到达每个内部跨步负载的第一次迭代。在算法 1 中，第 4 行的外部跨步负载在第 5 行和第 6 行都有相关性。</p><p>当它达到 inner striding load （第 8 行） 时，它会读取 LCR 中源寄存器的矢量化副本的值，并使用这些值和 IR 中的值来计算每个矢量化 outer loops 的 inner loops 调用次数。如果在进入 NDM 后的 200 条指令内没有出现地址低于内跨步负载的外部跨步负载，则子线程将根据 LCR 和 IR 中的值重新计算循环边界，并通过循环边界对内部跨步负载进行矢量化。也就是说，子线程会回到 loop bound detector 在初始发现模式期间计算的迭代次数。 (LCR中保存cmp的源寄存器,在外部矢量化的时候,这个源寄存器也会被矢量化,通过这个值和)</p><p><figure class=gallery-image style=flex-grow:129;flex-basis:310px><a href=/2024/decoupled_vector_runahead/image-20241218205326943.png data-size=715x553><img src=/2024/decoupled_vector_runahead/image-20241218205326943.png width=715 height=553 srcset="/2024/decoupled_vector_runahead/image-20241218205326943_hu13753689612781104591.png 480w, /2024/decoupled_vector_runahead/image-20241218205326943_hu446235333281578278.png 1024w" loading=lazy></a></figure></p><h4 id=432-further-vectorization>4.3.2 Further Vectorization</h4><p>根据检测到的循环边界，NDM 子线程收集尽可能多的跨步内存地址，最多限于128个地址。超过前128个的地址将被丢弃。然后，NDM 子线程从内跨步加载开始执行向量化，通过将这些128个目标地址填充到其向量寄存器中，其他寄存器根据它是从哪个外循环的 16 个 lane 中生成的来设置（对于当前未污点的寄存器使用标量，对于在 NDM 中被污点的寄存器使用向量）。它将内跨步加载的目标标记为污点，并按照第 4.2 节所述，进入 DVR 模式，每个 lane 都会启动和终止。</p><h3 id=参考文献>参考文献</h3><p><a class=link href=https://www.xinhecuican.tech/post/8be42a2d.html target=_blank rel=noopener>向量寄存器和gpu</a></p><h3 id=版权信息>版权信息</h3><p>本文原载于 <a class=link href=https://vastcircle.github.io target=_blank rel=noopener>vastcircle.github.io</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/runahead/>Runahead</a>
<a href=/tags/vector/>Vector</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2024/vector_runahead/><div class=article-details><h2 class=article-title>Vector_runahead</h2></div></a></article><article><a href=/2024/scalar_runahead_execution/><div class=article-details><h2 class=article-title>Scalar_runahead_execution</h2></div></a></article><article><a href=/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/><div class=article-details><h2 class=article-title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2024 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了150.3k字·共 41篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#摘要>摘要</a></li><li><a href=#introduction>introduction</a></li><li><a href=#background>background</a><ol><li><a href=#间接内存访问-indirect-memory-accesses>间接内存访问 (Indirect Memory Accesses)</a></li><li><a href=#vector-runahead>Vector runahead</a></li></ol></li><li><a href=#motivation>Motivation</a><ol><li><a href=#vector-runahead-的劣势>Vector Runahead 的劣势</a></li></ol></li><li><a href=#dvr微架构>DVR微架构</a><ol><li><a href=#41-discovery-mode>4.1 Discovery Mode</a><ol><li><a href=#411-最内层步幅加载检测>4.1.1 最内层步幅加载检测</a></li><li><a href=#412-依赖加载检查dependent-load-checking>4.1.2 依赖加载检查（Dependent-Load Checking）</a></li><li><a href=#413-循环边界推断loop-bound-inference>4.1.3 循环边界推断(Loop-Bound Inference)</a></li></ol></li><li><a href=#42-vector-runahead-subthread-operation>4.2 Vector-Runahead Subthread Operation</a><ol><li><a href=#421-vector-register-allocation-table>4.2.1 Vector Register Allocation Table</a></li><li><a href=#422-vector-issue-register>4.2.2 Vector Issue Register</a></li><li><a href=#423-branch-reconvergence>4.2.3 Branch Reconvergence.</a></li><li><a href=#424-termination>4.2.4 Termination.</a></li></ol></li><li><a href=#43-嵌套向量运行nested-vector-runahead>4.3 嵌套向量运行(Nested Vector Runahead)</a><ol><li><a href=#431-nested-discovery-mode>4.3.1 Nested Discovery Mode</a></li><li><a href=#432-further-vectorization>4.3.2 Further Vectorization</a></li></ol></li><li><a href=#参考文献>参考文献</a></li><li><a href=#版权信息>版权信息</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/gem5/ class=category-list-link>gem5<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/linux/ class=category-list-link>linux<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>处理器<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ class=category-list-link>环境配置<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/ class=category-list-link>缓存一致性<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>7</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>12</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>41</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_5>Runahead
</a><a href=/tags/vector/ class=font_size_3>Vector
</a><a href=/tags/cache/ class=font_size_2>Cache
</a><a href=/tags/chipyard/ class=font_size_2>Chipyard
</a><a href=/tags/prefetch/ class=font_size_2>Prefetch
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名
</a><a href=/tags/%E6%8F%90%E4%BA%A4/ class=font_size_2>提交
</a><a href=/tags/hugo/ class=font_size_1>Hugo</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>