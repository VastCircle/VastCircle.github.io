<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='概述 只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令
'><title>发射</title>
<link rel=canonical href=https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/><link rel=stylesheet href=/scss/style.min.46208cabd58e8bcef0cfb7d7ea6b561adcca3b91dd1fc6657493a44f03c5db75.css><meta property='og:title' content='发射'><meta property='og:description' content='概述 只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令
'><meta property='og:url' content='https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/'><meta property='og:site_name' content="VastCircle's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='发射'><meta property='article:published_time' content='2024-10-19T20:25:19+08:00'><meta property='article:modified_time' content='2024-10-19T20:25:19+08:00'><meta name=twitter:title content="发射"><meta name=twitter:description content="概述 只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令
"><style>:root{--article-font-family:"Noto Serif SC", var(--base-font-family)}</style><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
<!--
extended
-->
on-phone--column extended"><div id=article-toolbar><a href=https://VastCircle.github.io/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span></a></div><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><a href=/><img src=/img/avatar_hu9516569771622178000.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><h1 class=site-name><a href=/>VastCircle's blog</a></h1><h2 class=site-description>To shine , not to be illuminated</h2><ol class=social-menu><li><a href=https://github.com/VastCircle target=_blank title=GitHub><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>friends</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/>超标量处理器</a></header><h2 class=article-title><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/>发射</a></h2><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 19, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-words>5136字</time></div></footer></div></header><section class=article-content><h2 id=概述>概述</h2><p>只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令</p><p>发射时序一般处在处理器的关键路径上,直接影响处理器的周期时间</p><p><figure class=gallery-image style=flex-grow:164;flex-basis:394px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png data-size=596x363><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png width=596 height=363 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu10933506266918888330.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu6047188780366288377.png 1024w" loading=lazy></a></figure></p><p>(1)发射队列(Issue Queue),用来存储已经被寄存器重命名,但是没有被送到FU执行的指令,也称为保留站(Reservation station)</p><p>(2)分配(allocation)电路,用来从发射队列中找到空闲的空间,将寄存器重命名之后的指令存储在其中</p><p>(3)选择电路(仲裁电路),发射队列中多条指令的操作数都准备好了,电路会按照一定规律,从其中找到最合适的指令,送到Fu中去</p><p>(4)唤醒电路,当一条指令经过FU执行而得到结果数据时,会将其通知给发射队列中所有等待数据的指令,指令对应的源寄存器就会被设置为有效的状态,即为唤醒.</p><h3 id=集中式-or-分布式发射队列>集中式 or 分布式发射队列</h3><p>如果所有FU共用一个发射队列,即为集中式发射队列(centralized issue queue,CIQ)</p><p>如果每一个FU都有单独的发射队列,称为分布式发射队列(Distributed issue queue,DIQ)</p><p>CIQ容量大,选择电路和唤醒电路复杂,电路利用率高</p><p>DIQ会出现一个发射队列满了,其他发射队列没有满,但是最终数据被阻塞的情况,就会出现效率低下的问题</p><h3 id=数据捕捉-or-非数据捕捉>数据捕捉 or 非数据捕捉</h3><p>寄存器的数据读取时间</p><h4 id=数据捕捉>数据捕捉</h4><p>流水线的发射阶段之前读取寄存器,被寄存器重命名的指令会先读取物理寄存器堆,然后将读取到的值一起写入到发射队列,没有被计算出来的数据会以编号的形式写入,供唤醒时使用,会被标记为无法获得状态(non-available),这些值会通过旁路网络获取.在发射队列中,存储指令操作数的地方称为payload RAM</p><p>一条指令被仲裁电路选中发射到FU中去,它会将目标寄存器进行广播,其他在发射队列的指令就会去对比,有相等的情况时就会在payload RAM进行标记,在FU计算完成之后会写入到payload RAM 对应的位置 .</p><p><figure class=gallery-image style=flex-grow:249;flex-basis:598px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png data-size=776x311><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png width=776 height=311 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu17079656071217617578.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu4889682781684174770.png 1024w" loading=lazy></a></figure></p><p>machine width : 每周期实际解码和重命名的指令个数</p><p>issue width : 每周期最多可以在FU中并行执行的指令个数</p><p>在RISC 里 machine width &lt;= issue width</p><p>物理寄存器的端口数 = machine width * 2</p><p><figure class=gallery-image style=flex-grow:109;flex-basis:262px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png data-size=482x441><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png width=482 height=441 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu9745096111898785255.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu6496583278703640029.png 1024w" loading=lazy></a></figure></p><p>大多数源操作数会经历两读1写,从寄存器读取出来,送到发射队列,从发射队列中读取送到FU ,功耗高 ,面积大</p><p>寄存器重命名方便 ,指令在顺利离开流水线的时候,需要将结果从重排序缓存中搬移到ARF中,采用数据捕捉的方式可以不用惯性指令结果的变化??????</p><h4 id=非数据捕捉>非数据捕捉</h4><p>在发射阶段之后读取物理寄存器堆,被重命名之后的指令不去读取物理寄存器堆,而是直接将源寄存器堆的编号放到发射队列中去.当指令被选中时,通过编号读取物理寄存器堆,将读取值送到FU中</p><p>寄存器堆的读端口 = issue width ,比较大</p><p><figure class=gallery-image style=flex-grow:116;flex-basis:278px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png data-size=543x468><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png width=543 height=468 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu17049688566279640447.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu12853474364071027865.png 1024w" loading=lazy></a></figure></p><h3 id=压缩-or-非压缩>压缩 or 非压缩</h3><h4 id=压缩>压缩</h4><p>当一条指令被选中离开发射队列之后,指令上面所有的指令都会下移一格</p><p><figure class=gallery-image style=flex-grow:177;flex-basis:425px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png data-size=620x350><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png width=620 height=350 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu11413087233639779848.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu6794216728322161169.png 1024w" loading=lazy></a></figure></p><p>通过多路选择器进行压缩</p><p><figure class=gallery-image style=flex-grow:230;flex-basis:554px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png data-size=702x304><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png width=702 height=304 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu14122326088059142316.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu10310402141209563975.png 1024w" loading=lazy></a></figure></p><p>这种方式选择电路比较简单,通过优先编码选择最旧的就行了,oldest-first方法 ,但是选择电路的延时很长</p><p><figure class=gallery-image style=flex-grow:162;flex-basis:390px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png data-size=512x315><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png width=512 height=315 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu10969826154039478454.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu1981833134611443612.png 1024w" loading=lazy></a></figure></p><p>优点如下:</p><p>1.分配电路简单,发射队列中的空闲空间总是处于上层,只需要使用发射队列的写指针,指向第一个空闲空间</p><p>2.选择电路简单.最旧的指令存在的RAW相关性也越多,先执行可以最大程度释放和它存在RAW相关性的指令</p><p>但是</p><p>1.实现起来浪费面积</p><p>2.功耗大</p><h4 id=非压缩>非压缩</h4><p>没有移动</p><h2 id=发射过程中的流水线>发射过程中的流水线</h2><h3 id=非数据捕捉结构的流水线>非数据捕捉结构的流水线</h3><p>要被FU执行</p><p>(1)指令所有的源操作数准备好了</p><p>(2)指令被发射队列选中</p><p>(3)能够从寄存器,payload RAM或者旁路网络获得源操作数</p><p>下图发射过程被分为了唤醒(wake-up)和仲裁(Select)两个流水线阶段</p><p>唤醒阶段,发射队列中的所有相关寄存器会被置为准备好的状态</p><p>仲裁阶段,会使用仲裁电路选择一条最合适的指令送到FU中</p><p><figure class=gallery-image style=flex-grow:357;flex-basis:857px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png data-size=836x234><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png width=836 height=234 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu13578928480996287574.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu15483047359496982778.png 1024w" loading=lazy></a></figure></p><p>tomasulo算法:在指令执行完才对相关指令进行唤醒</p><p>可以通过将唤醒过程提前来获得更高性能</p><p>即在指令A被仲裁电路选中后就对其他寄存器进行唤醒,这样指令B在下一个周期就能够被仲裁</p><p><figure class=gallery-image style=flex-grow:267;flex-basis:643px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png data-size=611x228><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png width=611 height=228 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu12261158574036134191.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu15538349812895092404.png 1024w" loading=lazy></a></figure></p><p>意思是 Select 和 wake-up应该是在同一个周期的串行,A被唤醒才能够去selectB</p><p>这种操作称为"原子的"</p><p><figure class=gallery-image style=flex-grow:210;flex-basis:504px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png data-size=818x389><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png width=818 height=389 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu14381474285825173627.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu7271168370352068712.png 1024w" loading=lazy></a></figure></p><p>拆分流水线可以使得主频升高,但是</p><p>(1)分支预测失败,惩罚增加</p><p>(2)cache访问的周期数增加</p><p>(3)功耗增大</p><p>以上是假设执行是一个周期,实际上并不止</p><h3 id=数据捕捉结构的流水线>数据捕捉结构的流水线</h3><p><figure class=gallery-image style=flex-grow:237;flex-basis:568px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png data-size=858x362><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png width=858 height=362 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu7642558332426759119.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu738880975121771762.png 1024w" loading=lazy></a></figure></p><p>可以把select和payload放在同一个流水段 ,在指令被仲裁电路选中之后,在同一个周期对发射队列其他的指令进行唤醒,同时去读取payload RAM,这两个操作是并行进行的,在这个流水段还会负责payload RAM的读取和写入,会导致处理器的周期时间变得过大.</p><p>旁路网络这样是啥意思????</p><p>另一种设计方式是把payload单独放成一个流水段,旁路和执行分成两个流水段,在旁路阶段,FU的结果会被送到payload RAM和FU的输入端</p><p><figure class=gallery-image style=flex-grow:241;flex-basis:579px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png data-size=799x331><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png width=799 height=331 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu15363317278529565932.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu3440636031536888040.png 1024w" loading=lazy></a></figure></p><h2 id=分配>分配</h2><p>对于非压缩的方式设计的发射队列,需要分配电路扫描整个发射队列,找到四个空闲的表项并将四条指令写入</p><p><figure class=gallery-image style=flex-grow:111;flex-basis:268px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png data-size=478x427><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png width=478 height=427 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu915797298984400432.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu13892753167635664755.png 1024w" loading=lazy></a></figure>可以使用一个表格来记录所有空闲表项的编号,按照FIFO的方式管理,也可以简单把发射队列分为多个部分,每个段选一个空闲编号,但是会出现问题就是如果有一个表项非空的话,会阻碍其他指令的放入,甚至由于在寄存器重命名阶段是in-order状态A的无法放入会导致后续指令都无法放入</p><p><figure class=gallery-image style=flex-grow:117;flex-basis:282px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png data-size=529x450><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png width=529 height=450 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu16173649002378560098.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu10959566968097053341.png 1024w" loading=lazy></a></figure></p><h2 id=仲裁>仲裁</h2><p>最好实现oldest-first功能的仲裁</p><h3 id=1-of-m仲裁>1-of-M仲裁</h3><p>可以通过指令在ROB中的位置作为指令的年龄信息,但是由于ROB是一个循环队列,所有单纯的地址是无法表征年龄的</p><p><figure class=gallery-image style=flex-grow:387;flex-basis:930px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png data-size=834x215><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png width=834 height=215 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu11734813543713119581.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu2948785691697860533.png 1024w" loading=lazy></a></figure></p><p>其实我觉得,直接比较读写地址可以的吧,读指针 > 写指针 , 下新上旧 , 读指针 &lt; 写指针 , 上新下旧 ,其实读指针 > 写的时候,也代表两者不是一面的</p><p>可以在ROB中地址前面再加入一位,称为位置值.想当于对于读写地址又加了一位</p><p><figure class=gallery-image style=flex-grow:83;flex-basis:199px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png data-size=333x400><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png width=333 height=400 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu8819546655997073234.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu10037926471509499272.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:121;flex-basis:292px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png data-size=550x451><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png width=550 height=451 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu12240918921388596847.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu6071650023988884185.png 1024w" loading=lazy></a></figure></p><p>(1)位置值相同时,ROB地址越小,对应的指令越旧</p><p>(2)位置值不同时,ROB地址越大,对应的指令越旧,比方说情况2的 0 10 与 1 01 比较,明显是0 10 旧</p><p>先根据是否rdy选出指令,再根据年龄进行筛选</p><p>二分</p><p><figure class=gallery-image style=flex-grow:160;flex-basis:385px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png data-size=472x294><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png width=472 height=294 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu15299360207959238160.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu12909387690140829006.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:128;flex-basis:307px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png data-size=806x629><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png width=806 height=629 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu1482760444792659261.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu4089846200509570806.png 1024w" loading=lazy></a></figure></p><p>该电路能够得到最小的年龄值,但是还需要得到最小年龄值对应的指令,最方便的是将指令信息也一同附上去</p><p><figure class=gallery-image style=flex-grow:145;flex-basis:350px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png data-size=496x340><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png width=496 height=340 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu10454207305702131865.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu4651879014994689033.png 1024w" loading=lazy></a></figure></p><h3 id=n-of-m-仲裁电路>N of M 仲裁电路</h3><p>几个FU共用一个发射队列,发射队列需要在一个周期内为没一个FU选择出一条指令,就要求有一个N of M的仲裁电路</p><p>可以通过两级仲裁电路实现,第一级选择一条指令后对第二级进行标记,但是这样延时极大</p><p><figure class=gallery-image style=flex-grow:172;flex-basis:414px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png data-size=601x348><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png width=601 height=348 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu14705004795844087432.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu18352542851947980875.png 1024w" loading=lazy></a></figure></p><p>对每一个FU使用一个1 of M的仲裁器, 根据指令类型进行分类,这样就会存在相同类型的指令会阻塞或者一部分FU处在空闲状态的问题</p><p>可以通过增加FU的数量解决上述问题,但是比方数两个ALU,指令该分配给哪个ALU又是一个问题,可以通过轮换分配法实现,但是这样是无法保证严格的oldest-first原则的,而且有可能会浪费FU资源</p><p><figure class=gallery-image style=flex-grow:268;flex-basis:645px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png data-size=828x308><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png width=828 height=308 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu5869953476708852689.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu13988473186677534807.png 1024w" loading=lazy></a></figure></p><p>一般来说,加减法,逻辑运算,移位运算合成一个FU,</p><p>惩罚和除法合成一个,</p><p>访问存储器和访问协处理器合并在一起,</p><p>浮点运算合并在一起</p><h2 id=唤醒>唤醒</h2><h3 id=单周期的唤醒>单周期的唤醒</h3><p>唤醒是指被仲裁器选中的指令将目的寄存器的编号(dst_tag)和发射队列中所有源寄存器的编号进行比较,并将那些比较结果相等的源寄存器进行标记的过程</p><p>下面的电路是所有仲裁电路共享一个发射队列的情况, 所以发射队列只会接受到一个响应,因为同一时刻肯定只有一条指令被仲裁,每个FU都会使用一个仲裁电路</p><p><figure class=gallery-image style=flex-grow:209;flex-basis:503px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png data-size=881x420><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png width=881 height=420 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu12195273095659706992.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu9126926194952235300.png 1024w" loading=lazy alt=image-20241020213306752></a><figcaption>image-20241020213306752</figcaption></figure></p><p>(1)ValL:指令中是否存在第一个源寄存器</p><p>(2)SrcL:指令中第一个源寄存器的编号</p><p>(3)RdyL:指令中第一个源寄存器是否已经被唤醒而处于准备好的状态</p><p>(4)ValR:第二个</p><p>(5)Dest:目的寄存器的编号</p><p>(6)Issued:一条指令被仲裁电路选中之后,可能不会马上离开发射队列,需要进行标记,这样的指令不会向仲裁电路发出请求信号</p><p>为什么有四个仲裁电路?????是不是指多个FU,但是多个FU不是应该可以接受多个请求</p><p>发射队列的每一个表项都会根据四个响应信号的值,将自身的目的寄存器编号送到对应的总线上去,每个仲裁电路对应一个总线</p><ol><li>被仲裁电路选择的指令会将它的目的寄存器编号送到对应的总线上</li><li>每一条总线的值会和发射队列中所有指令的源寄存器的编号进行比较,如果发现相等,标记为准备好的状态</li><li>当发射队列某条指令的操作数都准备好了,并且没有被仲裁电路选中过,就可以想仲裁电路发送请求信号</li><li>如果仲裁电路发现有更高优先级的指令发出请求,当前指令不会得到有效响应信号,需要再之后的周期继续发送请求信号.在一些设计中,可以轮流向多个仲裁电路发送请求.如果从仲裁电路中得到有效信号,就会吧issued置位.一条被选中的指令不会立刻离开发射队列,因为一个指令如果使用了load指令的结果,即使被仲裁电路选中,也不能离开</li><li>发射队列的指令更具响应信号,,把目的寄存器编号送到对应总线上去,用来唤醒发射队列中所有相关的源寄存器</li></ol><h3 id=多周期的唤醒>多周期的唤醒</h3><p>单周期的唤醒能够在一个周期被FU执行完毕,但是当一条指令无法在一个周期执行完毕时,需要根据她在FU中的周期数,将唤醒过程延迟</p><p>根据唤醒的过程</p><h4 id=延迟广播>延迟广播.</h4><p>发现被仲裁电路选中的指令执行周期大于1,则在选中的当前周期,不讲指令的目的寄存器编号送到总线上,而是根据选中指令需要执行的周期数(N),延迟N-1周期,才送到总线上去</p><p><figure class=gallery-image style=flex-grow:490;flex-basis:1176px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png data-size=838x171><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png width=838 height=171 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu3236811294374040669.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu5826633055030736483.png 1024w" loading=lazy></a></figure></p><p>延迟广播之后可能出现tag bus产生冲突,比方说下面的MUL和ADD在同一时刻需要将目的寄存器的值送到tag broadcast bus上</p><p><figure class=gallery-image style=flex-grow:290;flex-basis:696px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png data-size=836x288><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png width=836 height=288 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu16861531667843717354.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu3627428205873869122.png 1024w" loading=lazy></a></figure></p><p>可以通过增加总线的数量,也可以利用表格,记录下FU执行指令所需要的周期数,被仲裁电路选中的指令,如果发现冲突,被选中的指令不会送到FU中执行,而是在下一个周期继续参与仲裁</p><p>但是还是存在一个问题,就是指令B被否决(cycle 1),本身指令C是可以被仲裁的,但是C比B要新,所以这个周期被浪费掉了,所以可以先检查是否冲突,如果冲突的话就不向仲裁电路发起请求了(不发请求很奇怪啊,发请求在仲裁的时候否决行不行),但是这样访问网络和仲裁电路是串行的</p><p><figure class=gallery-image style=flex-grow:168;flex-basis:403px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png data-size=580x345><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png width=580 height=345 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu3250847906907956578.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu13178792662719264520.png 1024w" loading=lazy></a></figure></p><h4 id=延迟唤醒>延迟唤醒</h4><p>最优解就就是要去实现背对背执行,一条指令的执行和后一条指令的执行是先后的</p><p>在比较结果相等时,不马上置为准备好的状态,而是根据指令所需要的执行周期数,进行相应周期的延时,然后再改变发射队列中源寄存器的状态</p><p><figure class=gallery-image style=flex-grow:237;flex-basis:570px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png data-size=632x266><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png width=632 height=266 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu13815543178213961515.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu9998523058420159875.png 1024w" loading=lazy></a></figure></p><p><figure class=gallery-image style=flex-grow:408;flex-basis:979px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png data-size=816x200><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png width=816 height=200 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu12597106233390159010.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu3885520225871445685.png 1024w" loading=lazy></a></figure></p><p>通过移位寄存器实现延迟唤醒的效果.在解码阶段对每条指令执行周期数进行编码,称为DELAY,在将目的寄存器送到总线外,还需要将DELAY值也送到总线上去.称为DELAY bus .</p><p>Freed :表项是否空闲</p><p>Issued:指令是否被仲裁电路选择</p><p>SrcL:第一个源寄存器编号</p><p>SrcL_M:当寄存器编号比较结果相等时,置1;当接收到仲裁电路的响应信号后,清0,它是移位寄存器进行算数右移的使能标志</p><p>SrcL_SHIFT:移位寄存器,当编号比较结果相等时,将DELAY写入移位寄存器,每周期进行算数右移</p><p>Rdy:表示第一个源寄存器是否准备好了</p><p>SrcR_imm_valid :表示第二个操作数是否是立即数</p><p>ROB ID:指令在ROB的位置,使得其能够实现oldest-first选择</p><p>编码形式是类似于11111000(8位),在经过3个算数右移之后最低位就是1,就是Rdy=1</p><p>直到被仲裁电路响应或者说选择之后,SrcL_M,srcL_SHIFT都会清零,其他时候Rdy都会保持着1的状态发送请求,直到被仲裁</p><p><figure class=gallery-image style=flex-grow:153;flex-basis:368px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046.png data-size=847x552><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046.png width=847 height=552 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046_hu3664706843096973520.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046_hu17387076878035751376.png 1024w" loading=lazy></a></figure></p><h3 id=推测唤醒>推测唤醒</h3><p>对于某些指令,指令在FU中执行的周期数是可以被预测的,这样才可能分配一个确定的DELAY值</p><p>但是对于</p><p>(1)Load指令</p><p>(2)某些处理器的特殊情况,例如RowerPC 603处理器存在early out,即当被除数值比较小时能够被提前预测指令</p><p>比较简单的方法就是等指令执行完了之后再去唤醒其他指令</p><p><figure class=gallery-image style=flex-grow:345;flex-basis:828px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731.png data-size=787x228><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731.png width=787 height=228 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731_hu13555257517852508750.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731_hu3376860337472421188.png 1024w" loading=lazy></a></figure></p><p>可以优化一下就是一般load指令在第一个周期计算地址,第二个周期访问Tag SRAM,第三个周期将读取到的数据写入目的寄存器,所以在第二个周期就可以判断,命中后去唤醒</p><p><figure class=gallery-image style=flex-grow:304;flex-basis:730px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962.png data-size=654x215><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962.png width=654 height=215 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962_hu15428221746190009120.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962_hu17889552520785745816.png 1024w" loading=lazy></a></figure></p><p>假设d-cache是一直命中的,就能够得到一个比较理想的情况<figure class=gallery-image style=flex-grow:287;flex-basis:690px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840.png data-size=633x220><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840.png width=633 height=220 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840_hu15789197913931500280.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840_hu5995376768543292965.png 1024w" loading=lazy></a></figure></p><p>但是一旦指令A发生了D-cache缺失,此时B就不能停住而等待操作数,这样会使得FU无法接受其他新指令,严重影响处理器的性能.最好的办法是将指令B重新放回发射队列(Issue Queue),因为load指令在D-cache缺失之后,会到L2 cache寻找数据,此时可以假设L2 cache是命中的,并按照命中时间重新对相关寄存器进行唤醒,还是使用延迟唤醒</p><p><figure class=gallery-image style=flex-grow:244;flex-basis:587px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840.png data-size=798x326><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840.png width=798 height=326 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840_hu12103557051335753409.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840_hu10406948929904864418.png 1024w" loading=lazy></a></figure></p><p>对于不确定周期的指令,可以去预测指令执行的周期数,在指令得到结果之前,对相关的指令进行唤醒操作</p><p>预测成功就执行,预测失败就去进行状态会被,被唤醒的所有寄存器需要重新设置为(not ready)状态,如果一些指令离开了发射队列,还需要从流水线中抹去,放回发射队列</p><p><figure class=gallery-image style=flex-grow:283;flex-basis:681px><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769.png data-size=724x255><img src=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769.png width=724 height=255 srcset="/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769_hu17984726890091083280.png 480w, /2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769_hu12546290877630753377.png 1024w" loading=lazy></a></figure></p><p>未完待续</p><h2 id=附录>附录</h2><h3 id=参考文献>参考文献</h3><h3 id=版权信息>版权信息</h3><p>本文原载于 <a class=link href=https://vastcircle.github.io target=_blank rel=noopener>vastcircle.github.io</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%8F%91%E5%B0%84/>发射</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/><div class=article-details><h2 class=article-title>虚拟存储器</h2></div></a></article><article><a href=/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/><div class=article-details><h2 class=article-title>rocket-src微架构代码解读</h2></div></a></article><article><a href=/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/><div class=article-details><h2 class=article-title>提交</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/3.3.0/pangu.min.js",function(){pangu.spacingPage()})</script><section class=copyright>&copy;
2023 -
2024 <a href=https://stack-theme-mod.vercel.app/>vastcircle</a>·<i class="fas fa-bell"></i> <a id=days>0</a>Days<br>共书写了62.5k字·共 23篇文章</br><span><p></section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>© Licensed Under CC BY-NC-SA 4.0</a></section><script>var days,number_of_days,s1="2024-10-06",s1=new Date(s1.replace(/-/g,"/"));s2=new Date,days=s2.getTime()-s1.getTime(),number_of_days=parseInt(days/(1e3*60*60*24)),document.getElementById("days").innerHTML=number_of_days</script></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>Search</label>
<input name=keyword required placeholder="Type something...">
<button title=Search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#概述>概述</a><ol><li><a href=#集中式-or-分布式发射队列>集中式 or 分布式发射队列</a></li><li><a href=#数据捕捉-or-非数据捕捉>数据捕捉 or 非数据捕捉</a><ol><li><a href=#数据捕捉>数据捕捉</a></li><li><a href=#非数据捕捉>非数据捕捉</a></li></ol></li><li><a href=#压缩-or-非压缩>压缩 or 非压缩</a><ol><li><a href=#压缩>压缩</a></li><li><a href=#非压缩>非压缩</a></li></ol></li></ol></li><li><a href=#发射过程中的流水线>发射过程中的流水线</a><ol><li><a href=#非数据捕捉结构的流水线>非数据捕捉结构的流水线</a></li><li><a href=#数据捕捉结构的流水线>数据捕捉结构的流水线</a></li></ol></li><li><a href=#分配>分配</a></li><li><a href=#仲裁>仲裁</a><ol><li><a href=#1-of-m仲裁>1-of-M仲裁</a></li><li><a href=#n-of-m-仲裁电路>N of M 仲裁电路</a></li></ol></li><li><a href=#唤醒>唤醒</a><ol><li><a href=#单周期的唤醒>单周期的唤醒</a></li><li><a href=#多周期的唤醒>多周期的唤醒</a><ol><li><a href=#延迟广播>延迟广播.</a></li><li><a href=#延迟唤醒>延迟唤醒</a></li></ol></li><li><a href=#推测唤醒>推测唤醒</a></li></ol></li><li><a href=#附录>附录</a><ol><li><a href=#参考文献>参考文献</a></li><li><a href=#版权信息>版权信息</a></li></ol></li></ol></nav></div></section><section class="widget categories"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Categories</h2><div class=widget-categories--list><div class=widget><h3 class=widget-title></h3><div class=widget-body><div class=category-list><div class=category-list-item><a href=https://VastCircle.github.io/categories/chipyard/ class=category-list-link>chipyard<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/cpu%E5%9F%BA%E7%A1%80/ class=category-list-link>cpu基础<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/rocket-chip/ class=category-list-link>rocket-chip<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/runahead/ class=category-list-link>runahead<span class=category-list-count>3</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/ class=category-list-link>代码阅读<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ class=category-list-link>博客搭建<span class=category-list-count>1</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=category-list-link>论文阅读<span class=category-list-count>2</a></span></div><div class=category-list-item><a href=https://VastCircle.github.io/categories/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/ class=category-list-link>超标量处理器<span class=category-list-count>11</a></span></div></div></div></div></div></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg></div><h2 class="widget-title section-title">Archives</h2><div class=widget-archive--list><div class=archives-year><a href=/archives/#2024><span class=year>2024</span>
<span class=count>23</span></a></div></div></section><section class="widget tagCloud"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg></div><h2 class="widget-title section-title">Tags</h2><div class=tagCloud-tags><a href=/tags/runahead/ class=font_size_3>Runahead
</a><a href=/tags/rocket-chip/ class=font_size_2>Rocket-Chip
</a><a href=/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/ class=font_size_2>分支预测
</a><a href=/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D/ class=font_size_2>寄存器重命名
</a><a href=/tags/%E6%8F%90%E4%BA%A4/ class=font_size_2>提交
</a><a href=/tags/chipyard/ class=font_size_1>Chipyard
</a><a href=/tags/hugo/ class=font_size_1>Hugo
</a><a href=/tags/in-order/ class=font_size_1>In-Order
</a><a href=/tags/scala/ class=font_size_1>Scala
</a><a href=/tags/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C/ class=font_size_1>乱序执行</a></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>