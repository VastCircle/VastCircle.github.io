<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>VastCircle's blog</title><link>https://VastCircle.github.io/</link><description>Recent content on VastCircle's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 19 Oct 2024 20:25:19 +0800</lastBuildDate><atom:link href="https://VastCircle.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>发射(概述+流水线+分配)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</link><pubDate>Sat, 19 Oct 2024 20:25:19 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令&lt;/p>
&lt;p>发射时序一般处在处理器的关键路径上,直接影响处理器的周期时间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 164;
flex-basis: 394px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png" data-size="596x363">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png"
width="596"
height="363"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu10933506266918888330.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu6047188780366288377.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)发射队列(Issue Queue),用来存储已经被寄存器重命名,但是没有被送到FU执行的指令,也称为保留站(Reservation station)&lt;/p>
&lt;p>(2)分配(allocation)电路,用来从发射队列中找到空闲的空间,将寄存器重命名之后的指令存储在其中&lt;/p>
&lt;p>(3)选择电路(仲裁电路),发射队列中多条指令的操作数都准备好了,电路会按照一定规律,从其中找到最合适的指令,送到Fu中去&lt;/p>
&lt;p>(4)唤醒电路,当一条指令经过FU执行而得到结果数据时,会将其通知给发射队列中所有等待数据的指令,指令对应的源寄存器就会被设置为有效的状态,即为唤醒.&lt;/p>
&lt;h3 id="集中式-or-分布式发射队列">集中式 or 分布式发射队列&lt;/h3>
&lt;p>如果所有FU共用一个发射队列,即为集中式发射队列(centralized issue queue,CIQ)&lt;/p>
&lt;p>如果每一个FU都有单独的发射队列,称为分布式发射队列(Distributed issue queue,DIQ)&lt;/p>
&lt;p>CIQ容量大,选择电路和唤醒电路复杂,电路利用率高&lt;/p>
&lt;p>DIQ会出现一个发射队列满了,其他发射队列没有满,但是最终数据被阻塞的情况,就会出现效率低下的问题&lt;/p>
&lt;h3 id="数据捕捉-or-非数据捕捉">数据捕捉 or 非数据捕捉&lt;/h3>
&lt;p>寄存器的数据读取时间&lt;/p>
&lt;h4 id="数据捕捉">数据捕捉&lt;/h4>
&lt;p>流水线的发射阶段之前读取寄存器,被寄存器重命名的指令会先读取物理寄存器堆,然后将读取到的值一起写入到发射队列,没有被计算出来的数据会以编号的形式写入,供唤醒时使用,会被标记为无法获得状态(non-available),这些值会通过旁路网络获取.在发射队列中,存储指令操作数的地方称为payload RAM&lt;/p>
&lt;p>一条指令被仲裁电路选中发射到FU中去,它会将目标寄存器进行广播,其他在发射队列的指令就会去对比,有相等的情况时就会在payload RAM进行标记,在FU计算完成之后会写入到payload RAM 对应的位置 .&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 249;
flex-basis: 598px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png" data-size="776x311">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png"
width="776"
height="311"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu17079656071217617578.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu4889682781684174770.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>machine width : 每周期实际解码和重命名的指令个数&lt;/p>
&lt;p>issue width : 每周期最多可以在FU中并行执行的指令个数&lt;/p>
&lt;p>在RISC 里 machine width &amp;lt;= issue width&lt;/p>
&lt;p>物理寄存器的端口数 = machine width * 2&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 109;
flex-basis: 262px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png" data-size="482x441">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png"
width="482"
height="441"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu9745096111898785255.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu6496583278703640029.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>大多数源操作数会经历两读1写,从寄存器读取出来,送到发射队列,从发射队列中读取送到FU ,功耗高 ,面积大&lt;/p>
&lt;p>寄存器重命名方便 ,指令在顺利离开流水线的时候,需要将结果从重排序缓存中搬移到ARF中,采用数据捕捉的方式可以不用惯性指令结果的变化??????&lt;/p>
&lt;h4 id="非数据捕捉">非数据捕捉&lt;/h4>
&lt;p>在发射阶段之后读取物理寄存器堆,被重命名之后的指令不去读取物理寄存器堆,而是直接将源寄存器堆的编号放到发射队列中去.当指令被选中时,通过编号读取物理寄存器堆,将读取值送到FU中&lt;/p>
&lt;p>寄存器堆的读端口 = issue width ,比较大&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 278px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png" data-size="543x468">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png"
width="543"
height="468"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu17049688566279640447.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu12853474364071027865.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="压缩-or-非压缩">压缩 or 非压缩&lt;/h3>
&lt;h4 id="压缩">压缩&lt;/h4>
&lt;p>当一条指令被选中离开发射队列之后,指令上面所有的指令都会下移一格&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 177;
flex-basis: 425px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png" data-size="620x350">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png"
width="620"
height="350"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu11413087233639779848.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu6794216728322161169.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过多路选择器进行压缩&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 230;
flex-basis: 554px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png" data-size="702x304">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png"
width="702"
height="304"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu14122326088059142316.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu10310402141209563975.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>这种方式选择电路比较简单,通过优先编码选择最旧的就行了,oldest-first方法 ,但是选择电路的延时很长&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 162;
flex-basis: 390px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png" data-size="512x315">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png"
width="512"
height="315"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu10969826154039478454.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu1981833134611443612.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>优点如下:&lt;/p>
&lt;p>1.分配电路简单,发射队列中的空闲空间总是处于上层,只需要使用发射队列的写指针,指向第一个空闲空间&lt;/p>
&lt;p>2.选择电路简单.最旧的指令存在的RAW相关性也越多,先执行可以最大程度释放和它存在RAW相关性的指令&lt;/p>
&lt;p>但是&lt;/p>
&lt;p>1.实现起来浪费面积&lt;/p>
&lt;p>2.功耗大&lt;/p>
&lt;h4 id="非压缩">非压缩&lt;/h4>
&lt;p>没有移动&lt;/p>
&lt;h2 id="发射过程中的流水线">发射过程中的流水线&lt;/h2>
&lt;h3 id="非数据捕捉结构的流水线">非数据捕捉结构的流水线&lt;/h3>
&lt;p>要被FU执行&lt;/p>
&lt;p>(1)指令所有的源操作数准备好了&lt;/p>
&lt;p>(2)指令被发射队列选中&lt;/p>
&lt;p>(3)能够从寄存器,payload RAM或者旁路网络获得源操作数&lt;/p>
&lt;p>下图发射过程被分为了唤醒(wake-up)和仲裁(Select)两个流水线阶段&lt;/p>
&lt;p>唤醒阶段,发射队列中的所有相关寄存器会被置为准备好的状态&lt;/p>
&lt;p>仲裁阶段,会使用仲裁电路选择一条最合适的指令送到FU中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 357;
flex-basis: 857px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png" data-size="836x234">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png"
width="836"
height="234"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu13578928480996287574.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu15483047359496982778.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>tomasulo算法:在指令执行完才对相关指令进行唤醒&lt;/p>
&lt;p>可以通过将唤醒过程提前来获得更高性能&lt;/p>
&lt;p>即在指令A被仲裁电路选中后就对其他寄存器进行唤醒,这样指令B在下一个周期就能够被仲裁&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 267;
flex-basis: 643px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png" data-size="611x228">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png"
width="611"
height="228"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu12261158574036134191.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu15538349812895092404.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>意思是 Select 和 wake-up应该是在同一个周期的串行,A被唤醒才能够去selectB&lt;/p>
&lt;p>这种操作称为&amp;quot;原子的&amp;quot;&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 210;
flex-basis: 504px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png" data-size="818x389">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png"
width="818"
height="389"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu14381474285825173627.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu7271168370352068712.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>拆分流水线可以使得主频升高,但是&lt;/p>
&lt;p>(1)分支预测失败,惩罚增加&lt;/p>
&lt;p>(2)cache访问的周期数增加&lt;/p>
&lt;p>(3)功耗增大&lt;/p>
&lt;p>以上是假设执行是一个周期,实际上并不止&lt;/p>
&lt;h3 id="数据捕捉结构的流水线">数据捕捉结构的流水线&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 237;
flex-basis: 568px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png" data-size="858x362">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png"
width="858"
height="362"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu7642558332426759119.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu738880975121771762.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以把select和payload放在同一个流水段 ,在指令被仲裁电路选中之后,在同一个周期对发射队列其他的指令进行唤醒,同时去读取payload RAM,这两个操作是并行进行的,在这个流水段还会负责payload RAM的读取和写入,会导致处理器的周期时间变得过大.&lt;/p>
&lt;p>旁路网络这样是啥意思????&lt;/p>
&lt;p>另一种设计方式是把payload单独放成一个流水段,旁路和执行分成两个流水段,在旁路阶段,FU的结果会被送到payload RAM和FU的输入端&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 241;
flex-basis: 579px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png" data-size="799x331">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png"
width="799"
height="331"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu15363317278529565932.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu3440636031536888040.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="分配">分配&lt;/h2>
&lt;p>对于非压缩的方式设计的发射队列,需要分配电路扫描整个发射队列,找到四个空闲的表项并将四条指令写入&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 111;
flex-basis: 268px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png" data-size="478x427">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png"
width="478"
height="427"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu915797298984400432.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu13892753167635664755.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>
可以使用一个表格来记录所有空闲表项的编号,按照FIFO的方式管理,也可以简单把发射队列分为多个部分,每个段选一个空闲编号,但是会出现问题就是如果有一个表项非空的话,会阻碍其他指令的放入,甚至由于在寄存器重命名阶段是in-order状态A的无法放入会导致后续指令都无法放入&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 117;
flex-basis: 282px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png" data-size="529x450">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png"
width="529"
height="450"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu16173649002378560098.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu10959566968097053341.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="仲裁">仲裁&lt;/h2>
&lt;p>最好实现oldest-first功能的仲裁&lt;/p>
&lt;h3 id="1-of-m仲裁">1-of-M仲裁&lt;/h3>
&lt;p>可以通过指令在ROB中的位置作为指令的年龄信息,但是由于ROB是一个循环队列,所有单纯的地址是无法表征年龄的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 387;
flex-basis: 930px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png" data-size="834x215">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png"
width="834"
height="215"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu11734813543713119581.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu2948785691697860533.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>其实我觉得,直接比较读写地址可以的吧,读指针 &amp;gt; 写指针 , 下新上旧 , 读指针 &amp;lt; 写指针 , 上新下旧 ,其实读指针 &amp;gt; 写的时候,也代表两者不是一面的&lt;/p>
&lt;p>可以在ROB中地址前面再加入一位,称为位置值.想当于对于读写地址又加了一位&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 83;
flex-basis: 199px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png" data-size="333x400">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png"
width="333"
height="400"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu8819546655997073234.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu10037926471509499272.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 121;
flex-basis: 292px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png" data-size="550x451">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png"
width="550"
height="451"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu12240918921388596847.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu6071650023988884185.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)位置值相同时,ROB地址越小,对应的指令越旧&lt;/p>
&lt;p>(2)位置值不同时,ROB地址越大,对应的指令越旧,比方说情况2的 0 10 与 1 01 比较,明显是0 10 旧&lt;/p>
&lt;p>先根据是否rdy选出指令,再根据年龄进行筛选&lt;/p>
&lt;p>二分&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 385px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png" data-size="472x294">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png"
width="472"
height="294"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu15299360207959238160.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu12909387690140829006.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 128;
flex-basis: 307px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png" data-size="806x629">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png"
width="806"
height="629"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu1482760444792659261.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu4089846200509570806.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>该电路能够得到最小的年龄值,但是还需要得到最小年龄值对应的指令,最方便的是将指令信息也一同附上去&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 145;
flex-basis: 350px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png" data-size="496x340">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png"
width="496"
height="340"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu10454207305702131865.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu4651879014994689033.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="n-of-m-仲裁电路">N of M 仲裁电路&lt;/h3>
&lt;p>几个FU共用一个发射队列,发射队列需要在一个周期内为没一个FU选择出一条指令,就要求有一个N of M的仲裁电路&lt;/p>
&lt;p>可以通过两级仲裁电路实现,第一级选择一条指令后对第二级进行标记,但是这样延时极大&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 172;
flex-basis: 414px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png" data-size="601x348">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png"
width="601"
height="348"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu14705004795844087432.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu18352542851947980875.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对每一个FU使用一个1 of M的仲裁器, 根据指令类型进行分类,这样就会存在相同类型的指令会阻塞或者一部分FU处在空闲状态的问题&lt;/p>
&lt;p>可以通过增加FU的数量解决上述问题,但是比方数两个ALU,指令该分配给哪个ALU又是一个问题,可以通过轮换分配法实现,但是这样是无法保证严格的oldest-first原则的,而且有可能会浪费FU资源&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 268;
flex-basis: 645px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png" data-size="828x308">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png"
width="828"
height="308"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu5869953476708852689.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu13988473186677534807.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一般来说,加减法,逻辑运算,移位运算合成一个FU,&lt;/p>
&lt;p>惩罚和除法合成一个,&lt;/p>
&lt;p>访问存储器和访问协处理器合并在一起,&lt;/p>
&lt;p>浮点运算合并在一起&lt;/p>
&lt;h2 id="唤醒">唤醒&lt;/h2>
&lt;h3 id="单周期的唤醒">单周期的唤醒&lt;/h3>
&lt;p>唤醒是指被仲裁器选中的指令将目的寄存器的编号(dst_tag)和发射队列中所有源寄存器的编号进行比较,并将那些比较结果相等的源寄存器进行标记的过程&lt;/p>
&lt;p>下面的电路是所有仲裁电路共享一个发射队列的情况, 所以发射队列只会接受到一个响应,因为同一时刻肯定只有一条指令被仲裁,每个FU都会使用一个仲裁电路&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 209;
flex-basis: 503px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png" data-size="881x420">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png"
width="881"
height="420"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu12195273095659706992.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu9126926194952235300.png 1024w"
loading="lazy"
alt="image-20241020213306752">
&lt;/a>
&lt;figcaption>image-20241020213306752&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>(1)ValL:指令中是否存在第一个源寄存器&lt;/p>
&lt;p>(2)SrcL:指令中第一个源寄存器的编号&lt;/p>
&lt;p>(3)RdyL:指令中第一个源寄存器是否已经被唤醒而处于准备好的状态&lt;/p>
&lt;p>(4)ValR:第二个&lt;/p>
&lt;p>(5)Dest:目的寄存器的编号&lt;/p>
&lt;p>(6)Issued:一条指令被仲裁电路选中之后,可能不会马上离开发射队列,需要进行标记,这样的指令不会向仲裁电路发出请求信号&lt;/p>
&lt;p>为什么有四个仲裁电路?????是不是指多个FU,但是多个FU不是应该可以接受多个请求&lt;/p>
&lt;p>发射队列的每一个表项都会根据四个响应信号的值,将自身的目的寄存器编号送到对应的总线上去,每个仲裁电路对应一个总线&lt;/p>
&lt;ol>
&lt;li>被仲裁电路选择的指令会将它的目的寄存器编号送到对应的总线上&lt;/li>
&lt;li>每一条总线的值会和发射队列中所有指令的源寄存器的编号进行比较,如果发现相等,标记为准备好的状态&lt;/li>
&lt;li>当发射队列某条指令的操作数都准备好了,并且没有被仲裁电路选中过,就可以想仲裁电路发送请求信号&lt;/li>
&lt;li>如果仲裁电路发现有更高优先级的指令发出请求,当前指令不会得到有效响应信号,需要再之后的周期继续发送请求信号.在一些设计中,可以轮流向多个仲裁电路发送请求.如果从仲裁电路中得到有效信号,就会吧issued置位.一条被选中的指令不会立刻离开发射队列,因为一个指令如果使用了load指令的结果,即使被仲裁电路选中,也不能离开&lt;/li>
&lt;li>发射队列的指令更具响应信号,,把目的寄存器编号送到对应总线上去,用来唤醒发射队列中所有相关的源寄存器&lt;/li>
&lt;/ol>
&lt;h3 id="多周期的唤醒">多周期的唤醒&lt;/h3>
&lt;p>单周期的唤醒能够在一个周期被FU执行完毕,但是当一条指令无法在一个周期执行完毕时,需要根据她在FU中的周期数,将唤醒过程延迟&lt;/p>
&lt;p>根据唤醒的过程&lt;/p>
&lt;h4 id="延迟广播">延迟广播.&lt;/h4>
&lt;p>发现被仲裁电路选中的指令执行周期大于1,则在选中的当前周期,不讲指令的目的寄存器编号送到总线上,而是根据选中指令需要执行的周期数(N),延迟N-1周期,才送到总线上去&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 490;
flex-basis: 1176px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png" data-size="838x171">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png"
width="838"
height="171"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu3236811294374040669.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu5826633055030736483.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>延迟广播之后可能出现tag bus产生冲突,比方说下面的MUL和ADD在同一时刻需要将目的寄存器的值送到tag broadcast bus上&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 290;
flex-basis: 696px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png" data-size="836x288">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png"
width="836"
height="288"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu16861531667843717354.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu3627428205873869122.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以通过增加总线的数量,也可以利用表格,记录下FU执行指令所需要的周期数,被仲裁电路选中的指令,如果发现冲突,被选中的指令不会送到FU中执行,而是在下一个周期继续参与仲裁&lt;/p>
&lt;p>但是还是存在一个问题,就是指令B被否决(cycle 1),本身指令C是可以被仲裁的,但是C比B要新,所以这个周期被浪费掉了,所以可以先检查是否冲突,如果冲突的话就不向仲裁电路发起请求了(不发请求很奇怪啊,发请求在仲裁的时候否决行不行),但是这样访问网络和仲裁电路是串行的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 168;
flex-basis: 403px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png" data-size="580x345">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png"
width="580"
height="345"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu3250847906907956578.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu13178792662719264520.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="延迟唤醒">延迟唤醒&lt;/h4>
&lt;p>在比较结果相等时,不马上置为准备好的状态,而是根据指令所需要的执行周期数,进行相应周期的延时,然后再改变发射队列中源寄存器的状态&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 237;
flex-basis: 570px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png" data-size="632x266">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png"
width="632"
height="266"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu13815543178213961515.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu9998523058420159875.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 408;
flex-basis: 979px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png" data-size="816x200">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png"
width="816"
height="200"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu12597106233390159010.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu3885520225871445685.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 162;
flex-basis: 389px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021134018615.png" data-size="874x539">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021134018615.png"
width="874"
height="539"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021134018615_hu11985143713305038664.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021134018615_hu8735654588987287885.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>寄存器重命名(超标量+过程恢复)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</link><pubDate>Sat, 19 Oct 2024 11:46:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</guid><description>&lt;h2 id="超标量处理器的寄存器重命名">超标量处理器的寄存器重命名&lt;/h2>
&lt;p>对于 Dest = Src1 op ASrc2&lt;/p>
&lt;p>(1)从RAT中找到Src1和Src2对应的物理寄存器Psrc1和Psrc2&lt;/p>
&lt;p>(2)从空闲列表(Free list)中找到一个空闲的物理寄存器Pdest,将其作为指令的目的寄存器Dest对应的物理寄存器&lt;/p>
&lt;p>(3)将逻辑寄存器Dest和物理寄存器Pdest的映射关系写到RAT中&lt;/p>
&lt;p>RAT需要3个读端口(Src1,Src2和Dest作为地址) Dest这个端口用于和ROB进行交互,将之前的映射关系写入ROB中&lt;/p>
&lt;p>对于超标量,就需要成倍的端口&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 101;
flex-basis: 244px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468.png" data-size="542x533">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468.png"
width="542"
height="533"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468_hu9722805920825487102.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468_hu15333852949318292347.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 355;
flex-basis: 853px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413.png" data-size="491x138">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413.png"
width="491"
height="138"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413_hu8255966269358325669.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413_hu10341188819607733508.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1) A,B存在RAW相关性 , 所以r0对应的物理寄存器之列来自于指令A对应的P30,不来自于从RAT读取的值&lt;/p>
&lt;p>(2)A,B,D存在WAW相关性,&lt;/p>
&lt;p>A.在写入RAT时,如果多条命令有同一个目标寄存器,那映射关系实际上写的还是最新的那条指令&lt;/p>
&lt;p>B.在将旧映射关系写入ROB的时候,如果发现一个周期内有多条指令都使用的同一个目的寄存器,此时写入到ROB中的旧映射关系不再来自于RAT读取的值,还是直接来自于和他存在WAW相关的指令,例如指令B的物理寄存器来自r0,或者所物理寄存器来自于P31&lt;/p>
&lt;p>(3)B,D存在WAR相关性,通过寄存器重命名可以客服&lt;/p>
&lt;h3 id="解决raw相关性">解决RAW相关性&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 225;
flex-basis: 542px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893.png" data-size="479x212">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893.png"
width="479"
height="212"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893_hu15093054276736074816.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893_hu12400791209209954972.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>意思就是如果在同一周期进行寄存器重命名,对于源寄存器,应该获取当前赋值给目的寄存器的物理寄存器(P31),而不是之前的物理寄存器(P25),所以需要进行组内相关性检查,由于此时是顺序的,所以相关性检查和顺序处理器相似,只需要比较源寄存器与目的寄存器的编号就可以了&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 157;
flex-basis: 378px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923.png" data-size="671x426">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923.png"
width="671"
height="426"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923_hu2388780508683478430.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923_hu5401642006917474835.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 175;
flex-basis: 421px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946.png" data-size="700x399">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946.png"
width="700"
height="399"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946_hu10836408520997120333.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946_hu14788717271551015671.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="解决waw相关性">解决WAW相关性&lt;/h3>
&lt;h4 id="对写rat进行检查">对写RAT进行检查&lt;/h4>
&lt;p>在寄存器重命名周期,如果存在多个指令的目的寄存器都相等的情况,那么只有最新的那条指令的映射关系才运行写入到RAT中 ,可以通过检查目标寄存器来实现,例如对于dst0只要和dst1,dst2,dst3中的任意一个存在相同的情况,就不需要将dst0对应的映射关系写到RAT中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 433px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453.png" data-size="649x359">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453.png"
width="649"
height="359"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453_hu17123479746391636632.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453_hu741281326496473227.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="对写rob进行检查">对写ROB进行检查&lt;/h4>
&lt;p>为了能够释放掉那些不再使用的物理寄存器,同时可以对处理器的状态进行恢复,每条指令需要从RAT中读出他以前对应的物理寄存器,并将其写到ROB当中,如果两条指令存在WAW,那么比较新的这条指令对应的就的物理寄存器就直接来自与比较旧的那条指令,而不是RAT中&lt;/p>
&lt;p>通过比较指令与前面指令的目的寄存器就可以实现&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 235;
flex-basis: 565px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215.png" data-size="471x200">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215.png"
width="471"
height="200"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215_hu14294549447914897059.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215_hu11321073359892355193.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 152;
flex-basis: 366px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687.png" data-size="818x536">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687.png"
width="818"
height="536"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687_hu5261038282723109657.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687_hu1035297534865978118.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="rat的sram结构">RAT的SRAM结构&lt;/h3>
&lt;p>读优先 : 当前写入的数据在下一个周期才能被读取&lt;/p>
&lt;p>写优先:当前写入的数据在当前数据就能够被读取&lt;/p>
&lt;p>对于RAT,需要做到先读,读完再修改,所以采取读优先&lt;/p>
&lt;p>对于读取目的寄存器,由于本来就要获取目的寄存器之前对应的物理寄存器,所以读优先是必须的&lt;/p>
&lt;p>对于读取源寄存器,其实需要得到新的映射,需要使用之前的RAW相关性的检查和处理电路&lt;/p>
&lt;h3 id="特殊情况的标记">特殊情况的标记&lt;/h3>
&lt;p>对于没有一个目标寄存器和两个源寄存器的指令,采取以下方式&lt;/p>
&lt;p>(1)根据需要重命名的目的寄存器个数,觉得当前周期需要从空闲列表读取数字的个数&lt;/p>
&lt;p>(2)使用目的寄存器读取RAT时,目的寄存器不存在的指令不会读取RAT&lt;/p>
&lt;p>(3)使用源寄存器读取RAT时,源寄存器不存在的指令不会读取RAT&lt;/p>
&lt;p>(4)在RAW和WAW相关性检查时,如果源寄存器和目的寄存器不存在,那就忽略&lt;/p>
&lt;h2 id="寄存器重命名的恢复">寄存器重命名的恢复&lt;/h2>
&lt;h3 id="使用checkpoint对rat进行恢复">使用checkpoint对RAT进行恢复&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 294;
flex-basis: 707px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227.png" data-size="820x278">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227.png"
width="820"
height="278"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227_hu9554526713186701756.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227_hu243255152380488361.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>SRAM的最小存储单元(Main Bit Cell,MBC), (Checkpoint Bit Cell ,CBC)&lt;/p>
&lt;p>当需要对RAT进行状态保存时,将MBC的内容复制到指定的CBC中(Allocation),当对RAT进行状态恢复时,将对应CBC的内容复制到MBC中(Restore)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 244;
flex-basis: 585px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542.png" data-size="747x306">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542.png"
width="747"
height="306"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542_hu12124988756168614648.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542_hu3605033107495912464.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="使用walk对rat进行恢复">使用WALK对RAT进行恢复&lt;/h3>
&lt;p>对每一条指令,在ROB中都储存了这条指令之前对应的物理寄存器,利用这个信息,可以将RAT的状态逐步&amp;quot;倒回去&amp;quot;,使得那些处在错误路径上的指令,对RAT的修改都进行修复&lt;/p>
&lt;p>ROB中储存着物理寄存器,逻辑寄存器,之前的物理寄存器,一条一条回退到之前的物理寄存器,应该就可以做到&lt;/p>
&lt;h3 id="使用architecture-state对rat进行恢复">使用Architecture State对RAT进行恢复&lt;/h3>
&lt;p>在流水线提交阶段有一个RAT,,叫做aRAT(architecture RAT),它所保存的物理寄存器和逻辑寄存器的映射是完全正确的&lt;/p>
&lt;p>对于如下的指令,在重命名阶段的RAT,对于r1的映射应该是P34,但是实际上此时指令D是处在推测阶段,是有可能被冲刷掉的,但是对于aRAT,它保存的就是已经提交的指令之间的映射,例如R1对应P31,它的状态是完全正确的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 311;
flex-basis: 748px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702.png" data-size="371x119">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702.png"
width="371"
height="119"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702_hu131409708023009198.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702_hu14698438627090399126.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>所以说,可以通过aRAT进行恢复,具体就是在分支预测失败时,让指令继续执行,直到分支指令变成最旧的一条指令,那此时所保存的状态就是分支指令之前的指令所得到的状态,再复制,就能够恢复了&lt;/p>
&lt;p>等到分支指令变到流水线最旧的指令,才恢复RAT的另一个好处就是,如果在一条分支指令之前存在异常或者另一个分支预测失败,那这条分支指令就不会被处理,也避免了一些无用功&lt;/p>
&lt;h3 id="分发">分发&lt;/h3>
&lt;p>(1) 发射队列 (out-of-order),指令在送到FU中被执行之前,先被放到一个缓存中,每个FU都对应一个发射队列,&lt;/p>
&lt;p>只要一条指令的所有源操作数都准备好了,就可以直接送到FU中执行,不用理会指令的原始顺序,在多发射处理器中,需要从缓存中找到多个空闲的表项&lt;/p>
&lt;p>(2)发射队列(in-order),分支指令和store指令是按照顺序执行的,该队列就是FIFO&lt;/p>
&lt;p>(3)重排序缓存(ROB),将乱序拉回顺序&lt;/p>
&lt;p>分发就是将寄存器重命名之后的指令写到发射队列和重排序队列当中&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>寄存器重命名(方式+映射表)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</link><pubDate>Fri, 18 Oct 2024 19:25:31 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>WAW 和 WAR (写后写 和读后写) 可以通过更换寄存器的名字来解决相应冲突&lt;/p>
&lt;h3 id="存在原因">存在原因&lt;/h3>
&lt;p>(1)有限个数的寄存器&lt;/p>
&lt;p>(2)循环体,很容易出现写后写冲突&lt;/p>
&lt;p>(3)代码重用,一些小函数被频繁的调用&lt;/p>
&lt;p>物理寄存器(Physical Register)和逻辑寄存器(Logical Register或者 architecture Register)物理寄存器数量多于逻辑寄存器&lt;/p>
&lt;p>重命名映射表 (Register Renaming Table, Register Alias Table ,RAT)空闲寄存器列表(Free Register List)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 142;
flex-basis: 342px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065.png" data-size="565x396">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065.png"
width="565"
height="396"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065_hu12948031862022571597.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065_hu6665644479148694185.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="寄存器重命名的方式">寄存器重命名的方式&lt;/h2>
&lt;p>(1)将逻辑寄存器(architecture Register File,ARF)扩展来实现&lt;/p>
&lt;p>(2)使用统一的物理寄存器(Physical Register File,PRF)实现&lt;/p>
&lt;p>(3)使用ROB实现&lt;/p>
&lt;h3 id="rob">ROB&lt;/h3>
&lt;p>将ROB作为物理寄存器,存储所有**推测状态(speculative)**的结果,使用逻辑寄存器(ARF)存储所有正确的结果&lt;/p>
&lt;p>当一条指令被写入ROB中的一个表项(entry)时,表项的编号即为物理寄存器,这样将逻辑寄存器和表项建立了关系,&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 104;
flex-basis: 249px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542.png" data-size="520x500">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542.png"
width="520"
height="500"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542_hu17786506562862009958.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542_hu13468767093701107792.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>ROB存储着所有没有离开流水线的指令结果,逻辑寄存器(ARF)存储着所有&amp;quot;最新&amp;quot;离开流水线的指令结果&lt;/p>
&lt;p>重命名映射表用来指示每一个逻辑寄存器的值是位于ROB中还是位于ARF中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224.png" data-size="547x343">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224.png"
width="547"
height="343"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224_hu13515659451589263706.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224_hu16314137865859507292.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="缺点">缺点&lt;/h4>
&lt;p>(1)即使没有目的寄存器也会占用ROB的一个表项,代表物理寄存器的浪费&lt;/p>
&lt;p>(2)对应ROB和ARF需要有多个读端口来支持多条指令的访问&lt;/p>
&lt;h3 id="arf扩展">ARF扩展&lt;/h3>
&lt;p>可以使用一个独立的存储部件来存储流水线中所有指令的结果,只有那些存在目的寄存器的指令才会占据该部件,称为 PRF(Physical Register File),PRF和ROB类似,只是在没有目标寄存器的指令不会占据PRF,寄存器重命名时存在目的寄存器的指令会占据PRF的空间,在退休时,结果会从PRF搬移到ARF中&lt;/p>
&lt;p>重命名映射表用来指示每一个逻辑寄存器的值是位于PRF中还是位于ARF中,需要保存PRF的地址空间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 174;
flex-basis: 417px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777.png" data-size="707x406">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777.png"
width="707"
height="406"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777_hu16404446892470360470.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777_hu9368343665924381625.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="使用统一的prf">使用统一的PRF&lt;/h3>
&lt;p>存储所有推测的和正确的寄存器值,&lt;/p>
&lt;p>使用空闲列表记录PRF哪些寄存器处在空闲状态&lt;/p>
&lt;p>当指令被寄存器重命名,并且存在目的寄存器的时候,就会占据PRF当中的一个寄存器,该寄存器会经历值未被计算,值被计算但是没有退休,退休三个过程&lt;/p>
&lt;p>通过重命名映射表存储每个逻辑寄存器和物理寄存器的对应关系&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 281;
flex-basis: 676px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250.png" data-size="741x263">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250.png"
width="741"
height="263"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250_hu5765812971098335496.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250_hu13651381351086792579.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>寄存器重命名时,&lt;/p>
&lt;p>源寄存器:查找重命名的映射表(RAT),找出对应物理寄存器的编号&lt;/p>
&lt;p>目的寄存器:给目的寄存器指定一个空闲状态的物理寄存器,并且该关系会被更新到RAT中&lt;/p>
&lt;p>指令退休之后释放物理寄存器&lt;/p>
&lt;p>一条指令之后在退休的时候,结果才会被外部看到,推测时是无法被外界看到的,需要使用另外一个RAT,存储所有&amp;quot;退休&amp;quot;状态的指令和物理寄存器的对应关系(啥时候释放?),外部只能通过查找这个RAT,找到逻辑寄存器对应的物理寄存器&lt;/p>
&lt;p>**只有后续的指令不使用物理寄存器之后,物理寄存器才能够变成空闲.**可以采取比较保守的方式,就是当一个指令和后面的莫条指令都写到同一个目的寄存器时,前面指令的物理寄存器可以释放了,**所以在ROB中除了记录逻辑寄存器当前对应的物理寄存器之外,还需要存储它之前对应的物理寄存器,**以便在指令退休的时候,将旧映射关系释放&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 462;
flex-basis: 1109px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285.png" data-size="587x127">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285.png"
width="587"
height="127"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285_hu9704412521937681004.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285_hu16598331625486021963.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="优点">优点&lt;/h4>
&lt;p>(1)寄存器的值只需要被写入一次?&lt;/p>
&lt;p>(2)源寄存器的值只能存储在一个地方,即PRF中&lt;/p>
&lt;h2 id="重命名映射表rat">重命名映射表(RAT)&lt;/h2>
&lt;p>RAT是一个表格,使用逻辑寄存器作为地址寻址,对于指令的源寄存器,可以从表格中得到对应的物理寄存器的编号&lt;/p>
&lt;p>对指令的目的寄存器来说,会将物理寄存器编号写到这个表格,即建立映射关系&lt;/p>
&lt;p>可以使用多端口的SRAM(sRAT)和CAM(cRAT)实现,CAM(内容寻址的存储器)&lt;/p>
&lt;p>SRAM表项个数等于逻辑寄存器的个数,里面存放对应物理寄存器的编号,位宽为log(物理寄存器数量)&lt;/p>
&lt;p>CAM表项个数等于物理寄存器的个数,里面存放对应逻辑寄存器的编号,位宽为log(逻辑寄存器数量),寻址时逻辑寄存器的编号会和每个表项进行对比,返回对应的地址&lt;/p>
&lt;p>使用SRAM寻址功耗小,面积小&lt;/p>
&lt;p>由于对于cRAT进行checkpoint只需要保存状态位(V),而不需要将整个cRAT进行保存,能够大大减少checkpoint电路的面积,当checkpoint数量大时,反而cRAT具有优势&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 200;
flex-basis: 480px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733.png" data-size="801x400">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733.png"
width="801"
height="400"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733_hu11917421335245838524.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733_hu1566958612408089329.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="基于sram的重命名映射表">基于SRAM的重命名映射表&lt;/h3>
&lt;p>checkpoint需要把整个sRAT都保存下来&lt;/p>
&lt;p>对于4-way的超标量处理器,每周期最多需要对四条指令进行寄存器重命名,sRRAT需要8个读端口和4个写端口(每条指令包含2个源寄存器和1个目的寄存器)&lt;/p>
&lt;p>新写入到sRAT的值会覆盖掉原来旧的对应关系,需要记录下来&lt;/p>
&lt;p>(1)方便指令在退休的时候,将对应的物理寄存器变为空闲状态???? (&lt;del>还是无法理解,按理来说覆盖了说明该逻辑寄存器又分配了新的物理寄存器,那原来那个确实可以删除了&lt;/del>)(覆盖的时候后面的指令还没有退休,是有可能无效的(分支失败异常之类的,那后面分配的必定是要被还原的,所以物理寄存器是应该在后面指令退休的时候再变成空闲状态))&lt;/p>
&lt;p>(2)当一条指令之前存在异常或者分支预测失败时,需要从流水线中被抹去 ,同时这条指令对于RAT的修改需要被恢复过来,通过将旧的映射关系保存下来,可以协助RAT的修复&lt;/p>
&lt;p>缺点就是无法使用多的checkpoint&lt;/p>
&lt;p>只要预测的足够准,就不怎么需要checkpoint ,就可以去减少checkpoint的数量,但是如果预测错了又没有checkpoint,那对于RAT的恢复也会很麻烦&lt;/p>
&lt;p>??? RAT里面的值不是应该也是保存在ROB里的吗,那保存ROB不就行了,为什么还要RAT&lt;/p>
&lt;h3 id="基于cam的重命名映射表">基于CAM的重命名映射表&lt;/h3>
&lt;p>任意时刻,每个逻辑寄存器都只有一个物理寄存器与之对应,可以使用一个有效位(V)表示&lt;/p>
&lt;p>cRAT需要8个读端口和4个写端口(每条指令包含2个源寄存器和1个目的寄存器)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 136;
flex-basis: 328px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693.png" data-size="427x312">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693.png"
width="427"
height="312"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693_hu13747216310678279473.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693_hu9494608413689815968.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>SRAM + CAM ,SRAM用来存储每个物理寄存器对应的逻辑寄存器,CAM用来进行内容的比较&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 104;
flex-basis: 249px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724.png" data-size="436x419">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724.png"
width="436"
height="419"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724_hu9710394290090467635.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724_hu9996034423044171934.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>需要等到后面写入到同一个逻辑寄存器的指令退休(retire)的时候,才可以将这个逻辑寄存器之前对应的物理寄存器变为空闲状态&lt;/p>
&lt;p>并不是一个物理寄存器对应的有效位为0,就表示物理寄存器是空闲状态,有可能是这个映射关系刚刚被覆盖了.通过使用ROB和空闲列表可以管理物理寄存器何时变为空闲&lt;/p>
&lt;p>在分支指令寄存器重命名之前,将cRAT的有效位保存起来;在流水线的后续阶段,发现分支指令预测失败是,将分支指令对应的checkpoint写回到cRAT的有效位就完成恢复了(why?这样能保证恢复映射关系?)&lt;/p>
&lt;p>恢复时可能把一些本身处在非空闲状态的物理寄存器变成了空闲状态,因为非空闲状态的物理寄存器有效位也可以是0&lt;/p>
&lt;p>有可能在进行checkpoint保存的时候为0,到了状态恢复的时候变成1了.典型情况是物理寄存器在变为空闲之后又被新的指令使用了.但是该指令处在分支预测失败或者异常路径上.应该是要恢复为0的&lt;/p>
&lt;h4 id="举例">举例&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 121;
flex-basis: 291px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359.png" data-size="250x206">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359.png"
width="250"
height="206"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359_hu1962377548689383665.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359_hu12246078549466636233.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在指令F进行寄存器重命名时,需要对cRAT进行Checkpoint保存&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 198;
flex-basis: 477px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099.png" data-size="742x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099.png"
width="742"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099_hu17598209733909211804.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099_hu1293636208337311542.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>分支F被发现了分支预测失败,对cRAT进行状态恢复前 ,在F解码时,就保存了此时的状态,所以如果预测失败写回,就直接恢复了那之前的表&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 172;
flex-basis: 415px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106.png" data-size="749x433">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106.png"
width="749"
height="433"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106_hu11760825212501167464.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106_hu9948112582823394189.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>每次在流水线的寄存器重命名阶段遇到分支2指令时,都会从表7.2找出一个空闲的GC来存储此时的有效位(V),并将GC的编号放在分支指令的信息中,这样当得到分支预测的结果之后,就可以根据编号来找到与之对应的GC.在分支预测失败之后直接进行相应的复原&lt;/p>
&lt;p>为了保证正确性,在分支预测失败进行恢复的时候,需要对空闲列表(free list)也进行状态恢复,那些别占用的物理寄存器都将重新变为空闲的状态(通过恢复free list的读指针)&lt;/p>
&lt;p>对cRAT进行状态恢复,就是要还原出逻辑寄存器真正对应的物理寄存器,因为会续分支预测失败路径上的指令可能会修改对应关系,需要进行纠正.对于物理寄存器的空闲管理交给ROB和free list&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>分支预测(目标地址预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</link><pubDate>Wed, 16 Oct 2024 18:26:42 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</guid><description>&lt;h2 id="分支预测的目标地址预测">分支预测的目标地址预测&lt;/h2>
&lt;p>对于直接跳转的分支指令,由于它的偏移值(offset)是以立即数的形式固定在指令中,目标地址是固定的,只需要记录分支指令的目标地址即可.&lt;/p>
&lt;p>对于间接分支跳转,大部分是CALL和Return ,所以可以进行一定程度的预测&lt;/p>
&lt;h3 id="直接跳转类型的分支预测">直接跳转类型的分支预测&lt;/h3>
&lt;p>(1)当分支指令不发生跳转时,&lt;/p>
&lt;p>目标地址 = 当前分支指令的PC值 + Sizeof(fetch group)&lt;/p>
&lt;p>(2)当发生跳转时&lt;/p>
&lt;p>目标指令 = 当前分支指令的PC值 + Sign_Eextend(offset)&lt;/p>
&lt;h4 id="btb">BTB&lt;/h4>
&lt;p>通过BTB(Branch Target Buffer)(相当于一个cache)使得多个PC值共用一个空间来存储目标地址,&lt;/p>
&lt;p>index + tag ,&lt;/p>
&lt;p>BTA (Branch Target Address)分支目标地址&lt;/p>
&lt;p>可以使用组相联的BTA来提高分支预测的准确率&lt;/p>
&lt;p>如果已经被替换了,那该跳哪去 : 先跳再冲刷吗?&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 386px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711.png" data-size="856x532">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711.png"
width="856"
height="532"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711_hu7374757969364877266.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711_hu6804283647297828377.png 1024w"
loading="lazy"
alt="image-20241016185417711">
&lt;/a>
&lt;figcaption>image-20241016185417711&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="partial-tag-btb">partial-tag BTB&lt;/h5>
&lt;p>如果映射到BTB中的指令中只有一条,那可以简化tag的部分,只使用很小的一部分,&lt;/p>
&lt;p>这种方法实际上也是在赌,减少了tag的大小,万一出现了重合,那就会出现目标地址预测失败的情况,但实际上,如果出现了重合,即使不减少tag,仍然会导致预测失败.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 302;
flex-basis: 726px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818.png" data-size="778x257">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818.png"
width="778"
height="257"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818_hu17713719676223318284.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818_hu2386597830981386302.png 1024w"
loading="lazy"
alt="image-20241016185852818">
&lt;/a>
&lt;figcaption>image-20241016185852818&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>和之前类似,仍然可以采取一定运算,来降低tag的位数,比方说异或&lt;/p>
&lt;p>&lt;del>我比较好奇,如果tag没有对上,对于直接相连来说,本身也无法得到正确地址,那为什么不直接把tag删除了&lt;/del>&lt;/p>
&lt;p>应该是组相联有用吧&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 235;
flex-basis: 565px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007.png" data-size="551x234">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007.png"
width="551"
height="234"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007_hu17591383904736463039.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007_hu1099906551913900448.png 1024w"
loading="lazy"
alt="image-20241016190929007">
&lt;/a>
&lt;figcaption>image-20241016190929007&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="btb缺失的处理">BTB缺失的处理&lt;/h4>
&lt;h5 id="停止执行">停止执行&lt;/h5>
&lt;p>暂停取指,直到目标地址被计算出来&lt;/p>
&lt;p>对于直接跳转指令,在解码阶段就可以分离出偏移值&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 181;
flex-basis: 436px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026.png" data-size="491x270">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026.png"
width="491"
height="270"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026_hu6458134045906799705.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026_hu15515489183902377947.png 1024w"
loading="lazy"
alt="解码阶段分离指令">
&lt;/a>
&lt;figcaption>解码阶段分离指令&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>停止取指会造成气泡,其实就是导致流水线停滞&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 282;
flex-basis: 677px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520.png" data-size="725x257">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520.png"
width="725"
height="257"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520_hu17955641935330878257.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520_hu10501807876583559370.png 1024w"
loading="lazy"
alt="image-20241016192510520">
&lt;/a>
&lt;figcaption>image-20241016192510520&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="继续执行">继续执行&lt;/h5>
&lt;p>使用顺序的PC值去指令&lt;/p>
&lt;p>计算出的地址和原来PC不一致,就冲刷流水线,重新开始取指&lt;/p>
&lt;p>这么做会浪费功耗&lt;/p>
&lt;h3 id="间接跳转类型的分支预测">间接跳转类型的分支预测&lt;/h3>
&lt;h4 id="callreturn-指令的分支预测">CALL/Return 指令的分支预测&lt;/h4>
&lt;p>CALL的地址一般也是固定的,所以也可以通过BTB进行预测&lt;/p>
&lt;p>Return的目标地址是不固定的,但是Return的目标地址总是等于最近一次执行的&lt;/p>
&lt;p>但是Return指令的目标地址,是按照CALL指令执行的相反顺序排列的&lt;/p>
&lt;p>所以可以做一个存储器,保存最近执行的CALL指令的下一条指令的地址,这个存储器是后进先出的(Last In First Out,LIFO),原理与堆栈类似,称为返回地址堆栈(Return Address Stack,RAS)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 249;
flex-basis: 599px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006.png" data-size="809x324">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006.png"
width="809"
height="324"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006_hu5781072421816679016.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006_hu16507365381751537198.png 1024w"
loading="lazy"
alt="CALL/Return 指令分支预测">
&lt;/a>
&lt;figcaption>CALL/Return 指令分支预测&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="ras工作条件">RAS工作条件&lt;/h5>
&lt;p>(1)需要及时保存PC + 4的值, 指令类型只有在解码阶段才能获知,因此可以在BTB中多加一项来保存分支指令的类型,这样在后续取到这一条指令就可以获知分支指令类型&lt;/p>
&lt;p>(2)在对Return指令进行目标地址预测是,能够选择RAS的数据,而非BTB的数据,按照上面的方法就可以做到&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 258;
flex-basis: 621px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233.png" data-size="492x190">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233.png"
width="492"
height="190"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233_hu508193164438520474.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233_hu1108834045841803893.png 1024w"
loading="lazy"
alt="将指令类型存储到BTB中">
&lt;/a>
&lt;figcaption>将指令类型存储到BTB中&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="ras满了">RAS满了&lt;/h5>
&lt;p>如果函数层次过深,就会出现RAS无法继续存放的问题&lt;/p>
&lt;p>(1)不保存CALL了,这样下一次Return 就会出现分支预测失败,并且还要求RAS指针不发生改变&lt;/p>
&lt;p>(2)继续按照顺序向RAS写入,此时最旧的会被覆盖掉.最后一次return 可能会出现分支预测失败,但是也是可能性事件,比方说递归函数&lt;/p>
&lt;p>可以通过带计数器的RAS来扩展RAS的容量, 即对于相邻的CALL,如果是同一条指令,就存放在RAS的同一个地址,再用计数器进行标识&lt;/p>
&lt;h4 id="其他指令的预测">其他指令的预测&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 131;
flex-basis: 316px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224.png" data-size="227x172">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224.png"
width="227"
height="172"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224_hu6984012436561300078.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224_hu9987043498051736602.png 1024w"
loading="lazy"
alt="case指令">
&lt;/a>
&lt;figcaption>case指令&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 291;
flex-basis: 699px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293.png" data-size="711x244">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293.png"
width="711"
height="244"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293_hu5286439124904148354.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293_hu16493922937992861016.png 1024w"
loading="lazy"
alt="image-20241016210205293">
&lt;/a>
&lt;figcaption>image-20241016210205293&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>使用基于局部历史的分支预测方法,把PHT换成了Target Cache,&lt;/p>
&lt;p>每当分支指令执行一次,就将目标地址写到Target Cache 中&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>分支预测使用 BHR , GHR和饱和计数器配合进行分支指令方向的预测&lt;/p>
&lt;p>使用 BTB, RAS和 Target Cache对分支指令的目标地址进行预测&lt;/p>
&lt;p>完整的分支预测方法 , decoupled BTB : 将分支指令的方向预测独立于BTB ,本身不会被记录到BTB的分支指令也会被记录(&lt;del>不跳转的分支也会记录到BTB&lt;/del>)&lt;/p>
&lt;p>预测为发生跳转,但是发生了BTB缺失,比发生分支预测失败的情况好,可以节省功耗&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 101;
flex-basis: 243px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326.png" data-size="525x517">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326.png"
width="525"
height="517"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326_hu15660941589493918871.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326_hu4393141796266973765.png 1024w"
loading="lazy"
alt="完整的分支预测方法">
&lt;/a>
&lt;figcaption>完整的分支预测方法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="分支预测失败的恢复">分支预测失败的恢复&lt;/h2>
&lt;p>处在错误路径上的指令有可能已经将处理器中某个部位的内容进行了更改,例如寄存器重命名阶段的重命名映射表(mapping table),需要对操作进行撤销,即分支预测失败时的恢复&lt;/p>
&lt;h3 id="分支预测检查">分支预测检查&lt;/h3>
&lt;p>(1) 解码阶段可以检查直接跳转的正确性,可以得到分支指令的方向和目标地址,&lt;/p>
&lt;p>对于间接跳转,即使得知预测错误,也无法得到正确的地址,但是可以通过流水线暂停来避免抹掉指令造成的功耗浪费&lt;/p>
&lt;p>(2)在读取物理物理寄存器的阶段,读取到寄存器的值,就可以得到目标地址是否错误,进行重新取指令,&lt;/p>
&lt;p>还是需要对不必要的指令进行抹去,对于进入发射队列的指令,可能比较困难,需要选择性的进行抹去&lt;/p>
&lt;p>(3)在执行阶段,任何分支指令的结果都可以被计算出结果,可以进行检查,但是造成的惩罚(penalty)是最大的.需要清除在这条分支指令之后进入流水线的所有数据&lt;/p>
&lt;h3 id="基于rob的恢复">基于ROB的恢复&lt;/h3>
&lt;p>在乱序执行中,在这条分支指令之前的数据也会在发射队列或者执行中,可以采取重排序缓存(ROB)对处理器进行状态恢复 (ROB是顺序存储指令的)&lt;/p>
&lt;p>当发生分支指令预测失败时,将信息记录在ROB对应的表项(entry)中,并且暂停流水线的取指令,但是让流水线继续执行,当这条指令变为最旧的指令后,冲刷掉流水线中的所有数据,重新取指令. 缺点就是停滞时间会比较长.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 168;
flex-basis: 404px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348.png" data-size="627x372">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348.png"
width="627"
height="372"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348_hu6633562508414504632.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348_hu17435496857645374288.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="基于checkpoint的状态恢复">基于checkpoint的状态恢复&lt;/h3>
&lt;p>checkpoint, 发现分支指令,并且在分支指令之后的指令更改处理器的状态之前,将处理器的状态保存起来,包括寄存器重命名中使用的映射表(mapping table),预测跳转的分支指令对应的下一条指令的PC等.在寄存器重命名阶段进行.&lt;/p>
&lt;p>需要将流水线中所有处于分支预测失败路径上的指令抹去. 需要一种机制识别哪些指令处在错误的路径上,可以通过编号实现,(编号可以在顺序阶段就编号完成),编号之后就可以获知哪些指令位于分支指令后面&lt;/p>
&lt;p>分支指令的编号个数决定了最多可以在流水线中存在的分支指令个数:假设处理器中最多支持128条指令存在于流水线中,按照每五条指令存在一条分支,最多后128/5 = 26 条分支指令存在与流水线中,需要5位&lt;/p>
&lt;p>所有在流水线中的分支指令会被分配一个编号值,编号会被保存在FIFO中,称为编号列表(tag list)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 348;
flex-basis: 836px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101.png" data-size="680x195">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101.png"
width="680"
height="195"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101_hu1585711271151754337.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101_hu6318652637317940402.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>
可以使用 (free tag list 和 tag list)来进行设计&lt;/p>
&lt;p>编号值不再被使用 : 分支指令成功retire , 分支预测失败 (分支预测失败之后就要根据编号来冲刷流水线了,所有编号可以回收了)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 152;
flex-basis: 365px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005.png" data-size="709x466">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005.png"
width="709"
height="466"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005_hu2549951271718018092.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005_hu616055593929496326.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="流水线抹去">流水线抹去&lt;/h4>
&lt;p>(1)发射之前的所有指令需要全部被抹去&lt;/p>
&lt;p>(2)流水线的发射阶段以及之后的流水段中,使用比寻找分支指令之后的指令全部抹去&lt;/p>
&lt;p>tag list 是顺序保存对应标号的 , 所以 比方说监测到分支指令3 预测失败,所以 0 ,1, 4 都需要被直接清除 , 因此通过广播编号值及将ROB中对应的指令置为无效&lt;/p>
&lt;p>一个周期内使用所有编号去抹去ROB的指令是不现实的,可以采取一个周期广播一个编号的方式 , 因为从取指到发射还是需要经过几个周期的,只要在这之前重排序缓存和发射队列指令被抹去了就行了&lt;/p>
&lt;p>编号值在解码阶段分配最合适 ,因为此时已经知道属于分支指令了&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 211;
flex-basis: 508px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101.png" data-size="830x392">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101.png"
width="830"
height="392"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101_hu15410874502044149990.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101_hu9376489831608965537.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于多条分支指令,通过控制第二条分支指令及其后面的所有指令在本周期不能进入解码阶段,可以避免使用多端口的FIFO来进行赋值&lt;/p>
&lt;h4 id="ptab-prediction-target-address--buffer">PTAB (Prediction Target Address Buffer)&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 284;
flex-basis: 683px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287.png" data-size="820x288">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287.png"
width="820"
height="288"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287_hu16483625173512044034.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287_hu641169617317350030.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过将分支指令的预测值保存到一个缓存中,使得其在执行阶段进行分支预测是否正确的检查时能够正确调用,并且可以只保存方向预测为跳转的分支指令 PTAB , (Prediction Target Address Buffer)&lt;/p>
&lt;p>&lt;del>它不是本身就在BTB中吗,为啥还要一个buffer&lt;/del>&lt;/p>
&lt;p>(1)valid , 表示PTAB中某个表项是否被占用, 当分支指令写入PATB时,置1,当完成检查之后,Reset&lt;/p>
&lt;p>(2)Predict Address,分支指令被预测的目标地址&lt;/p>
&lt;p>(3)Next PC, 分支指令的下一条PC , 如果预测错误,就直接使用其作为正确地址取指&lt;/p>
&lt;p>怎么去找PTAB对应的表项 ? 用 PC吗 ? 或者说用 Next PC吗&lt;/p>
&lt;p>写PTAB可以在取指阶段就完成&lt;/p>
&lt;p>自修改代码一般都会去清空分支预测器和I-Cache&lt;/p>
&lt;h2 id="超标量处理器的分支预测">超标量处理器的分支预测&lt;/h2>
&lt;p>由于超标量取一个地址,会取出多条指令,所以如果只使用取指令时的地址进行分支预测,相当于只是对指令你个组中的第一条指令进行分支预测&lt;/p>
&lt;p>可以使用公共地址寻址分支预测器 (对于4-way超标量处理器[31:4]),因为多数情况下,实际只有一条分支指令 .在BTB中需要记录下分支指令在四条指令中的位置,避免错误使用它的结果 (为什么指令会出现非对齐存储?)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 202;
flex-basis: 485px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971.png" data-size="457x226">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971.png"
width="457"
height="226"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971_hu9999926450411402190.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971_hu11458907609099289698.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 151;
flex-basis: 363px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518.png" data-size="824x544">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518.png"
width="824"
height="544"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518_hu6574895480496477885.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518_hu7626835333107781858.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="目标地址的预测">目标地址的预测&lt;/h3>
&lt;p>要对指令组的所有指令进行分支预测,需要得到所有指令的PC值,需要使用3个加法器实现PC地址的获取,&lt;/p>
&lt;p>但是由于需要同时获取四个PC值对应的目标地址,需要BTB支持四个读端口,即使采用交疊避免真正的多端口,但是硬件利用率还是较低&lt;/p>
&lt;p>在分支指令的方向预测完毕之后,利用结果信息再进行目标地址的预测,可以避免对于BTB部件的多端口需求,,这种方法对于方向预测和目标地址预测是串行的&lt;/p>
&lt;p>对于RISC指令,大多数指令是直接跳转类型,目标地址无需预测,在取指之后实际就可以被计算出来.实现这样的功能需要进行预解码&lt;/p>
&lt;h3 id="目标方向的预测">目标方向的预测&lt;/h3>
&lt;p>对于基于局部历史的分支预测方法来说,需要PHT和BHT支持多个读端口,可以通过交疊(interleaving)模拟实现多端口&lt;/p>
&lt;p>对于全局历史的分支预测,由于一个周期内进行分支预测的多条指令对应的GHR是不同的,需要进行特殊的处理&lt;/p>
&lt;p>交疊 : 7位地址Addr[6:0],通过Addr [1:0]进行寻址bank ,通过Addr[6:2]寻址bank对应的内容 ,就是使用多个单端口的存储器去组成多端口的功能&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 432px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926.png" data-size="811x450">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926.png"
width="811"
height="450"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926_hu1473716903533949269.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926_hu1420717281721194343.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>分支预测(概述+方向预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</link><pubDate>Tue, 15 Oct 2024 14:08:47 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;h3 id="分支预测需要的内容">分支预测需要的内容&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>方向，决定跳转与否&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标地址 决定跳转的目的地，riscv中有两种体现形式&lt;/p>
&lt;p>PC + 立即数，跳转范围受限。&lt;/p>
&lt;p>寄存器跳转，预测风险难度高，但是除了RETURN/CALL,一般建议不使用间接跳转。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="分支预测的解码">分支预测的解码&lt;/h3>
&lt;p>快速分辨出哪条指令是分支指令&lt;/p>
&lt;p>I-cache得出结果可能需要多个周期，这些周期无法得到准确的预测结果&lt;/p>
&lt;p>解码+分支预测放在一个周期 ， 严重影响周期时间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 205;
flex-basis: 494px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234.png" data-size="768x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234.png"
width="768"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234_hu5012368611020013998.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234_hu8871877114348964777.png 1024w"
loading="lazy"
alt="快速解码">
&lt;/a>
&lt;figcaption>快速解码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;del>可以在指令从L2 cache 写入到I-cache时进行快速解码,(pre-decode),然后将指令否是分支的信息也写入I-cache.&lt;/del>&lt;/p>
&lt;p>分支预测的最好时机是在当前周期得到去指令地址的时候&lt;/p>
&lt;p>可以直接通过PC值来进行分支预测，那就不需要进行解码了，但是只能够知道它是分支指令&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 220;
flex-basis: 530px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072.png" data-size="773x350">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072.png"
width="773"
height="350"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072_hu10962105718784769920.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072_hu3395612283536332007.png 1024w"
loading="lazy"
alt="pc分支预测">
&lt;/a>
&lt;figcaption>pc分支预测&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="分支预测的方向预测">分支预测的方向预测&lt;/h2>
&lt;p>跳转 （taken)和不发生跳转（not token）&lt;/p>
&lt;h3 id="一bit的跳转预测">一bit的跳转预测&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 290;
flex-basis: 697px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711.png" data-size="517x178">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711.png"
width="517"
height="178"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711_hu3772473742952120499.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711_hu6029973878094252562.png 1024w"
loading="lazy"
alt="image-20241015182744711">
&lt;/a>
&lt;figcaption>image-20241015182744711&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="基于两位饱和计数器2-bit-saturating-counter">基于两位饱和计数器（2-bit saturating counter)&lt;/h3>
&lt;p>根据分支前两次的结果预测下一次的结果&lt;/p>
&lt;h4 id="状态机">状态机&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 301;
flex-basis: 723px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601.png" data-size="654x217">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601.png"
width="654"
height="217"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601_hu6329958502138823409.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601_hu5922628540263514478.png 1024w"
loading="lazy"
alt="基于两位饱和计数器">
&lt;/a>
&lt;figcaption>基于两位饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>（1）计数器处于饱和状态，分支指令本次被预测发生跳转&lt;/p>
&lt;p>（2） 计数器处于不饱和状态，分支指令预测发生跳转&lt;/p>
&lt;p>（3） 计数器处于不饱和状态，分支指令预测不发生跳转&lt;/p>
&lt;p>（4） 计数器处于饱和状态，分支指令被预测不发生跳转&lt;/p>
&lt;p>初始状态位于 strongly not taken 或者 weakly not taken&lt;/p>
&lt;p>状态机处于饱和状态，只有两次预测失败才会改变预测的结果&lt;/p>
&lt;p>对于以下的情况，该种方法能够有50%的成功预测率&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 328;
flex-basis: 787px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299.png" data-size="279x85">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299.png"
width="279"
height="85"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299_hu12330989491748176683.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299_hu10712615227853934463.png 1024w"
loading="lazy"
alt="image-20241015184801299">
&lt;/a>
&lt;figcaption>image-20241015184801299&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>TTNTNTNTNT 对于这种情况，预测还是有问题，就是始终进入不了饱和，那还是相当于1bit&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431.png" data-size="632x397">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431.png"
width="632"
height="397"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431_hu1672855586108714933.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431_hu15441497882329938705.png 1024w"
loading="lazy"
alt="另外两种预测方法">
&lt;/a>
&lt;figcaption>另外两种预测方法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>情况1是如果两次连续的跳转，就直接变成饱和的强跳转，那就需要两次不跳转才能预测为不跳转&lt;/p>
&lt;p>情况2是如果两次连续的不跳转，就直接变成饱和的不跳转，那就需要两次跳转才能预测为跳转&lt;/p>
&lt;p>利用格雷码降低功耗，减少出错的概率&lt;/p>
&lt;p>对于一般的for循环，TTTTTTTTTTTTTTN ,只会出现2次预测失败 ，开始时 weakly not taken , 当再次执行for循环，第一次就会预测成功&lt;/p>
&lt;h4 id="存储方式">存储方式&lt;/h4>
&lt;p>每一个PC需要一个两位的饱和计数器， 32 位 PC需要 2^30 * 2b 存储器 ， 使用如下方法存储（PHT（Pattern History Table））: 使用 PC的一部分进行存储&lt;/p>
&lt;h5 id="别名-aliasing">别名 （aliasing)&lt;/h5>
&lt;p>不同PC有相同的饱和计数器，导致相互之间的干扰&lt;/p>
&lt;p>中立别名 ： 分支指令的方向一致&lt;/p>
&lt;p>破坏性别名 ： 分支指令的方向不一致&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 225;
flex-basis: 540px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722.png" data-size="655x291">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722.png"
width="655"
height="291"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722_hu9221241697137903403.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722_hu5725581828526846841.png 1024w"
loading="lazy"
alt="使用PC值的一部分来寻址饱和计数器">
&lt;/a>
&lt;figcaption>使用PC值的一部分来寻址饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 189;
flex-basis: 454px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012.png" data-size="563x297">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012.png"
width="563"
height="297"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012_hu2951182150190756820.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012_hu16224992082934435296.png 1024w"
loading="lazy"
alt="image-20241015194600012">
&lt;/a>
&lt;figcaption>image-20241015194600012&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="避免别名的方法--哈希表">避免别名的方法 —— 哈希表&lt;/h5>
&lt;p>哈希表能够压缩32位PC到一个比较小的值&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 472px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893.png" data-size="553x281">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893.png"
width="553"
height="281"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893_hu15927042566795541290.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893_hu8702642689007638371.png 1024w"
loading="lazy"
alt="image-20241015194955893">
&lt;/a>
&lt;figcaption>image-20241015194955893&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>更新时间点&lt;/p>
&lt;p>（1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新PHT 预测的结果更新PHT肯定不合理&lt;/p>
&lt;p>（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新PHT&lt;/p>
&lt;p>（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新PHT&lt;/p>
&lt;p>对于2,3，分支指令可能在PHT更新之前就被取过很多次了，会影响结果，但是影响的不多&lt;/p>
&lt;p>在乱序执行中，即使在执行阶段得到了一条分支指令的结果，也无法保证该结果是正确的，因为分支指令可能位于分支预测失败的路径上，所以（3）是最保险的&lt;/p>
&lt;p>顺序执行不会吗 ？ 不会 ，主要是乱序执行有可能前面的指令后于后面指令的执行 ，这样后面的指令不一定会执行&lt;/p>
&lt;h3 id="基于局部历史的分支预测">基于局部历史的分支预测&lt;/h3>
&lt;p>BHR(Branch History Register):分支历史寄存器&lt;/p>
&lt;p>通过一个寄存器记录一条分支指令在过去的历史状态&lt;/p>
&lt;p>n位BHR记录n次结果&lt;/p>
&lt;p>BHR和PHT一一对应，BHR有多少种取值，PHT有多少表项（entry)&lt;/p>
&lt;p>结果从BHR右侧移入，对应的BHR值改变对应的PHT&lt;/p>
&lt;p>那就相当于把一个PC对应的表项有进行了细分 -&amp;gt; 一个BHR和多个PHT&lt;/p>
&lt;p>如果一个序列，连续相同的数有p位，则虚了的循环周期为p,只要BHR不小于p,就可以做完美预测&lt;/p>
&lt;h4 id="寻址">寻址&lt;/h4>
&lt;p>如果进行全寻址的话 ， 1个PC值 需要 N位BTR + 2^N * 2 位PHT , 2^n 就需要 2^n（ N + 2^N * 2）&lt;/p>
&lt;p>所以需要PC部分值来寻址&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 238;
flex-basis: 571px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253.png" data-size="629x264">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253.png"
width="629"
height="264"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253_hu9089512783516302460.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253_hu16056882700841532627.png 1024w"
loading="lazy"
alt="image-20241016102002253">
&lt;/a>
&lt;figcaption>image-20241016102002253&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>1个PHT&lt;/strong>&lt;/p>
&lt;p>PC部分值寻址PHT,PC通过hash处理寻址BHT&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339.png" data-size="581x365">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339.png"
width="581"
height="365"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339_hu16419308451831036941.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339_hu17376103308489953844.png 1024w"
loading="lazy"
alt="image-20241016104245339">
&lt;/a>
&lt;figcaption>image-20241016104245339&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>异或（XOR)法&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 155;
flex-basis: 373px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111.png" data-size="727x467">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111.png"
width="727"
height="467"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111_hu15096252433589209338.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111_hu925909729055331567.png 1024w"
loading="lazy"
alt="位拼接法和异或法">
&lt;/a>
&lt;figcaption>位拼接法和异或法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="基于全局历史的分支预测">基于全局历史的分支预测&lt;/h3>
&lt;p>对一条分支指令进行分支预测，考虑前面分支指令的执行结果&lt;/p>
&lt;p>需要一个全局历史寄存器（GHR(global history register)),记录最近执行的所有分支指令的结果、&lt;/p>
&lt;p>最理想的情况是对每条分支指令都使用一个PHT&lt;/p>
&lt;p>一个全局寄存器 + 每一条分支指令对应的PHT&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 203;
flex-basis: 489px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117.png" data-size="650x319">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117.png"
width="650"
height="319"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117_hu9179660129570194615.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117_hu13364759526685380234.png 1024w"
loading="lazy"
alt="image-20241016144951117">
&lt;/a>
&lt;figcaption>image-20241016144951117&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>量变引起质变，当局部BHR少到只剩下一个的时候，就是全局GHR&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 176;
flex-basis: 423px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624.png" data-size="726x411">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624.png"
width="726"
height="411"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624_hu7324003174822261831.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624_hu16689410873822793480.png 1024w"
loading="lazy"
alt="image-20241016144931624">
&lt;/a>
&lt;figcaption>image-20241016144931624&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>两种分支预测方法&lt;/p>
&lt;p>&lt;strong>局部历史分支预测&lt;/strong>：基于分支指令自身在过去的执行状况来进行分支预测，对每一条分支指令都使用分支历史寄存器（BHR),并使用了由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个BHR的规律，使用BHR和PHT配合进行分支预测&lt;/p>
&lt;p>&lt;strong>全局历史分支预测&lt;/strong>：基于一条分支指令之前的一些分支指令的执行状况来进行分支预测，使用全局历史寄存器（GHR)记录所有分支指令的执行情况，由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个GHR的规律,使用GHR和PHT配合进行分支预测&lt;/p>
&lt;h3 id="竞争的分支预测">竞争的分支预测&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 134;
flex-basis: 323px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720.png" data-size="417x309">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720.png"
width="417"
height="309"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720_hu13974060394538718885.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720_hu8834002104162655463.png 1024w"
loading="lazy"
alt="竞争的分支预测原理图">
&lt;/a>
&lt;figcaption>竞争的分支预测原理图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 135;
flex-basis: 325px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271.png" data-size="506x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271.png"
width="506"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271_hu7667022521208126150.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271_hu9814928122482868099.png 1024w"
loading="lazy"
alt="竞争的分支预测_更详细的原理图">
&lt;/a>
&lt;figcaption>竞争的分支预测_更详细的原理图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>理想情况下每一条分支指令都有一个CPHT(choice PHT)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 143;
flex-basis: 345px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840.png" data-size="391x272">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840.png"
width="391"
height="272"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840_hu3776547309985000606.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840_hu13077989359135110784.png 1024w"
loading="lazy"
alt="CPHT中的两位饱和计数器">
&lt;/a>
&lt;figcaption>CPHT中的两位饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>当P1预测正确,P2预测错误时,计数器减1&lt;/li>
&lt;li>当P1预测错误,P2预测正确时,计数器加1&lt;/li>
&lt;li>当P1和P2预测结果一致时,不管预测正确与否,计数器保持不变&lt;/li>
&lt;/ol>
&lt;p>对于每一条指令,在GHR内容不同时,会导致使用不同的分支预测方法,所以将PC值与GHR进行相应运算再去寻址CPHT的地址.&lt;/p>
&lt;h3 id="分支预测的更新">分支预测的更新&lt;/h3>
&lt;h4 id="历史寄存器">历史寄存器&lt;/h4>
&lt;p>（1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新&lt;/p>
&lt;p>（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新,分支指令可能在错误预测的路径上,造成错误&lt;/p>
&lt;p>（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新 ,最保险的方法,但是浪费了性能&lt;/p>
&lt;p>一条分支指令b在时间t被分支预测,在时间 $t + \Delta t$ 从流水线退休, 任何在 $ \Delta t $内的时间被预测的分支指令都不会从分支指令的结果受益&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 479px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302.png" data-size="763x382">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302.png"
width="763"
height="382"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302_hu9275436089700128595.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302_hu11989386203258249376.png 1024w"
loading="lazy"
alt="image-20241016153738302">
&lt;/a>
&lt;figcaption>image-20241016153738302&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>采取方法1更新 ,但是会出现分支预测失败的情况 ,即使后续的分支指令使用的错误的 GHR ,由于他们在预测失败的路径上,都会从流水线中被抹去&lt;/p>
&lt;h5 id="修复ghr错误值的方法">修复GHR错误值的方法&lt;/h5>
&lt;h6 id="提交commit阶段修复法">提交(commit)阶段修复法&lt;/h6>
&lt;p>前端阶段Speculative GHR, 提交阶段放置一个 Ritired GHR, 在前端推测失败之后,需要等待分支指令退休的时候,将后端的GHR写到前端的GHR中,然后根据这条分支指令所指定的目标地址,重新取指令执行.&lt;/p>
&lt;p>该方法的缺点是会造成分支预测失败时惩罚的增大,(why?)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 231;
flex-basis: 556px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680.png" data-size="610x263">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680.png"
width="610"
height="263"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680_hu14721982168866039868.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680_hu14789759748200599315.png 1024w"
loading="lazy"
alt="利用提交阶段的GHR修复分支预测器的GHR">
&lt;/a>
&lt;figcaption>利用提交阶段的GHR修复分支预测器的GHR&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h6 id="checkpoint修复法">checkpoint修复法&lt;/h6>
&lt;p>在取指令阶段更新GHR时,可以把旧的GHR值保存起来,保存的内容称为checkpoint GHR .一旦分支指令的结果在流水线中被计算出来,就可以对分支指令的分支预测是否正确进行检查.如果分支预测正确,说明GHR中的值是正确的,如果预测失败,将这条分支指令对于的checkpoint GHR恢复到前端的GHR中,并从这条分支指令正确的目标地址开始取指令执行&lt;/p>
&lt;p>我的理解是把原来的GHR和分支预测结果的反向结合然后放进fifo中,在预测失败时把这个值取出来&lt;/p>
&lt;p>如果是顺序执行,读取存储器的方式也可以用FIFO,&lt;/p>
&lt;p>方式二是对方式一的一种补充,使得能够在执行阶段也去实现恢复&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 125;
flex-basis: 300px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973.png" data-size="509x407">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973.png"
width="509"
height="407"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973_hu2640580469089932493.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973_hu1193722294166550780.png 1024w"
loading="lazy"
alt="利用checkpoint的方法会GHR进行修复">
&lt;/a>
&lt;figcaption>利用checkpoint的方法会GHR进行修复&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="修复bhr错误值的方法">修复BHR错误值的方法&lt;/h5>
&lt;p>方式和修复GHR基本是类似的,并且BHR很少出现一条分支指令在流水线的提交阶段更新BHR,流水线中又出现了这条分支指令使用BHR进行分支预测的情况,除非循环体很短&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 302;
flex-basis: 725px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130.png" data-size="716x237">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130.png"
width="716"
height="237"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130_hu15264134084536464035.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130_hu13417008434328038782.png 1024w"
loading="lazy"
alt="image-20241016181356130">
&lt;/a>
&lt;figcaption>image-20241016181356130&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="两位饱和寄存器">两位饱和寄存器&lt;/h4>
&lt;p>由于饱和寄存器一般是处在饱和状态的,所以选择在分支指令退休的时候更新PHT的饱和计数器,也不会产生很大的负面影响&lt;/p>
&lt;h2 id="版权信息">版权信息&lt;/h2>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>超标量处理器概览</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link><pubDate>Mon, 14 Oct 2024 16:43:30 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid><description>&lt;h2 id="超标量处理器概览">超标量处理器概览&lt;/h2>
&lt;h3 id="超标量处理器的流水线">超标量处理器的流水线&lt;/h3>
&lt;h4 id="顺序执行">顺序执行&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 248;
flex-basis: 596px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png" data-size="1111x447">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png"
width="1111"
height="447"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu6270803957762553776.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu2445645561301413447.png 1024w"
loading="lazy"
alt="in-order pipline">
&lt;/a>
&lt;figcaption>in-order pipline&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>假设流水线每周期可以从 I-Cache 中取出两条指令来执行，则称为2-way 的超标量处理器，在指令经过解码之后，需要根据自身的类型，将两条指令送到对应的 FU 中执行，这个过程称为&lt;strong>发射(Issue)&lt;/strong>。在这个阶段，指令会读取寄存器而得到操作数，同时根据指令的类型，将指令送到对应的 FU 中进行执行。在执行阶段使用了三个 FU:第一个 FU 用来执行 ALU 类型的指令，第二个 FU 用来执行访问存储器类型的指令，第三个 FU 用来执行乘法操作，因为要保证流水线的写回(Write back)阶段是顺序执行的，因此所有 FU 都需要经历同样周期数的流水线，ScoreBoard 用来记录流水线中每条指令的执行情况，例如一条指令在哪个 FU 中执行，在什么时候这条指令可以将结果计算出来等， 一个典型的 ScoreBoard如下。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 156;
flex-basis: 375px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640.png" data-size="443x283">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640.png"
width="443"
height="283"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640_hu6690237057733442019.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640_hu17698180965633417655.png 1024w"
loading="lazy"
alt="scoreboard">
&lt;/a>
&lt;figcaption>scoreboard&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>P: Pending,表示指令的结果还没有写回到逻辑寄存器中。&lt;/p>
&lt;p>F:一条指令在哪个 FU 中执行，在将指令结果进行旁路时会使用这个信息。&lt;/p>
&lt;p>Result Position:在这个部分记录了一条指令到达 FU 中流水段的哪个阶段，3 表示指令处于 FU 流水线的第一个流水段，1 表示指令到达 FU 流水段的最后一个阶段， 0 表示指令处于流水线的写回阶段，在流水线的&lt;strong>发射&lt;/strong>阶段，会将指令的信息写到ScoreBoard 中，同时，这条指令会查询 ScoreBoard 来获知自己的源操作数是否都准备好了，在这条指令被送到 FU 中执行之后的每个周期，都会将这个值右移一位，这样使用这个值就可以表达出指令在 FU 中执行到哪个阶段，对于执行 ALU 类型指令的第一个 FU 来说，当指令到达 3 时，就可以将它的结果进行旁路了；而对于执行乘法指令的第三个 FU 来说，只有当指令到达 1 时，才可以将它的结果进行旁路。本书采取的应该是第二种。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 293;
flex-basis: 703px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774.png" data-size="1179x402">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774.png"
width="1179"
height="402"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774_hu1954438157205633643.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774_hu1187424182315409720.png 1024w"
loading="lazy"
alt="image-20241014210458774">
&lt;/a>
&lt;figcaption>image-20241014210458774&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>阻塞发生在译码级&lt;/p>
&lt;p>指令能够跳转到发射级的条件是scoreboard 对应处在级为2&lt;/p>
&lt;p>&lt;del>？一发就发两条，两条必须要同步吗&lt;/del> 应该只是由于下条导致的等待&lt;/p>
&lt;p>指令D不能提前发射应该就是由于需要等待指令C发射&lt;/p>
&lt;p>&lt;del>指令C无法进入执行是由于前递的问题，需要等待指令A的前递&lt;/del>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 695px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png" data-size="1002x346">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png"
width="1002"
height="346"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu1110554545418232987.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu2239682821483300699.png 1024w"
loading="lazy"
alt="image-20241014212008795">
&lt;/a>
&lt;figcaption>image-20241014212008795&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="乱序执行">乱序执行&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 263;
flex-basis: 632px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599.png" data-size="1096x416">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599.png"
width="1096"
height="416"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599_hu3570244685790815188.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599_hu18113048283906519492.png 1024w"
loading="lazy"
alt="乱序执行流水线">
&lt;/a>
&lt;figcaption>乱序执行流水线&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>解码(Decode)阶段&lt;/strong>：为了在乱序执行时解决 WAW 和 WAR 这两种相关性，需要对寄存器进行&lt;strong>重命名(register renaming),&lt;strong>这个过程可以在&lt;/strong>流水线的解码(Decode)&lt;strong>阶段完成，也可以单独使用一个流水段来完成，处理器中需要增加&lt;/strong>物理寄存器堆(Physical Register File, PRF)来配合对指令集中定义的寄存器( Architecture Register File,ARF)进行重命名&lt;/strong>，PRF 中寄存器的个数要多于 ARF。&lt;/p>
&lt;p>**Dispatch(分发):**在这个阶段，被重命名之后的指令会按照程序中规定的顺序，写到发射队列(Issue Queue)、重排序缓存(ROB)和 Store Buffer 等部件中，如果在这些部件中没有空闲的空间可以容纳当前的指令，那么这些指令就需要在流水线的重命名阶段进行等待，这就相当于暂停了寄存器重命名以及之前的所有流水线，直到这些部件中有空闲的空间为止。分发阶段可以和寄存器重命名阶段放在一起，在一些对周期时间要求比较紧的处理器中，也可以将这个部分单独使用一个流水段。&lt;/p>
&lt;p>&lt;strong>发射(Issue)阶段&lt;/strong>：一旦指令的操作数准备好了，就可以从发射队列中离开，送到对应的 FU 中执行，因此发射阶段是流水线从&lt;strong>顺序执行到乱序&lt;/strong>执行的分界点。每个 FU 都有自己的流水线级数，在这种流水线中，由于每个 FU 的执行周期数都不相同，所以指令在流水线的写回(Write Back)阶段是乱序的，在这个阶段，一条指令只要计算完毕， 就会将结果写到 PRF中，由于分支预测失败( mis-prediction)或者异常( exception)的存在，PRF 中的结果未必都会写到 ARF 中，因此也将 PRF 称为 Future File。&lt;/p>
&lt;p>&lt;strong>Register File Read(读取寄存器)&lt;/strong>:被仲裁电路选中的指令需要从物理寄存器堆(Physical Register File,PRF)中读取操作数，一般情况下，被仲裁电路选中的指令可以从PRF 中得到源操作数，当然还有“不一般”的情况，那就是指令不能从 PRF 中得到操作数， 但是却可以在送到 FU 中执行之前，从旁路网络(bypassing network)中得到操作数，事实上很大一部分指令都是通过旁路网络获得操作数的，这也为减少 PRF 的读端口提供了可能。由于超标量处理器每周期需要执行好几条指令，PRF 所需要的端口个数也是比较多的，多端口寄存器堆的访问速度一般都不会很快，因此在现实世界的处理器中，这个阶段都会单独使用一个流水段。&lt;/p>
&lt;p>&lt;strong>提交(Commit)阶段&lt;/strong>：为了保证程序的串行结果，指令需要按照程序中规定的顺序更新处理器的状态，这需要使用一个称为&lt;strong>重排序缓存(ROB)&lt;strong>的部件来配合，流水线中的所有指令都按照程序中规定的顺序存储在重排序缓存中，使用重排序缓存来实现程序对处理器状态的顺序更新，一条指令在这个阶段，会将它的结果从 PRF 搬移到 ARF 中，同时&lt;/strong>重排序缓存也会配合完成对异常(exception)的处理&lt;/strong>，如果不存在异常，那么这条指令就可以顺利地离开流水线， 并对处理器的状态进行更改，此时称这条&lt;strong>指令退休(retire)了&lt;/strong>，一条指令一旦退休，它就再也不可能回到之前的状态了。&lt;/p>
&lt;p>因为 store 指令需要写存储器，如果在流水线的写回阶段就将 store 指令的结果写到存储器中，那么一旦由于分支预测失败或者异常等原因，需要将这条 store 指令从流水线中抹掉时，就没有办法将存储器的状态进行恢复了，因为存储器中原来的值已经被覆盖， &lt;strong>Store Buffer(SB),来存储 store 指令没有退休之前的结果&lt;/strong>，s&lt;strong>tore 指令在流水线的写回阶段，会将它的结果写到 Store Buffer 中，只有一条 store 指令真的从流水线中退休的时候，才可以将它的值从 Store Buffer 写到存储器中&lt;/strong>。使用了这个部件之后，Load 指令此时除了从 D-Cache 中寻找数据，还需要从 Store Buffer 中进行查找，这样在一定程度上增加了设计的复杂度。&lt;/p>
&lt;p>在重排序这里也会处理异常 ， 如果没有异常就会写入ARF, 并成功退休，但是无论有没有异常都会写入SB。退休了才可以去修改相应状态。&lt;/p>
&lt;p>发射阶段选择相应的指令并且送到FU,被选择的指令才会去读取物理寄存器&lt;/p>
&lt;p>写回阶段进行统一旁路，为什么我写的RISCV有这么多的旁路网络 ?&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 267;
flex-basis: 643px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323.png" data-size="946x353">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323.png"
width="946"
height="353"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323_hu5637503064892761083.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323_hu14369550668972739287.png 1024w"
loading="lazy"
alt="image-20241015131538323">
&lt;/a>
&lt;figcaption>image-20241015131538323&lt;/figcaption>
&lt;/figure>
&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 695px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png" data-size="1002x346">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png"
width="1002"
height="346"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu1110554545418232987.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu2239682821483300699.png 1024w"
loading="lazy"
alt="image-20241014212008795">
&lt;/a>
&lt;figcaption>image-20241014212008795&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处&lt;/p></description></item><item><title>乱序执行CPU</title><link>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</link><pubDate>Sat, 12 Oct 2024 16:08:08 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</guid><description>&lt;h2 id="tomasulos-algorithm">Tomasulo&amp;rsquo;s algorithm&lt;/h2>
&lt;h3 id="tomasulos-algorithm创新">Tomasulo‘s algorithm创新&lt;/h3>
&lt;p>Tomasulo算法的主要创新包括硬件实现的寄存器重命名、为所有执行单元设计的保留站（reservation stations），以及一个公共数据总线（CDB），通过该总线计算出的值可以广播到所有可能需要它们的保留站。这些创新使得指令能够实现更好的并行执行，避免在使用记分板或其他早期算法时可能导致的停滞.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 155;
flex-basis: 373px"
>
&lt;a href="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture.png" data-size="1280x822">
&lt;img src="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture.png"
width="1280"
height="822"
srcset="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture_hu16291643218958583948.png 480w, https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture_hu13189868510601512322.png 1024w"
loading="lazy"
alt="Tomasulo_Architechure">
&lt;/a>
&lt;figcaption>Tomasulo_Architechure&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="cdb总线">CDB总线&lt;/h3>
&lt;p>公共数据总线（CDB）将保留站直接连接到功能单元。根据Tomasulo的设计，它“在保持优先顺序的同时促进并发执行” 。这带来了两个重要影响：&lt;/p>
&lt;ol>
&lt;li>功能单元可以直接访问任何操作的结果，而无需通过浮点寄存器。这使得多个等待同一结果的单元可以继续执行，而不必等待解决对寄存器文件读端口的争用问题。&lt;/li>
&lt;li>危险检测和控制执行是分布式的。保留站负责控制指令何时可以执行，而不是依赖一个专门的危险单元来进行统一管理。&lt;/li>
&lt;/ol>
&lt;h3 id="指令顺序">指令顺序&lt;/h3>
&lt;p>指令是按顺序发出的，因此即使它们是乱序执行的（即非顺序执行），指令序列的效果（如指令引发的异常）仍然会按照顺序执行处理器中的顺序发生。这确保了乱序执行不会影响程序的正确性和预期行为&lt;/p>
&lt;h4 id="寄存器重命名">寄存器重命名&lt;/h4>
&lt;p>Tomasulo算法通过寄存器重命名来实现正确的乱序执行。所有的通用寄存器和保留站寄存器要么保存真实值，要么保存占位符值。如果在发射阶段某个目标寄存器的真实值不可用，则最初会使用占位符值。占位符值是一个标签，指示哪个保留站将生成真实值。当功能单元完成计算并在公共数据总线（CDB）上广播结果时，占位符将被真实值替换。&lt;/p>
&lt;p>每个功能单元都有一个保留站。保留站保存执行单条指令所需的信息，包括操作和操作数。当功能单元空闲且指令所需的所有源操作数均为真实值时，功能单元便开始处理指令。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://jia.je/hardware/2021/09/14/brief-into-ooo/#%E7%BB%8F%E5%85%B8-tomasulo" target="_blank" rel="noopener"
>乱序执行CPU&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Tomasulo%27s_algorithm" target="_blank" rel="noopener"
>wikipedia Tomasulo&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</title><link>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</link><pubDate>Thu, 10 Oct 2024 14:23:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。&lt;/p>
&lt;h2 id="introduction">introduction&lt;/h2>
&lt;p>乱序执行处理器上的超前执行不会将长延迟操作“移开”（这需要在指令窗口中缓冲它及其后面的指令），而是将其扔出指令窗口。&lt;/p>
&lt;p>当指令窗口被一个长延迟操作阻塞时，架构寄存器文件(architectural register file)的状态会被checkpoint保存。然后处理器进入“&lt;strong>超前运行模式&lt;/strong>”。它为阻塞操作分配一个虚假结果并将其扔出指令窗口。阻塞操作后的指令被**获取、执行，并以伪退休（pseudo-retired）**的方式从指令窗口中移除。当阻塞操作完成时，处理器重新进入“&lt;strong>正常模式&lt;/strong>”。此时，它会恢复之前保存的检查点状态，并从阻塞操作开始重新获取和执行指令。
伪退出(pseudo-retire):指令按照传统意义上的方式执行和完成，只是它们不更新架构状态。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 150;
flex-basis: 361px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456.png" data-size="1193x793">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456.png"
width="1193"
height="793"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456_hu10562838702254261104.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456_hu2604305733844358238.png 1024w"
loading="lazy"
alt="image-20241012153516456">
&lt;/a>
&lt;figcaption>image-20241012153516456&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Runahead 的好处来自于将被长延迟操作阻塞的小指令窗口转换为非阻塞窗口，从而使其具有大得多的窗口的性能。&lt;/p>
&lt;p>在这篇论文中，仅评估了runahead mode对于在二级缓存失效的内存操作的表现，尽管它也可以在任何阻塞指令窗口的长延迟操作上启动。基于英特尔奔腾4处理器的机器模型，该处理器拥有&lt;strong>128个条目的指令窗口&lt;/strong>。
首先展示了当前的乱序执行引擎无法容忍长延迟的主存访问时间。接下来，展示了runahead mode如何更好地应对这些延迟，并且能够达到一个具有更大指令窗口的机器的性能。&lt;/p>
&lt;h2 id="relate-work">Relate work&lt;/h2>
&lt;p>暂无&lt;/p>
&lt;h2 id="out-of-order-execution-and-memory-latency-tolerance乱序执行和内存容忍度">Out-of-order execution and memory latency tolerance(乱序执行和内存容忍度)&lt;/h2>
&lt;h3 id="instruction-and-scheduling-windows">Instruction and scheduling windows&lt;/h3>
&lt;p>乱序执行比顺序执行更能容忍缓存缺失，因为它能够调度与缓存缺失无关的操作。乱序执行的机器通过两个窗口实现这一点：&lt;strong>指令窗口和调度窗口。&lt;/strong>
指令窗口保存所有已解码但尚未提交到架构状态的指令，其主要目的是保证指令按顺序退休，以支持精确异常。
调度窗口包含指令窗口中的一部分指令，其主要目的是每个周期搜索那些准备好执行的指令，并对它们进行调度执行。&lt;/p>
&lt;p>当一个长延迟操作发生时，它会阻塞指令窗口，直到操作完成。尽管后续的指令可能已经执行完成，但它们无法从指令窗口中退休。如果操作的延迟时间足够长，并且指令窗口不够大，指令会在窗口中堆积，最终导致指令窗口被填满。此时，机器会停顿并停止向前执行。&lt;/p>
&lt;h3 id="memory-latency-tolerance">Memory latency tolerance&lt;/h3>
&lt;p>取指理想 变 调度窗口 L2理想程度 指令窗口&lt;/p>
&lt;p>图 1 显示了七台不同机器的指令窗口停滞的周期百分比。每个栏顶部的数字是机器的IPC。该数据是所有模拟基准的平均值。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 137;
flex-basis: 330px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124.png" data-size="407x296">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124.png"
width="407"
height="296"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124_hu10965257689849940883.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124_hu1293429106633126320.png 1024w"
loading="lazy"
alt="具有完整指令窗口停顿的周期的百分比">
&lt;/a>
&lt;figcaption>具有完整指令窗口停顿的周期的百分比&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Runahead 的性能优势来自于将指令提取到提取引擎的缓存中，并执行未命中一级或二级缓存的独立加载和存储。&lt;/p>
&lt;h2 id="implementation-of-runahead-execution-in-an-out-of-order-processor">Implementation of runahead execution in an out-of-order processor&lt;/h2>
&lt;p>在本节中，我们描述了在乱序处理器上实现超前执行的情况，其中&lt;strong>指令在被调度后并在执行之前访问寄存器文件&lt;/strong>。Intel Pentium 4 处理器 [13]、MIPS R10000 微处理器 [30] 和 Compaq Alpha 21264 处理器 [18] 是这种微架构的例子。在其他一些微架构中，例如 Intel Pentium Pro 处理器 [12]，&lt;strong>指令在放入调度器之前访问寄存器文件&lt;/strong>。&lt;/p>
&lt;p>Frontend RAT(Register Alias Table)用于重命名传入指令，并包含架构寄存器到物理寄存器的推测映射。&lt;/p>
&lt;p>Retirement RAT 包含指向包含已提交架构值的物理寄存器的指针。它用于在分支错误预测和异常之后恢复状态。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 140;
flex-basis: 338px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755.png" data-size="984x698">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755.png"
width="984"
height="698"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755_hu4585166472539683948.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755_hu9334271057527929535.png 1024w"
loading="lazy"
alt="image-20241010195821755">
&lt;/a>
&lt;figcaption>image-20241010195821755&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="entering-runahead-mode">Entering runahead mode&lt;/h3>
&lt;p>**当内存操作在二级缓存中未命中且该内存操作到达指令窗口的头部时，处理器进入超前执行模式。**导致进入超前执行模式的指令地址会被记录。为了在从超前运行模式退出时正确恢复架构状态，处理器对架构寄存器文件的状态进行检查点。出于性能原因，处理器还检查分支历史寄存器和返回地址堆栈的状态。&lt;/p>
&lt;p>架构寄存器文件的检查点可以通过复制提交寄存器别名表（RAT）指向的物理寄存器内容来完成，但这可能需要时间。&lt;strong>为了避免因复制导致的性能损失，处理器可以在正常模式下不断更新检查点的架构寄存器文件&lt;/strong>。当非超前指令从指令窗口中提交时，它会将其结果更新到检查点寄存器文件中的架构目标寄存器。这样检查点操作不会浪费任何时钟周期。&lt;/p>
&lt;p>尽管Retirement RAT 在正常模式下指向架构寄存器状态，但在超前运行模式下它指向伪架构寄存器状态并反映伪退休指令更新的状态&lt;/p>
&lt;h3 id="execution-in-runahead-mode">Execution in runahead mode&lt;/h3>
&lt;p>&lt;strong>无效位和指令&lt;/strong>:每个物理寄存器都有一个与其关联的无效（INV）位，&lt;strong>以指示它是否具有虚假值&lt;/strong>。任何源自设置了无效位的寄存器的指令都是无效指令。 INV 位用于防止使用虚假数据进行虚假预取和分支解析。
如果存储指令是无效的，它会在前置执行期间将一个 INV 值引入内存映像。为了处理前置模式下数据值（和 INV 值）通过内存的通信，我们使用一个小的“前置缓存”，它与一级数据缓存并行访问。&lt;/p>
&lt;p>&lt;strong>INV 值的传播&lt;/strong>:引入 INV 值的第一条指令是导致处理器进入runahead mode的指令,如果这条指令是加载指令，它会将其物理目的寄存器标记为 INV。如果它是存储指令，则会在前置缓存中分配一行，并将其目标字节标记为 INV。任何无效的指令在调度或执行后写入寄存器时，会将该寄存器标记为 INV。任何有效的操作在写入寄存器时，会重置其目的寄存器的 INV 位。&lt;/p>
&lt;h4 id="runahead-store-operations-and-runahead-cache">Runahead store operations and runahead cache&lt;/h4>
&lt;p>先行存储(store)指令不会将其结果写入任何地方。因此，依赖于有效先行存储的先行加载被视为无效指令并被丢弃。由于寄存器数量有限，因此将&lt;strong>先行存储(store)&lt;strong>的结果&lt;/strong>转发&lt;/strong>到&lt;strong>先行加载(load)&lt;strong>对于高性能至关重要。
如果存储及其相关加载都在指令窗口中，则此转发是通过当前乱序处理器中已存在的&lt;/strong>store buffer&lt;/strong>来完成的。
如果超前运行加载依赖于已经pseudo-retired的超前运行存储（这意味着该存储不再位于存储缓冲区中），则它应该从某个其他位置获取存储的结果。1是写入data cache ,2是弄一个大的fully-associative buffer。&lt;/p>
&lt;p>使用 runahead cache 来保存伪退休先行存储的结果和 INV 状态 ，提供指令之间的数据和INV状态的通信。为了支持存储和加载之间 INV 位的正确通信，&lt;strong>存储缓冲区&lt;/strong>中的每个条目和runahead cache 中的每个字节都有一个相应的 INV 位。runahead cache 的每个字节还有另一个与其关联的位（STO 位），指示存储是否已写入该字节。仅当访问的字节由存储写入（设置了 STO 位）并且访问runahead cache 有效时，对超前运行高速缓存的访问才会导致命中。&lt;/p>
&lt;p>更新 INV 和 STO的规则:&lt;/p>
&lt;ol>
&lt;li>当有效的先行存储完成执行时，它将其数据写入其存储缓冲区条目（就像在普通处理器中一样）并重置该条目的关联 INV 位。同时，它查询数据缓存，如果数据缓存未命中，则向内存层次结构发送预取请求。（为什么store 要查 data cache）&lt;/li>
&lt;li>当一个无效的先行存储被scheduled时，它会set其相关store buff条目的 INV 位。&lt;/li>
&lt;li>当一个有效的先行存储离开指令窗口时，它会将其结果写入预运行缓存，并重置已写入字节的 INV 位。同时，它还会设置已写入字节的 STO 位。&lt;/li>
&lt;li>当一个无效的先行存储离开指令窗口时，如果其地址有效，它会设置写入字节的 INV 位和 STO 位&lt;/li>
&lt;li>先行存储从不将结果写入数据缓存。&lt;/li>
&lt;/ol>
&lt;p>当存储操作的地址无效时，存储操作会被简单地视为一个空操作（NOP）。由于加载操作无法识别与这些无效存储操作的依赖关系，它们可能会错误地从内存中加载一个陈旧的值。这个问题可以通过使用&lt;strong>内存依赖预测器&lt;/strong>来缓解，**预测器可以识别无效地址存储操作与其依赖的加载操作之间的依赖关系。**一旦依赖关系被识别，如果存储操作的数据值是无效的，则加载操作会被标记为无效（INV）；如果存储操作的数据值是有效的，则可以将其forward给加载操作。&lt;/p>
&lt;h4 id="runahead-load-operations">Runahead load operations&lt;/h4>
&lt;p>runahead load invalid :&lt;/p>
&lt;ol>
&lt;li>
&lt;p>源自无效的物理寄存器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>依赖于store buffer中标记为无效（INV）的存储操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>依赖于一个已经伪退休且是无效（INV）的存储操作(runahead cache)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有效load会并行访问3个结构 ： data cache , runahead cache , store buffer .&lt;/p>
&lt;p>加载操作命中store buffer ，并且命中的条目被标记为有效，那么加载操作会从store buffer获取数据。
加载操作命中store buffer ，并且命中的条目被标记为无效（INV），那么加载操作会将其物理目标寄存器标记为无效（INV）。&lt;/p>
&lt;p>只有当加载指令访问的cache line有效且其访问的任何字节的 STO 位被set时，该加载才被视为在&lt;strong>runahead cache 中命中&lt;/strong>。
&lt;strong>如果load在store buffer未命中但在runahead cache 命中&lt;/strong>，则它会检查在runahead cache 访问的字节的 INV 位。如果没有INV 位set ，将使用runahead cache 中的数据。如果任意一个源数据字节被标记为 INV，则将其目标标记为INV。
&lt;strong>如果load在store buffer和runahead cache 都未命中，但在data cache中命中&lt;/strong>，则它将使用data cache中的值，并被视为Valid。然而，由于以下两个原因，它实际上可能是无效的：1）它可能依赖于具有 INV 地址的store，或者 2）它可能依赖于一个 INV store，该store在runahead cache中将其目标字节标记为 INV，但由于冲突，相应的runahead cache被释放。然而，这两种情况都是罕见的，不会显著影响性能。&lt;/p>
&lt;p>&lt;strong>如果加载在所有三个结构中都未命中&lt;/strong>，它会向L2 cache 发送请求以获取其数据。如果该请求在L2 cache 中命中，则数据将从L2 cache 传输到L1 cache ，加载完成其执行。如果请求在L2 cache 中未命中，加载会将其&lt;strong>目标寄存器&lt;/strong>标记为 INV，并像导致进入runahead mode的加载那样(未命中L1 cache)从调度器中移除。该请求会发送到内存像一个未命中 L2 缓存的&lt;strong>正常加载请求&lt;/strong>一样。&lt;/p>
&lt;p>store buffer &amp;gt; runahead cache &amp;gt; data cache &amp;gt; L2 cache&lt;/p>
&lt;h4 id="execution-and-prediction-of-branches">Execution and prediction of branches&lt;/h4>
&lt;p>在runahead mode中，分支的预测和解决方式与正常模式完全相同，唯一的区别是：具有 INV 源(寄存器标记为INV)的分支（与所有分支一样）被预测并以推测的方式更新全局分支历史寄存器，但与其他分支不同，它永远无法被解决。如果分支被正确预测，这不是问题。然而，如果分支预测错误，处理器在获取到该分支后将始终处于错误路径，直到遇到一个与控制流无关的点。我们将获取到错误预测的 INV 分支的程序中的点称为“分歧点”。分歧点的存在不一定对性能有害，但正如我们稍后将展示的，分歧点在runahead mode中出现得越晚，性能提升就越好。&lt;/p>
&lt;p>与分支预测相关的一个有趣问题是前置模式下分支预测器表的训练策略。一种选择——也是我们实现中采用的选项——是始终训练分支预测器表。如果一个分支首先在前置模式下执行，然后在正常模式下执行，这种策略将导致同一个分支对分支预测器进行两次训练。因此，预测器表的性能得到了增强，计数器可能会失去滞后效应。第二种选择是绝不在前置模式下训练分支预测器。这会导致前置模式下的分支预测准确率降低，从而降低性能，并使分歧点更接近前置入口点。第三种选择是始终在前置模式下训练分支预测器，但同时使用一个队列将前置模式下分支的结果传递给正常模式。在正常模式下，如果存在预测，则使用该队列中的预测来进行分支预测。如果一个分支使用来自队列的预测进行预测，则不会再次训练预测器表。第四种选择是为前置模式和正常模式使用两个独立的预测器表，并在进入前置模式时将正常模式的表信息复制到前置模式。这一选项在硬件实现上成本较高，但我们进行了模拟以确定第一种选项的双重训练策略有多重要。我们的结果显示，与第四种选择相比，二次训练分支预测器表条目并没有显著降低性能。&lt;/p>
&lt;h4 id="instruction-pseudo-retirement-during-runahead-mode">Instruction pseudo-retirement during runahead mode.&lt;/h4>
&lt;p>在runahead mode下，指令按照程序顺序离开指令窗口。&lt;strong>如果某条指令到达指令窗口的队头，它将被考虑进行pseudo-retire。&lt;/strong>
如果被考虑pseudo-retire的指令是无效的（INV），它会立即从窗口中移除。
如果指令是有效的，它需要等待执行完毕（此时它可能变为无效的），并将结果写入物理寄存器文件。在pseudo-retire时，一条指令会释放为其执行分配的所有资源。&lt;/p>
&lt;p>无论是有效还是无效的指令，在它们离开指令窗口时都会更新退休重命名表（Retirement RAT）。退休重命名表不需要存储与每个寄存器关联的无效（INV）位，因为物理寄存器已经各自关联了无效位。&lt;/p>
&lt;h4 id="exiting-runahead-mode">Exiting runahead mode&lt;/h4>
&lt;p>任何时候可以退出 runahead mode , 所有在处理器中执行的指令都会被清除，它们的缓冲区会被释放。检查点保存的架构寄存器文件会复制到物理寄存器文件的预定部分。前端和退休的重命名表（RAT）也会被修复，以便它们指向保存架构寄存器值的物理寄存器。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="知识点补充">知识点补充&lt;/h3>
&lt;h4 id="store-buffer">store buffer&lt;/h4>
&lt;h4 id="分支预测">分支预测&lt;/h4>
&lt;h4 id="architectural-register">Architectural Register&lt;/h4>
&lt;p>架构寄存器是指每个CPU独有的一组全局寄存器，这些寄存器不与其他CPU共享。它们可以存储任意类型的数据，并且能够在CPU内部的线程之间实现快速通信。&lt;/p>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://www.sciencedirect.com/topics/computer-science/architectural-register" target="_blank" rel="noopener"
>architectural register&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://jia.je/hardware/2021/09/14/brief-into-ooo/#%E8%83%8C%E6%99%AF" target="_blank" rel="noopener"
>浅谈乱序执行CPU&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Chipyard Learning</title><link>https://VastCircle.github.io/2024/chipyard-learning/</link><pubDate>Mon, 07 Oct 2024 16:15:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard-learning/</guid><description>&lt;h2 id="chipyard-从下载到构建">chipyard 从下载到构建&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone https://github.com/ucb-bar/chipyard.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> chipyard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout 1.10.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 为了使得clone顺利，把http都换成ssh ，使用命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find . -name &lt;span style="color:#98c379">&amp;#34;.gitmodules&amp;#34;&lt;/span> -type f -exec sed -i &lt;span style="color:#98c379">&amp;#39;s/https:\/\/github.com\//git@github.com:/g&amp;#39;&lt;/span> &lt;span style="color:#56b6c2">{}&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule sync
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 运行初始化脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./build-setup.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 导入conda环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">source&lt;/span> ./env.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">## 初始化software ，例如coremark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ./scripts/init-software.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置一个2核心soc">配置一个2核心soc&lt;/h2>
&lt;h3 id="chipyard-配置文件">chipyard 配置文件&lt;/h3>
&lt;p>chipyard的配置文件是在&lt;code>chipyard/generators/chipyard/src/main/scala/config&lt;/code>中，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">MyCoreConfigs&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e5c07b">Config&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">freechips&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">rocketchip&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">subsystem&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e5c07b">WithNBigCores&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">2&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span> &lt;span style="color:#7f848e">// single rocket-core
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">chipyard&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">config&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e5c07b">AbstractConfig&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在sim/verilator界面去执行命令,可以生成文件 simulator-chipyard-MyCoreConfig&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>make &lt;span style="color:#e06c75">CONFIG&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>MyCoreConfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="裸机编译riscv">裸机编译riscv&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#include&lt;/span> &lt;span style="color:#7f848e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#7f848e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#61afef;font-weight:bold">main&lt;/span>(&lt;span style="color:#e5c07b">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#61afef;font-weight:bold">printf&lt;/span>(&lt;span style="color:#98c379">&amp;#34;Hello, World!&lt;/span>&lt;span style="color:#98c379">\n&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">return&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ riscv64-unknown-elf-gcc -fno-common -fno-builtin-printf -specs&lt;span style="color:#56b6c2">=&lt;/span>htif_nano.specs -c hello.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ riscv64-unknown-elf-gcc -static -specs&lt;span style="color:#56b6c2">=&lt;/span>htif_nano.specs hello.o -o hello.riscv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ spike hello.riscv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-fno-common&lt;/li>
&lt;/ul>
&lt;p>​ 默认情况下，C语言会将未初始化的全局变量放在一个“common”区域，可以被多个文件共享。&lt;code>-fno-common&lt;/code> 禁止这种行为，要求每个未初始化的全局变量必须在一个文件中定义。&lt;/p>
&lt;ul>
&lt;li>-fno-builtin-printf&lt;/li>
&lt;/ul>
&lt;p>​ 禁用编译器内置的 &lt;code>printf&lt;/code> 函数，强制使用标准库中的 &lt;code>printf&lt;/code> 函数&lt;/p>
&lt;ul>
&lt;li>-specs=htif_nano.specs&lt;/li>
&lt;/ul>
&lt;p>​ &lt;code>htif_nano.specs&lt;/code> 可能是为特定硬件平台（例如 RISC-V）的模拟环境或硬件接口（HTIF）准备的编译和链接配置，确保生成的代码可以在特定环境中运行&lt;/p>
&lt;ul>
&lt;li>
&lt;p>-static&lt;/p>
&lt;p>强制使用静态链接库，而不是动态链接库。所有需要的库代码都会在编译时直接链接到生成的可执行文件中，而不是在运行时动态加载。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="生成波形">生成波形&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>make run-binary-debug &lt;span style="color:#e06c75">BINARY&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>test.riscv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应该是要重新编译前文生成的bin文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 方法1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make run-binary-debug &lt;span style="color:#e06c75">BINARY&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>test.riscv &lt;span style="color:#e06c75">CONFIG&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>MyCoreConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 方法2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./simulator-chipyard-RocketConfig &lt;span style="color:#e06c75">$RISCV&lt;/span>/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在output/chipyard.harness.TestHarness.MyCoreConfig 可以看到hello.vcd&lt;/p>
&lt;p>使用 gtkwave可以打开hello.vcd 查看&lt;/p>
&lt;h3 id="rocket-chip">rocket chip&lt;/h3>
&lt;div align=center>&lt;img src="rocket-chip 图表.png" alt="123" style="zoom:50%;" />&lt;/div>
&lt;h4 id="tiles">tiles&lt;/h4>
&lt;p>每个&lt;code>Rocket&lt;/code>核心都与一个页表遍历器、L1 指令缓存和 L1 数据缓存组合成一个&lt;code>RocketTile&lt;/code>&lt;/p>
&lt;p>每个 CPU 块都有一个 L1 指令缓存和 L1 数据缓存。这些缓存的大小和关联性可以配置。默认&lt;code>RocketConfig&lt;/code> 使用 16 KiB、4 路组关联指令和数据缓存&lt;/p>
&lt;h4 id="memory-system">Memory System&lt;/h4>
&lt;p>这些图块(Tiles)连接到&lt;code>SystemBus&lt;/code>，后者将其连接到 L2 缓存组。然后，L2 缓存组连接到&lt;code>MemoryBus&lt;/code>，后者通过 TileLink 到 AXI 转换器连接到 DRAM 控制器&lt;/p>
&lt;div align=center>&lt;img src="image-20241009152035016.png" alt="Momory System" style="zoom:50%;" /> &lt;/div>
&lt;h4 id="mmio">MMIO&lt;/h4>
&lt;p>对于 MMIO 外围设备，&lt;code>SystemBus&lt;/code>连接到&lt;code>ControlBus&lt;/code>和&lt;code>PeripheryBus&lt;/code>&lt;/p>
&lt;p>&lt;code>ControlBus&lt;/code>连接标准外围设备，如 BootROM、平台级中断控制器 (PLIC)、核心本地中断 (CLINT) 和调试单元&lt;/p>
&lt;h5 id="bootrom">BootROM&lt;/h5>
&lt;p>BootROM 包含第一阶段引导加载程序，即系统复位后运行的第一条指令。它还包含设备树，Linux 会使用它来确定连接了哪些其他外设，具体在 /generators/rocket-chip/bootrom&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">#define DRAM_BASE 0x80000000
.section .text.start, &amp;#34;ax&amp;#34;, @progbits
.globl _start
_start:
csrwi 0x7c1, 0 // disable chicken bits
li s0, DRAM_BASE
csrr a0, mhartid
la a1, _dtb
jr s0
.section .text.hang, &amp;#34;ax&amp;#34;, @progbits
.globl _hang
_hang:
csrwi 0x7c1, 0 // disable chicken bits
csrr a0, mhartid
la a1, _dtb
csrwi mie, 0
1:
wfi
j 1b
.section .rodata.dtb, &amp;#34;a&amp;#34;, @progbits
.globl _dtb
.align 5, 0
_dtb:
.ascii &amp;#34;DTB goes here&amp;#34;
&lt;/code>&lt;/pre>&lt;p>linker.ld&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>SECTIONS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ROM_BASE&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> 0x10000; /* ... but actually position independent */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text.start : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.text.start&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE + 0x40;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text.hang : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.text.hang&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE + 0x80;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .rodata.dtb : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.rodata.dtb&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一条指令应该是从0x10000开始&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://chipyard.readthedocs.io/en/1.10.0/" target="_blank" rel="noopener"
>chipyard手册&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/hwzhao/p/17363380.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/hwzhao/p/17363380.html&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>博客搭建</title><link>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 06 Oct 2024 21:57:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h2 id="安装hugo">安装Hugo&lt;/h2>
&lt;p>ubuntu 系统使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令进行验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-hugo-网站">创建 Hugo 网站&lt;/h2>
&lt;p>通过上述命令安装 hugo 程序后，就可以通过 &lt;code>hugo new site&lt;/code> 命令进行网站创建、配置与本地调试了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new site robin-site
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置主题">配置主题&lt;/h2>
&lt;p>当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>Themes&lt;/a> 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。&lt;/p>
&lt;p>官方主题网站: &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>https://themes.gohugo.io/&lt;/a>&lt;/p>
&lt;p>主题推荐:&lt;/p>
&lt;ul>
&lt;li>Pure: &lt;a class="link" href="https://themes.gohugo.io/hugo-theme-pure/" target="_blank" rel="noopener"
>https://themes.gohugo.io/hugo-theme-pure/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="关联主题仓库">关联主题仓库&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/reuixiy/hugo-theme-meme/blob/main/README.zh-cn.md" target="_blank" rel="noopener"
>https://github.com/reuixiy/hugo-theme-meme/blob/main/README.zh-cn.md&lt;/a>&lt;/p>
&lt;p>我们可以将主题仓库直接 &lt;code>git clone&lt;/code> 下来进行使用，例如在根目录robin-site下运行以下代码，即可下载pure主题.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。官方更推荐使用的是将原主题仓库 &lt;code>fork&lt;/code> 到自己的账户，并使用 &lt;code>git submodule&lt;/code> 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> robin-site/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/pseudoyu/pure themes/pure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在根目录下的 &lt;code>config.toml&lt;/code>文件中添加新的一行:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">theme&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">&amp;#34;pure&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="更新主题">更新主题&lt;/h3>
&lt;p>如果是 clone 了其他人的博客项目进行修改，则需要用以下命令进行初始化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule update --init --recursive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果需要同步主题仓库的最新修改，需要运行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule update --remote
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="hugo-theme-meme主题配置">hugo-theme-meme主题配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 安装meme&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add --depth &lt;span style="color:#d19a66">1&lt;/span> https://github.com/reuixiy/hugo-theme-meme.git themes/meme
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 替换配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm config.toml &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> cp themes/meme/config-examples/zh-cn/config.toml config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="zozo-主题配置">zozo 主题配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/varkai/hugo-theme-zozo themes/zozo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm config.toml &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> cp themes/zozo/config.toml config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://gojun.me/posts/hello-hugo-blog/" target="_blank" rel="noopener"
>https://gojun.me/posts/hello-hugo-blog/&lt;/a>&lt;/p>
&lt;h3 id="hugo-theme-stack主题配置">Hugo-theme-stack主题配置&lt;/h3>
&lt;p>&lt;a class="link" href="https://stack.jimmycai.com/guide/getting-started" target="_blank" rel="noopener"
>https://stack.jimmycai.com/guide/getting-started&lt;/a>&lt;/p>
&lt;h2 id="新建博文">新建博文&lt;/h2>
&lt;p>完成后，可以通过 &lt;code>hugo new&lt;/code> 命令发布新文章。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo new posts/test.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &lt;span style="color:#98c379">&amp;#34;Test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: 2022-10-21T19:00:43+08:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令会在 &lt;code>content&lt;/code> 目录下建立 &lt;code>post&lt;/code> 目录，并在 &lt;code>post&lt;/code> 下生成 &lt;code>test.md&lt;/code> 文件，博文书写就在这个文件里使用 Markdown 语法完成。博文的 front matter 里&lt;code>draft&lt;/code> 选项默认为 &lt;code>true&lt;/code>，需要改为 &lt;code>false&lt;/code> 才能发表博文，建议直接更改上面说的&lt;code>archetypes&lt;/code> 目录下的 &lt;code>default&lt;/code> 文件，把 &lt;code>draft: true&lt;/code> 改为 &lt;code>draft: false&lt;/code>，这样生成的博文就是默认可以发表的。&lt;/p>
&lt;h2 id="生成网页">生成网页&lt;/h2>
&lt;p>为了查看生成的博客的效果，我们在本地编辑调试时可以通过 &lt;code>hugo server&lt;/code> 命令进行本地实时调试预览，无须每次都重新生成。在cmd中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-fallback" data-lang="fallback">hugo server -D
&lt;/code>&lt;/pre>&lt;p>但此时只能在本地访问，如果想发布到 &lt;code>Github Pages&lt;/code> ， 还需要借助 GithubPages 工具。&lt;/p>
&lt;h2 id="配置文件">&lt;strong>配置文件&lt;/strong>&lt;/h2>
&lt;p>打开配置config.toml可以看到很多的参数可以配置，这里只描述最基本的内容，不同的主题可能会支持不同的参数配置，具体请看对应主题的说明文档。baseURL是站点的域名。title是站点的名称。theme是站点的主题。还有关于评论和打赏的相关配置，这些配置都可以参考官网主题的说明。&lt;/p>
&lt;p>每次发布的时候，都需要先执行hugo，把新写的文档按照主题进行渲染，所有生成的文件默认都在当前pulic的子目录下，可以在config里面配置到其他目录。然后把所有新的文件提交到github。提交代码之后，要等一段时间才生效。&lt;/p>
&lt;h2 id="github-actions-部署">github actions 部署&lt;/h2>
&lt;h3 id="两个仓库">两个仓库&lt;/h3>
&lt;p>如果想使用 Github Actions 自动部署 hugo 博客，则最起码需要创建两个 Github 的仓库。&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>第一个，便是存储博客 .md 源文件的地方，其实就是 hugo 系统；&lt;/li>
&lt;li>第二个，则是部署 Github Pages 的仓库，仓库名必须是 &lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>，这是 github 官方要求的。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="最终版">最终版&lt;/h2>
&lt;h3 id="主题">主题&lt;/h3>
&lt;p>使用的是大佬美化后的版本 &lt;a class="link" href="https://github.com/Mantyke/Hugo-stack-theme-mod" target="_blank" rel="noopener"
>Mantyke/Hugo-stack-theme-mod&lt;/a>。&lt;/p>
&lt;p>因为还是想用github工作流，不使用vercel,所以接下来结合前面的多篇文章操作,第一步是clone fork 之后的仓库，然后修改remote为一个创建好的私人仓库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone git@github.com:VastCircle/Hugo-stack.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote set-url origin git@github.com:VastCircle/hugostack.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后通过一系列的git操作将网页部署到gh-pages分支上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>rm -rf public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#39;hugo project init&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## create a new orphand branch (no commit history) named gh-pages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout --orphan gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Unstage all files&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rm -rf --cached &lt;span style="color:#c678dd">$(&lt;/span>git ls-files&lt;span style="color:#c678dd">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Add and commit that file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;INIT: initial commit on gh-pages branch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Push to remote gh-pages branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Return to master branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Add the gh-pages branch of the repository. It will look like a folder named public&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree add --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages --squash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Pull down the file we just committed. This helps avoid merge conflicts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree pull --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Push the public subtree to the gh-pages branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree push --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>貌似失败了&lt;/p>
&lt;h3 id="再来一次">再来一次&lt;/h3>
&lt;p>这次把public作为一个独立的仓库，通过.gitignore去屏蔽public ,使得 主仓库不包括 public ,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>rm -rf public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 主仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#39;hugo project init&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 推送仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote add origin https://github.com/VastCircle/VastCircle.github.io.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;INIT: initial commit on public&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>shell 脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#deploy.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">echo&lt;/span> -e &lt;span style="color:#98c379">&amp;#34;\033[0;32mDeploying updates to GitHub...\033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Build the project.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo &lt;span style="color:#7f848e"># if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Go To Public folder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Add changes to git.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add -A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Commit changes.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">msg&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#98c379">&amp;#34;rebuilding site `date`&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">if&lt;/span> &lt;span style="color:#56b6c2">[&lt;/span> &lt;span style="color:#e06c75">$#&lt;/span> -eq &lt;span style="color:#d19a66">1&lt;/span> &lt;span style="color:#56b6c2">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">then&lt;/span> &lt;span style="color:#e06c75">msg&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>&lt;span style="color:#e06c75">$1&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;&lt;/span>&lt;span style="color:#e06c75">$msg&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Push source and build repos.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Come Back&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加-github-action">添加 github action&lt;/h3>
&lt;p>.github/workflows/deploy-site.yaml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>name: deploy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>on:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> push:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> branches: &lt;span style="color:#56b6c2">[&lt;/span>&lt;span style="color:#98c379">&amp;#34;master&amp;#34;&lt;/span>&lt;span style="color:#56b6c2">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workflow_dispatch:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># schedule:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># # Runs everyday at 8:00 AM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># - cron: &amp;#34;0 0 * * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>permissions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contents: &lt;span style="color:#e5c07b">read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages: write
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id-token: write
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Allow one concurrent deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>concurrency:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group: &lt;span style="color:#98c379">&amp;#34;pages&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cancel-in-progress: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Default to bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaults:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shell: bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jobs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># BUild job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runs-on: ubuntu-latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_VERSION: 0.134.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TZ: America/Los_Angeles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Checkout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: actions/checkout@v3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submodules: &lt;span style="color:#e5c07b">true&lt;/span> &lt;span style="color:#7f848e"># Fetch Hugo themes (true OR recursive)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fetch-depth: &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#7f848e"># Fetch all history for .GitInfo and .Lastmod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Setup Hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: peaceiris/actions-hugo@v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hugo-version: &lt;span style="color:#98c379">&amp;#39;0.134.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extended: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Build Hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># For maximum backward compatibility with Hugo modules&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_ENVIRONMENT: production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_ENV: production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run: hugo --minify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Deploy Web
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: peaceiris/actions-gh-pages@v3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PERSONAL_TOKEN: &lt;span style="color:#98c379">${&lt;/span>{ secrets.PERSONAL_TOKEN &lt;span style="color:#98c379">}&lt;/span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXTERNAL_REPOSITORY: VastCircle/VastCircle.github.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUBLISH_BRANCH: master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUBLISH_DIR: ./public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> commit_message: &lt;span style="color:#98c379">${&lt;/span>{ github.event.head_commit.message &lt;span style="color:#98c379">}&lt;/span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何编写博客">如何编写博客&lt;/h2>
&lt;p>正如同其他的博客，使用 &lt;strong>Markdown 语言&lt;/strong>来编写博客。Markdown 流行且极易上手，因此这里就不多介绍语法，如果不会的可以自己搜索了解。&lt;/p>
&lt;h3 id="使用-hugo-创建文章">使用 Hugo 创建文章&lt;/h3>
&lt;p>在博客根目录下运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>hugo new post/untitled.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么要用 hugo 来新建而不是创建一个 &lt;code>.md&lt;/code> 文件呢？这是因为使用 hugo 创建会自动使用已填入 &lt;code>Front Matter&lt;/code>的模板。&lt;/p>
&lt;p>&lt;code>Front Matter&lt;/code> 用于标识文章的标题、时间等信息，hugo 就是据此来生成静态页面。关于属性的含义和用法可以参考 &lt;a class="link" href="https://www.gohugo.org/doc/content/front-matter/" target="_blank" rel="noopener"
>Hugo 中文文档&lt;/a>。&lt;/p>
&lt;p>模板可以在 &lt;code>\archetypes\default.md&lt;/code> 下找到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; # 标题，创建时自动填充
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description: # 文章简介
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: {{ .Date }} # 日期，创建时自动填充，格式同 2023-01-15T12:00:00+08:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: # 文章的封面，留空就是没有，填文章所在位置的相对地址，通常放在同目录下，
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>math: # 是否启用 KaTex，填 true 启用
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license: # 文章尾部显示的协议，false 为隐藏，其他作为内容，留空就是使用 config.yaml 里默认的
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hidden: false # 是否隐藏，一般用不到
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>comments: true # 因为 bug 所以这个属性只要存在，不管是 true 还是 false 都会导致回复无法显示，需要删掉
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: true # 是否为草稿，建议改为 false 或者删掉这个属性以防止忘记修改，毕竟我们一般都是写好了才部署到服务器上
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了方便，我参考网络以及 stack-mod 的功能对模板进行了一些改造：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slug: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: &amp;#34;{{ .Date }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lastmod: &amp;#34;{{ .Date }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: cover.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>math:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hidden: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>categories: [&amp;#34;&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tags: [&amp;#34;&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>## 附录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>### 参考文献
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>### 版权信息
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>本文原载于 [&lt;span style="color:#e06c75">reincarnatey.net&lt;/span>](&lt;span style="color:#e06c75">https://blog.reincarnatey.net&lt;/span>)，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此我们可以编写一个批处理程序来快速帮我们生成文章：&lt;/p>
&lt;p>&lt;code>create_post.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>#!/bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 输出提示信息
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> &lt;span style="color:#98c379">&amp;#34;【创建文章】&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 读取用户输入的 Slug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read -p &lt;span style="color:#98c379">&amp;#34;请输入Slug: &amp;#34;&lt;/span> input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 获取当前日期
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>current_date=$(date +&lt;span style="color:#e06c75">%Y%&lt;/span>m%d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 使用 Hugo 创建新文章
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new post/$current_date-$input/index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 暂停，提示用户操作完成
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read -p &lt;span style="color:#98c379">&amp;#34;按任意键继续...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用此批处理程序生成的文章会创建在 &lt;code>\content\post\2023\0115-test\index.md&lt;/code>，便于我们整理文章资料，同时后续在同目录下存放文章的封面也不会导致内容很乱。&lt;/p>
&lt;h3 id="使用-hugo-创建类别标签">使用 Hugo 创建类别、标签&lt;/h3>
&lt;p>创建 Categories 和 Tag 也同理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>hugo new categories/testcat.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new tags/testtag.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hugo 会自动应用 &lt;code>\archetypes\categories.md&lt;/code> 和 &lt;code>\archetypes\tags.md&lt;/code> 的模板，但是这两个模板都不太好，建议都改为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slug: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: cover.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>style:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> background: &amp;#34;#2a9d8f&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color: &amp;#34;#fff&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>create_Categories.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#c678dd">echo&lt;/span> off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> 【创建类别】
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">set&lt;/span> &lt;span style="color:#c678dd">/p&lt;/span> &lt;span style="color:#e06c75">input&lt;/span>= 请输入类别名:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new categories/&lt;span style="color:#e06c75">%input%&lt;/span>/_index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">pause&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>生成的categories就是在改变如下图所示的界面&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 632;
flex-basis: 1518px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1.png" data-size="1050x166">
&lt;img src="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1.png"
width="1050"
height="166"
srcset="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1_hu14227645176143580784.png 480w, https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1_hu14426535897027265073.png 1024w"
loading="lazy"
alt="image1">
&lt;/a>
&lt;figcaption>image1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;code>create_tag.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#c678dd">echo&lt;/span> off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> 【创建标签】
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">set&lt;/span> &lt;span style="color:#c678dd">/p&lt;/span> &lt;span style="color:#e06c75">input&lt;/span>= 请输入标签名:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new tags/&lt;span style="color:#e06c75">%input%&lt;/span>/_index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">pause&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：如果创建多级文件夹时文章文件名不是 &lt;code>index.md&lt;/code> 或者类别、标签文件名不是 &lt;code>_index.md&lt;/code> 的话，设置封面图片会出现问题。&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>&lt;a class="link" href="https://hk.v2ex.com/t/1009591" target="_blank" rel="noopener"
>https://hk.v2ex.com/t/1009591&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://jianzhnie.github.io/post/hugo_site/" target="_blank" rel="noopener"
>https://jianzhnie.github.io/post/hugo_site/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://hyrtee.github.io/2023/start-blog/" target="_blank" rel="noopener"
>https://hyrtee.github.io/2023/start-blog/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://smc.im/post/deploy-hugo-blog-with-github-actions/" target="_blank" rel="noopener"
>https://smc.im/post/deploy-hugo-blog-with-github-actions/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/" target="_blank" rel="noopener"
>建站技术 | 使用 Hugo + Stack 简单搭建一个博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://kaichu.io/posts/my-first-post/" target="_blank" rel="noopener"
>https://kaichu.io/posts/my-first-post/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://stack.jimmycai.com/" target="_blank" rel="noopener"
>stack 手册&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.oddyti.com/post/hugo-problems/#github%E4%BB%93%E5%BA%93%E5%8F%8C%E5%88%86%E6%94%AF%E5%88%86%E5%88%AB%E5%AD%98%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E9%83%A8%E7%BD%B2%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"
>部署hugo 踩过的坑&lt;/a>_&lt;/p>
&lt;p>&lt;a class="link" href="https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener"
>https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/&lt;/a>&lt;/p></description></item></channel></rss>