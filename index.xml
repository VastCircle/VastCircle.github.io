<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>VastCircle's blog</title><link>https://VastCircle.github.io/</link><description>Recent content on VastCircle's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Nov 2024 16:00:54 +0800</lastBuildDate><atom:link href="https://VastCircle.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Cache</title><link>https://VastCircle.github.io/2024/cache/</link><pubDate>Sat, 16 Nov 2024 16:00:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/cache/</guid><description>&lt;h2 id="cache的一般设计">Cache的一般设计&lt;/h2>
&lt;p>Cache line = Cache data block + Cache Tag ,如果一个数据可以存储在Cache中的多个地方,能够被同一个地址找到的多个Cache Line 称为Cache Set&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 124;
flex-basis: 299px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116160826859.png" data-size="641x513">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116160826859.png"
width="641"
height="513"
srcset="https://VastCircle.github.io/2024/cache/image-20241116160826859_hu1332369990589390405.png 480w, https://VastCircle.github.io/2024/cache/image-20241116160826859_hu18064085407264266732.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>Cache缺失的原因(3C定理:&lt;/p>
&lt;p>(1)Compulsory , 第一次访问的指令或数据肯定不会在Cache中,&lt;/p>
&lt;p>(2)Capcity,容量,&lt;/p>
&lt;p>(3)Conflict,冲突&lt;/p>
&lt;h3 id="cache的组成方式">Cache的组成方式&lt;/h3>
&lt;h4 id="直接相连">直接相连&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 125;
flex-basis: 300px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116161412680.png" data-size="423x338">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116161412680.png"
width="423"
height="338"
srcset="https://VastCircle.github.io/2024/cache/image-20241116161412680_hu2800656703488485149.png 480w, https://VastCircle.github.io/2024/cache/image-20241116161412680_hu12292938691630876810.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="组相联">组相联&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 432px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116161438353.png" data-size="632x351">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116161438353.png"
width="632"
height="351"
srcset="https://VastCircle.github.io/2024/cache/image-20241116161438353_hu11565796626120221971.png 480w, https://VastCircle.github.io/2024/cache/image-20241116161438353_hu7354851681176083980.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="并行访问和串行访问">并行访问和串行访问&lt;/h5>
&lt;p>&lt;strong>并行访问&lt;/strong>&lt;/p>
&lt;p>当Tag的地址被读取的同时,Data部分的所有数据也能够被读出来,送到一个多路选择器中,这个多路选择器受到Tag比较结果的控制,选出对应的Data block,然后根据Block offset的值,选择合适的字节,选择字节的过程称为数据对齐(Data Alignment)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 163;
flex-basis: 391px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116162035130.png" data-size="579x355">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116162035130.png"
width="579"
height="355"
srcset="https://VastCircle.github.io/2024/cache/image-20241116162035130_hu1245071803936278610.png 480w, https://VastCircle.github.io/2024/cache/image-20241116162035130_hu18277916102578682986.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于i-cache,流水线的结构不会有太大的影响,可以实现每周期读取指令,因为读取指令本身就是连续的,但是对于D-cache,会增大load的延时&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 165;
flex-basis: 397px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116162505527.png" data-size="622x376">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116162505527.png"
width="622"
height="376"
srcset="https://VastCircle.github.io/2024/cache/image-20241116162505527_hu15060017127470534791.png 480w, https://VastCircle.github.io/2024/cache/image-20241116162505527_hu14573293114003113365.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>串行访问&lt;/strong>&lt;/p>
&lt;p>首先访问Tag SRAM,根据Tag比较的结果,直接去访问对应的way ,这样就不需要多路选择器了,可以节省功耗&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 144;
flex-basis: 345px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116163105148.png" data-size="553x384">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116163105148.png"
width="553"
height="384"
srcset="https://VastCircle.github.io/2024/cache/image-20241116163105148_hu16397395133458991088.png 480w, https://VastCircle.github.io/2024/cache/image-20241116163105148_hu9558830123433454204.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>相比于并行会增加一个周期,但是它也降低了同时访问Tag SRAM和Data RAM的延迟&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 191;
flex-basis: 459px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116163140291.png" data-size="674x352">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116163140291.png"
width="674"
height="352"
srcset="https://VastCircle.github.io/2024/cache/image-20241116163140291_hu11023120944439539204.png 480w, https://VastCircle.github.io/2024/cache/image-20241116163140291_hu7334958423253631261.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="全相连">全相连&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 381px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116163346972.png" data-size="582x366">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116163346972.png"
width="582"
height="366"
srcset="https://VastCircle.github.io/2024/cache/image-20241116163346972_hu7828507688133854421.png 480w, https://VastCircle.github.io/2024/cache/image-20241116163346972_hu15099731169493597316.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="cache的写入">Cache的写入&lt;/h3>
&lt;p>在一般的RISC处理器中,Icache都不会被直接写入内容,即使是有自修改指令,也需要借助D-cache,将要改写的指令作为数据写到D-cache中,然后将D-cahce中的内容写到下级存储器中(例如L2-cache,这个存储器是被i-cache和d-cache共享的,这个过程称为clean),并将I-cache的所有内容置为无效,这样处理器再次执行的时候,就会去读取修改过的指令&lt;/p>
&lt;p>Write Through 和 Write Back&lt;/p>
&lt;p>Write Allocate,在发生write miss之后先把下级数据写入D-cache,再将数据写入D-cache&lt;/p>
&lt;p>Non-Write Allocate ,发生write miss 直接写入内存&lt;/p>
&lt;p>Write Through 配合 Non-Write Allocate&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 69;
flex-basis: 167px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116170905639.png" data-size="591x849">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116170905639.png"
width="591"
height="849"
srcset="https://VastCircle.github.io/2024/cache/image-20241116170905639_hu11376883461551201258.png 480w, https://VastCircle.github.io/2024/cache/image-20241116170905639_hu9755231987386440507.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 280px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116171153043.png" data-size="716x613">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116171153043.png"
width="716"
height="613"
srcset="https://VastCircle.github.io/2024/cache/image-20241116171153043_hu17440820691935303671.png 480w, https://VastCircle.github.io/2024/cache/image-20241116171153043_hu14108955066647394251.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="cache的替换策略">Cache的替换策略&lt;/h3>
&lt;h4 id="lruleast-recently-used">LRU(Least Recently Used)&lt;/h4>
&lt;p>选择最近被使用次数最少的Cache line,这样需要为每一个Cache Line设置一个Age部分,每当一个Cache line被访问时,对应的年龄部分会增大,进行替换时,替换年龄最少的那个,实际上,为了减少代价,会使用&amp;quot;伪LRU&amp;quot;的方法,将所有的way进行分组,每一组使用一个1位的年龄部分&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 177;
flex-basis: 426px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116171552581.png" data-size="760x428">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116171552581.png"
width="760"
height="428"
srcset="https://VastCircle.github.io/2024/cache/image-20241116171552581_hu1017904653173853324.png 480w, https://VastCircle.github.io/2024/cache/image-20241116171552581_hu3117118189869326289.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>类似于二分法,三级年龄位可以分8个way&lt;/p>
&lt;h4 id="随机替换">随机替换&lt;/h4>
&lt;p>可以通过时钟算法实现近似的随机&lt;/p>
&lt;h2 id="提高cache的性能">提高Cache的性能&lt;/h2>
&lt;h3 id="write-buffer">Write buffer&lt;/h3>
&lt;p>可以将dirty的数据先放到write buffer里,等到下一级存储器有空闲的时候,将write buffer的数据写到下一级存储器中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 234;
flex-basis: 562px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116191825344.png" data-size="464x198">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116191825344.png"
width="464"
height="198"
srcset="https://VastCircle.github.io/2024/cache/image-20241116191825344_hu7889130295197604032.png 480w, https://VastCircle.github.io/2024/cache/image-20241116191825344_hu15626345929076081660.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>当读取D-cache发生缺失时,不仅需要从下级存储器中查找数据,还需要在write buffer中也查找&lt;/p>
&lt;h3 id="流水线">流水线&lt;/h3>
&lt;p>对于写D-Cache来说,读取Tag SRAM和写Data SRAM只能串行的完成.&lt;/p>
&lt;p>可以将Tag SRAM的读取和比较放在一个周期,写Data SRAM放在下一个周期&lt;/p>
&lt;p>对于store指令,需要两个周期来完成,如果连续的执行store指令,任然可以获得没周期执行一条store指令的效果&lt;/p>
&lt;p>当执行load指令时,可能出现load需要的数据正好在store指令的流水线寄存器中,因此还需要一种机制来检查load指令携带的地址和store指令的流水线寄存器&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 173;
flex-basis: 417px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116192239775.png" data-size="642x369">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116192239775.png"
width="642"
height="369"
srcset="https://VastCircle.github.io/2024/cache/image-20241116192239775_hu11128785969072269180.png 480w, https://VastCircle.github.io/2024/cache/image-20241116192239775_hu2248314353265831686.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="多级结构">多级结构&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 448;
flex-basis: 1075px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116192948742.png" data-size="771x172">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116192948742.png"
width="771"
height="172"
srcset="https://VastCircle.github.io/2024/cache/image-20241116192948742_hu15711754013701734057.png 480w, https://VastCircle.github.io/2024/cache/image-20241116192948742_hu14872485187820154820.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一般在处理器中.L2 cache会使用write back的方式,但是对于L1 cache来说,write through也可以接受,可以简化流水线的设计,也便于在多核的环境中,管理存储器之间的一致性&lt;/p>
&lt;h4 id="inclusive-和-exclusive">inclusive 和 exclusive&lt;/h4>
&lt;p>Inclusive : 如果 l2包括了l1中的所有内容,称l2 cache是inclusive的&lt;/p>
&lt;p>exclusive:如果l2 cache 和l1 cache的内容互不相同,称l2 cache是exclusive的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 250;
flex-basis: 601px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116193314356.png" data-size="451x180">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116193314356.png"
width="451"
height="180"
srcset="https://VastCircle.github.io/2024/cache/image-20241116193314356_hu519990957970606505.png 480w, https://VastCircle.github.io/2024/cache/image-20241116193314356_hu14808646991832425164.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>inclusive类型的cache,在覆盖l1 cache不会存在问题;inclusive类型的cache也简化了一致性(coherence)的管理,例如在多核的处理器中,当其中一个处理器改变了存储器中一个地址的数据时,如果在其他处理器的私有Cache中也保存了地址的数据,需要置为无效,此时只需要检查最低级的存储器,因为如果l2 cache没有数据,l1 cache中必然没有数据&lt;/p>
&lt;h3 id="victim-cache">Victim Cache&lt;/h3>
&lt;p>有时候,cache中被踢出的数据在之后可能马上又要被使用,比方说对于2-way的Cache,有3个数据恰好位于同一个Cache set&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 382;
flex-basis: 918px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116194031670.png" data-size="624x163">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116194031670.png"
width="624"
height="163"
srcset="https://VastCircle.github.io/2024/cache/image-20241116194031670_hu10040534559773902139.png 480w, https://VastCircle.github.io/2024/cache/image-20241116194031670_hu11667458781686084904.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>Victim Cache可以保存最近被踢出Cache的数据,因此所有的Cache set都可以利用它来提高way的个数,通常Victim Cache采用全相连的方式,容量比较小,Victim本质就是增加了Cache中way的个数,能够避免多个数据竞争Cache中有限的位置,从而降低Cache的缺失率.一般来说Victim Cache和 Cache的数据是互斥的,可以同时去查找Victim Cache和Cache,如果Cache中没有数据的话,就使用Victim Cache的数据&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 226;
flex-basis: 543px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116194526437.png" data-size="534x236">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116194526437.png"
width="534"
height="236"
srcset="https://VastCircle.github.io/2024/cache/image-20241116194526437_hu16126775329523168523.png 480w, https://VastCircle.github.io/2024/cache/image-20241116194526437_hu4284953928355226590.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>Filter cache,当一个数据第一次被使用,会放在Filter cache中,当数据被再次使用,才放在Cache中,这样可以避免偶然使用的数据,从而提高Cache的利用效率&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 471px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116195003330.png" data-size="464x236">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116195003330.png"
width="464"
height="236"
srcset="https://VastCircle.github.io/2024/cache/image-20241116195003330_hu8483874276382225260.png 480w, https://VastCircle.github.io/2024/cache/image-20241116195003330_hu11577955194034125407.png 1024w"
loading="lazy"
alt="image-20241116195003330">
&lt;/a>
&lt;figcaption>image-20241116195003330&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="预取">预取&lt;/h3>
&lt;p>可以使用预取（prefetching)来猜测处理器在以后可能使用什么指令和数据，提前将其放到Cache中，可以通过硬件完成，也可以通过软件完成。&lt;/p>
&lt;h4 id="硬件预取">硬件预取&lt;/h4>
&lt;p>在访问I-cache的一个数据块的时候，可以将它后面的数据块也取出来放在I-cache,但是由于分支预测指令的存在，可能会使得不被使用的指令进入I-cache,一方面降低I-cache实际可用的容量，一方面有占用了本来可能有用的指令，称为“cache 污染” ，可以先将预取的指令放在一个单独的缓存中（stream Buffer)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 200;
flex-basis: 482px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116202635573.png" data-size="482x240">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116202635573.png"
width="482"
height="240"
srcset="https://VastCircle.github.io/2024/cache/image-20241116202635573_hu8140215996625278615.png 480w, https://VastCircle.github.io/2024/cache/image-20241116202635573_hu7370200458249293033.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="软件预取">软件预取&lt;/h4>
&lt;p>在程序的编译阶段，编译器可以对程序分析，进而知道哪些数据是需要进行预取的，在程序中设置预取指令，就可以在计算时直接从D-cache中找到需要的数据，这种预取需要把握预取的时机，&lt;/p>
&lt;p>并且使用软件预取时，在执行预取指令的时候，处理器需要继续执行，也就是继续能够从D-cache中取数据，而不能让预取指令阻碍后面指令的执行，这要求D-cache是non-blocking结构的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 176;
flex-basis: 423px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116203647382.png" data-size="282x160">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116203647382.png"
width="282"
height="160"
srcset="https://VastCircle.github.io/2024/cache/image-20241116203647382_hu2549777358311364986.png 480w, https://VastCircle.github.io/2024/cache/image-20241116203647382_hu6979007415998428569.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在实现虚拟存储器器的系统中，预取指令可能会引起异常，例如发生Page Fault,虚拟地址错误（Virtual Address Falut）或者保护违例（Protection Violation),此时有两种选择，如果对异常进行处理，称这种预取指令为处理错误的预取指令（Faulting Prefetch Instruction),反之，如果不对异常处理并且抛弃掉这条预取指令，称这种预取指令为不处理错误的预取指令（NonFaulting Prefetch Instruction),此时发生异常的预取指令会变成空指令&lt;/p>
&lt;h3 id="多端口cache">多端口Cache&lt;/h3>
&lt;p>在超标量处理器中，为提高性能，处理器需要能够每周期执行多条load/store指令，这需要多端口D-Cache,需要一些特殊的方式来避免多端口对芯片的面积和速度带来很大的负面影响&lt;/p>
&lt;h4 id="true-multi-port">True Multi-port&lt;/h4>
&lt;p>真正的多端口需要所有在Cache中的控制通路和数据通路进行复制，这表示它有两套地址解码器（Address Decoder),使得两个端口可以同时寻址Tag SRAM和Data SRAM,有两个多路选择器，用来同时读取两个端口的数据，比较器的数量也需要同时增加一杯，用来判断两个端口的命中情况，同时需要两个对齐器（Aligner).&lt;/p>
&lt;p>SRAM中的每个Cell也需要同时支持两个并行的读取操作。因此需要更长的访问时间，功耗也会随之增大。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 205;
flex-basis: 493px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116205756405.png" data-size="576x280">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116205756405.png"
width="576"
height="280"
srcset="https://VastCircle.github.io/2024/cache/image-20241116205756405_hu18285717603797448149.png 480w, https://VastCircle.github.io/2024/cache/image-20241116205756405_hu13303096475044297097.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="multiple-cache-copies">Multiple Cache Copies&lt;/h4>
&lt;p>和上面类似，将Cache进行复制，SRAM将不使用多端口的结构，可以基本消除对处理器周期的影响，但是浪费了很多面积，而且需要保存两个Cache的同步，即需要保证两个Cache是完全一致的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 127;
flex-basis: 305px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116205912949.png" data-size="272x214">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116205912949.png"
width="272"
height="214"
srcset="https://VastCircle.github.io/2024/cache/image-20241116205912949_hu15815348389656329818.png 480w, https://VastCircle.github.io/2024/cache/image-20241116205912949_hu6290296688918996185.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="multi-banking">Multi-banking&lt;/h4>
&lt;p>将Cache分为很多个小bank,每个bank只有一个端口，如果一个周期之内，Cache的多个端口上的访问地址位于不同bank之中，没有任何问题，当端口的地址位于同一个bank之中时，会引起bank冲突（bank conflict)&lt;/p>
&lt;p>这种方法仍然需要两个地址解码器，有两个多路选择器，两套比较器，两个对齐器（Aligner)。此时Data SRAM不需要实现多端口结构了（一个地址只会读一次），提高了速度减少了面积。但是由于需要判断Cache的每个端口是不是命中，对于Tag SRAM来说，仍旧需要提供多个端口同时读取的功能（why?），即采用多端口SRAM,或者将单端口SRAM进行复制&lt;/p>
&lt;p>当端口冲突时，当前周期Cache只能对一个端口进行响应&lt;/p>
&lt;p>可以采用更多的bank来降低bank冲突的概率，由于每个端口都会访问所有的bank,那需要更多的布线资源&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 217;
flex-basis: 521px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116211832055.png" data-size="404x186">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116211832055.png"
width="404"
height="186"
srcset="https://VastCircle.github.io/2024/cache/image-20241116211832055_hu18083423710349595363.png 480w, https://VastCircle.github.io/2024/cache/image-20241116211832055_hu5979318066791751977.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="amd-opteron-的多端口-cache">AMD opteron 的多端口 Cache&lt;/h4>
&lt;p>40位物理地址，48位虚拟地址&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 155;
flex-basis: 373px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116214350948.png" data-size="821x528">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116214350948.png"
width="821"
height="528"
srcset="https://VastCircle.github.io/2024/cache/image-20241116214350948_hu4034912218193561823.png 480w, https://VastCircle.github.io/2024/cache/image-20241116214350948_hu9904768563727028057.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>数据块的大小是64Bits,需要6字节寻址找到其中的某一个字节，每个数据块被分为8个独立的bank,每个bank都是64位的单端口SRAM&lt;/p>
&lt;p>整个Cache的大小是64KB,采用两路组相连，每一路大小为32KB.使用“Virtually-indexed,Pyhsically-tagged&amp;quot;的实现方式，可以使用虚拟地址寻址Cache,每一路是32KB的大小，需要VA[14:0]进行寻址，前面6位寻址块内字节，所以VA[14:6]用来寻址Cache set ,&lt;/p>
&lt;p>由于每个Cache line划分为8个bank,所以使用VA[5:3]来找到某一个bank,剩下的VA[2:0]用来找到某个字节，这种方式将两个连续的64位数据放在两个相邻的不同bank中，对它访问不会存在冲突。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 471;
flex-basis: 1130px"
>
&lt;a href="https://VastCircle.github.io/2024/cache/image-20241116215448071.png" data-size="636x135">
&lt;img src="https://VastCircle.github.io/2024/cache/image-20241116215448071.png"
width="636"
height="135"
srcset="https://VastCircle.github.io/2024/cache/image-20241116215448071_hu14988285204597629743.png 480w, https://VastCircle.github.io/2024/cache/image-20241116215448071_hu8311006062730573641.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>大小为64KB,两路组相连，每一路都有8个4KB的bank,整个cache有16个4KB的bank,Cache的每一个端口访问时，都会同时访问两个way的数据，然后根据tag去选择命中了哪个，所以Cache的一个端口访问时，会同时访问到两个bank,每个way各一个，&lt;/p>
&lt;p>PA[39:12]就是tag部分，用来判断哪个way是命中的，每一个端口都有一个TLB.每个端口都要同时读取两个way的tag进行比较，理论上来说，每个way的Tag SRAM需要支持两个读端口，这个Cache采用将Tag SRAM复制的方法&lt;/p>
&lt;p>虚拟地址的[11:0]寻址page内部，[47：12]寻址TLB,对应PFN[39:12],它用来和Cache对应的Tag部分比较，来判断是否命中&lt;/p>
&lt;p>该Cache相比于单端口，需要两个TLB,两个Tag比较电路，两倍的Tag SRAM,除了Data SRAM没有被复制，其他都被复制了，所以面积大，但是速度快。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Dram访问路径查找</title><link>https://VastCircle.github.io/2024/dram%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 13 Nov 2024 18:55:55 +0800</pubDate><guid>https://VastCircle.github.io/2024/dram%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>虚拟存储器</title><link>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</link><pubDate>Tue, 12 Nov 2024 20:12:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中&lt;/p>
&lt;p>虚拟存储器空间的大小由处理器的位数决定,对于32位处理器,地址范围就是0~0xFFFFFFFF,就是4GB ,这些地址就是虚拟地址&lt;/p>
&lt;p>和虚拟存储器相对应的就是物理存储器,是在现实世界中能够使用的存储器,其中的地址就是物理地址&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 173;
flex-basis: 416px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891.png" data-size="580x334">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891.png"
width="580"
height="334"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891_hu9392279268069119721.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202223891_hu7023267616482017088.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 176;
flex-basis: 424px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094.png" data-size="569x322">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094.png"
width="569"
height="322"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094_hu14335039875351292116.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112202238094_hu7954957040857737702.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>MMU(memory manage unit,MMU)内存管理单元&lt;/p>
&lt;p>使用物理地址,运行程序时需要为每个程序分配一块地址空间,每个程序需要在地址空间中进行运行&lt;/p>
&lt;p>使用虚拟地址,每个程序会认为它独占了整个地址空间,这样在编写程序时不需要考虑地址的限制,由操作系统负责调度,将物理存储器动态分配给各个程序,将每个程序的虚拟地址转为物理地址.&lt;/p>
&lt;p>虚拟地址还可以带来保护(protect)和共享(share)&lt;/p>
&lt;h3 id="地址转化--基于分页page的虚拟存储器">地址转化 -基于分页(page)的虚拟存储器&lt;/h3>
&lt;p>典型的页大小是4KB ,物理地址中称为frame,page和frame的大小必须相等&lt;/p>
&lt;p>程序运行时会进行把程序从硬盘搬移到物理内存中,每次搬移的单位就是一个页&lt;/p>
&lt;p>VA[11:0]表示页内的位置,称为page offset ,VA剩余的部分表示哪个页,称为VPN(Virtual Page Number)&lt;/p>
&lt;p>PA[11:0]表示frame的位置,称为frame offset,剩余部分表示哪个frame,称为PFN(Physical Frame Number)&lt;/p>
&lt;p>从VPN到PFN,offset不需要变化&lt;/p>
&lt;p>比方说 page0 -&amp;gt; frame 2 ,offset = 4 , 那只需要把VPN换成PFN ,就是把0换成2,&lt;/p>
&lt;p>如果程序的内容没有存储在物理内存中,MMU就会产生Page Fault的异常给处理器,处理器通过异常处理程序(操作系统的一部分代码)找到替换的frame ,需要先解除frame 和 page的映射,然后把硬盘的内容搬移到frame,然后添加frame和page的映射,如果被替换的frame是dirty的,还需要先将内容搬移到硬盘中,处理完成之后返回发生异常的指令重新执行&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 383px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257.png" data-size="717x449">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257.png"
width="717"
height="449"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257_hu844777046950357857.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112203722257_hu1495159615354411353.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="单级页表线性页表">单级页表(线性页表)&lt;/h4>
&lt;p>页表(page Table,PT)用来存储从虚拟地址到物理地址的映射关系,一般页表是放在物理内存中的,需要使用虚拟地址寻址,页表内被寻址到的内容就是这个虚拟地址对应的物理地址,处理器中会有一个页表寄存器(Page Table Register,PTR)来存放当前运行程序的页表在物理内存中的起始位置,每次操作系统将程序调入物理内存都会去将PTR设置好&lt;/p>
&lt;p>两次内存访问,先使用虚拟地址访问页表,再使用物理地址进行寻址&lt;/p>
&lt;p>使用PTR和虚拟地址共同寻址页表,相当于使用它们共同组成一个地址,用来寻址物理内存&lt;/p>
&lt;p>valid用来指示当前的page是否在物理内存中&lt;/p>
&lt;p>下图展示如何通过PTR从物理内存中定位一个页表,并且使用虚拟地址来寻址页表,从而找到物理地址,&lt;/p>
&lt;p>具体来说就是一个虚拟地址VPN[31:12],页表的起始物理地址是addr,那这个虚拟地址对应的物理地址就是addr + VPN[31:12]所对应的entry的值,就完成了相应的映射&lt;/p>
&lt;p>页表的表项数为2^32 / 4K = 2 ^20 = 1M ,需要20位来寻址,在页表中包括的所有VPN的映射关系,页表的大小是4B * 1M = 4M , 一个entry 需要32位,因为物理内存的数据位宽是32位&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 198;
flex-basis: 476px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106.png" data-size="808x407">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106.png"
width="808"
height="407"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106_hu9820542538462257665.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112205713106_hu11134552561278830943.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>程序对应的页表,连同pc和通用寄存器,组成了程序的状态,在切换程序时,需要去保存状态,该程序称为进程,用户打开程序,操作系统会分配物理内存的空间,创建页表和堆栈等,进程的页表指定了能够在物理内存中访问的地址空间&lt;/p>
&lt;p>可以通过页表通过相同的虚拟地址访问不同的物理地址 ,通过不同的虚拟地址访问相同的物理地址,实现进程的保护和共享&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 137;
flex-basis: 329px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256.png" data-size="639x465">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256.png"
width="639"
height="465"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256_hu4352988920381212314.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241112213025256_hu15938731263752335312.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="多级页表">多级页表&lt;/h4>
&lt;p>将4MB的线性页表划分为若干个更小的页表,称为子页表.操作系统在处理进程的时候,根据需求逐步放入子页表,并且子页表不再占用连续的物理内存空间.需要一个表格记录子页表在物理内存中存储的位置,称为第一级页表(level1 page Table),子页表称为第二级页表(level2 Page Table)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 118;
flex-basis: 285px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578.png" data-size="557x469">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578.png"
width="557"
height="469"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578_hu13967031774116966010.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113005854578_hu15170062433743167635.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一个2^20的entry的页表可以划分为2^10 entry的一级页表+2^10个2^10大小的二级页表,一个页表的表项称为PTE(Page Table Entry),当操作系统创建一个进程,就在物理内存找一块4KB空间存放一级页表,并将基地址放在PTR寄存器中,一个虚拟地址肯定能够对应一个一级页表的表项,用后10位寻址一级页表,获取二级页表,然后再用前10位获取二级页表的表项,&lt;/p>
&lt;p>页表的映射关系应该都是操作系统分的,是在异常那边进行处理的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 314px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760.png" data-size="817x624">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760.png"
width="817"
height="624"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760_hu2940597119313810523.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113013352760_hu11773006285468692535.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>不同的虚拟地址会导致出现不同的页表,极端情况为(1)4M程序连续,会建立一个一级页表和一个二级页表=8KB ,(2)都是离散的,并且全部都在4MB的边界上,这样需要建立1024个二级页表+一个一级页表=4100kB&lt;/p>
&lt;p>增加级数,一级页表寻址二级页表,寻址3级页表&amp;hellip;&lt;/p>
&lt;p>2^64entry -&amp;gt; 4096个2^40entry&lt;/p>
&lt;p>​ -&amp;gt; 4096个4096个2^28 entry&lt;/p>
&lt;p>​ -&amp;gt; 4096 4096 4096 2^16 entry &amp;hellip;&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 177;
flex-basis: 425px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927.png" data-size="866x489">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927.png"
width="866"
height="489"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927_hu8599081119763294452.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113103609927_hu8742420021551640479.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>需要多次访问物理内存,&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 131;
flex-basis: 314px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228.png" data-size="669x510">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228.png"
width="669"
height="510"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228_hu10601366518261350491.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104520228_hu2163039551090256012.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>处理器多个进程时,为进程分配的物理内存之和可能大于实际可用的物理内存,部分页可能临时存在在下一级的硬盘中,成为swap空间 ,需要用到这些页时才会被调入到物理内存&lt;/p>
&lt;p>把页从物理内存写入硬盘称为Page out ,从硬盘写入swap空间称为Page In&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 108;
flex-basis: 260px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087.png" data-size="387x356">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087.png"
width="387"
height="356"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087_hu17650543691703514328.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113104829087_hu4548535786874561091.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>利用虚拟存储器,可以管理每一个页的访问权限,只需要在页表中去设置每一个页的属性就可以了,&lt;/p>
&lt;h4 id="page-fault">Page Fault&lt;/h4>
&lt;p>Page Fault是异常的一种,通过操作系统来进行完成&lt;/p>
&lt;p>(1)Page Fault需要访问硬盘,通常为毫米级别,与Page Fault对应的异常处理程序来说是微乎其微的&lt;/p>
&lt;p>(2)使用软件可以根据实现情况实现灵活的替换算法,找到最合适的页进行替换&lt;/p>
&lt;p>直接使用虚拟地址不能知道页位于硬盘的哪个位置,只能知道物理内存的,需要操作系统在开辟swap空间的同时,会使用一个表格记录每个页在硬盘中存储的位置,可以和页表进行合并&lt;/p>
&lt;p>如果valid为0,代表页在硬盘中,反之在物理内存里&lt;/p>
&lt;p>但是实际上物理上仍然是分开的,因为不管一个页是不是在物理内存中,操作系统都必须记录一个进程的所有页在硬盘中的位置&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 120;
flex-basis: 288px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162.png" data-size="563x468">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162.png"
width="563"
height="468"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162_hu16669049199911691540.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113112122162_hu12050019672886567113.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)写通(Write Through),将改变的内容马上写回到硬件中去&lt;/p>
&lt;p>(2)写回(Write Back),只有等到地址的内容在物理内存中要被替换时,才将内容写回到硬盘&lt;/p>
&lt;p>在PTE中增加一个dirty的状态位,当页内的某个地址被写入是,dirty的状态会被置1.在需要被替换时,根据dirty位去决定是否要先写回到硬盘中去&lt;/p>
&lt;p>替换算法可以在硬件上提供支持,在PTE中增加一位来记录每个页最近是否被访问过,称为&amp;quot;使用位(use)&amp;quot;,可以周期性的去将使用位清零&lt;/p>
&lt;p>为了处理Page Fault,硬件需要&lt;/p>
&lt;p>(1)在发现Page Fault,能够产生对应类型的异常,并跳转到异常处理程序&lt;/p>
&lt;p>(2)当写入物理内存时,需要将页表中对应PTE的脏状态置1.&lt;/p>
&lt;p>(3)当store/load物理内存时,将use位置1&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 227;
flex-basis: 547px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875.png" data-size="677x297">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875.png"
width="677"
height="297"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875_hu16875898927542427658.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114256875_hu5836178382668034331.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;h5 id="没有page-fault时">没有Page Fault时&lt;/h5>
&lt;ol>
&lt;li>处理器送出的VA送到MMU&lt;/li>
&lt;li>MMU使用PRT和VA[31:12]组成访问页表的地址,送到物理内存&lt;/li>
&lt;li>将寻址到的PTE返回给MMU&lt;/li>
&lt;li>MMU判断valid=1,使用PA={PFN,VA[11:0]}访问物理地址&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 169;
flex-basis: 407px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566.png" data-size="615x362">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566.png"
width="615"
height="362"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566_hu9843346056032092035.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114450566_hu14508332668482389946.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="发生page-fault">发生Page Fault&lt;/h5>
&lt;p>1~3一致&lt;/p>
&lt;ol start="4">
&lt;li>MMU发现valid=0,触发Page Fault,处理器会跳转到Page Fault对应的异常程序中,此时MMU还会吧发生Page Fault的虚拟地址VA保存到专业的处理器,供异常处理程序使用&lt;/li>
&lt;li>如果物理内存没有空闲空间,异常处理程序会根据替换算法,从物理内存找出未来可能不被使用的页,将其替换,页称为Victim Page,如果dirty为1,需要写入到硬盘&lt;/li>
&lt;li>Page Fault异常处理程序会使用MMU保存的虚拟地址VA寻址硬盘,找到对应的页,将其写入到Victim page所在的位置&lt;/li>
&lt;li>从异常程序返回时,引发Page Fault的指令会被重新取到流水线中,处理器会重新发送虚拟地址到MMU&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 226;
flex-basis: 542px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412.png" data-size="807x357">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412.png"
width="807"
height="357"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412_hu6221575889162077024.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113114927412_hu8021151083403226446.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="程序保护">程序保护&lt;/h2>
&lt;p>操作系统的内容不允许被用户进程随意修改,操作系统中的有一部分允许用户进程读取.操作系统相对于普通用户进程来说,应该有足够多的权限,来保证操作系统对于系统的控制权;不同进程之间一个加以保护,一个进程不能让其他的进程随便修改自己的内容&lt;/p>
&lt;p>上述条件需要操作系统和用户进程对于不同的页有不同的访问权限,通过页表可以实现,&lt;/p>
&lt;p>操作系统一般不会使用页表,而是直接访问物理内存,物理内存中的专门一部分供操作系统来使用&lt;/p>
&lt;p>ARMv7架构,AP部分决定每个页的访问权限&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 232;
flex-basis: 558px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838.png" data-size="836x359">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838.png"
width="836"
height="359"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838_hu16735024332026684348.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133337838_hu8986040596683524870.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一旦发现当前的访问不符合规定,会产生非法访问异常,使得处理器跳转到异常处理程序,由操作系统决定如何处理非法的访问&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 190;
flex-basis: 456px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861.png" data-size="747x393">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861.png"
width="747"
height="393"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861_hu2288858152837664721.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113133610861_hu8963100368267186447.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>也可以对一级页表设置权限控制,每个一级页表可以映射4KB*1024=4MB的地址范围,可以&lt;/p>
&lt;p>00 -&amp;gt; 4MB空间不允许访问, 11 -&amp;gt; 对应的4MB空间不设限制 , 01 -&amp;gt; 需要产看第二级页表的PTE,获得页访问的权限,通过粗粒度和细粒度的组合,可以提高处理器的执行效率&lt;/p>
&lt;p>在有dcache的处理器中,在虚拟地址转化为物理地址之后先去访问dcache,需要有一部分空间是不允许缓存的&lt;/p>
&lt;p>PTE包含&lt;/p>
&lt;p>(1)PFN,表示虚拟地址对应的物理地址的页号&lt;/p>
&lt;p>(2)Valid,表示对应页当前是否在物理内存中&lt;/p>
&lt;p>(3)Dirty,表示对应页中内容是否被修改&lt;/p>
&lt;p>(4)Use,表示对应页中的内容是否被修改过&lt;/p>
&lt;p>(5)AP,访问权限控制,表示操作系统和用户程序对当前页的访问权限&lt;/p>
&lt;p>(6)Cacheable,表示对应页是否被缓存&lt;/p>
&lt;h2 id="tlb和cache">TLB和Cache&lt;/h2>
&lt;h3 id="tlb">TLB&lt;/h3>
&lt;p>TLB(Translation Lookaside Buffer)用来缓存页表中最近使用的PTE,这样就不需要每次都去访问两次物理内存&lt;/p>
&lt;p>TLB只有时间相关性,空间相关性没有明显的规律&lt;/p>
&lt;p>一般TLB使用全相连的方式来设计&lt;/p>
&lt;p>现代处理器采用两级TLB,一级TLB采用哈佛结构,分为I-TLB和D-TLB,采用全相联,二级TLB是指令和数据共用,一般采用组相连&lt;/p>
&lt;p>TLB命中,直接返回从TLB中得到的物理地址,TLB缺失,需要访问物理内存中的页表&lt;/p>
&lt;ol>
&lt;li>页表中的PTE有效,直接从页表中得到对应的物理地址&lt;/li>
&lt;li>页表中的PTE无效,需要从硬盘中去将相应的页搬移到物理内存中&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 260;
flex-basis: 624px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233.png" data-size="484x186">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233.png"
width="484"
height="186"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233_hu8864321583826033378.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113140352233_hu16150349096023952055.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>现代处理器中都支持大小可变的页,由操作系统进行管理,根据不同应用的特点选用不同大小的页&lt;/p>
&lt;h4 id="tlb缺失">TLB缺失&lt;/h4>
&lt;p>(1)虚拟地址对应的页不再物理内存中&lt;/p>
&lt;p>(2)虚拟地址对应的页在物理内存中,但是PTE没有放在TLB中&lt;/p>
&lt;p>Page Table Walk:从页表中找到对应的映射关系,并将其写回到TLB中&lt;/p>
&lt;ol>
&lt;li>软件实现Page Table Walk.当发生TLB缺失,硬件把产生TLB缺失的虚拟地址保存到特殊寄存器中,产生TLB缺失的异常,在异常处理程序中,软件使用虚拟地址去寻址物理内存中的页表,找到对应的PTE,并且写回到TLB中 .为了防止在异常处理程序中又发生TLB缺失,这个程序会放在不需要进行地址转化的物理内存上 ,软件处理会冲说流水线&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 115;
flex-basis: 277px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171.png" data-size="434x375">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171.png"
width="434"
height="375"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171_hu6588184095300100579.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113141426171_hu7411631538644157319.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ol start="2">
&lt;li>硬件实现Page Table Walk. 当发生TLB缺失时,自动使用当前的虚拟地址去寻址页表.硬件进行逐级寻址是比较方便的.这种方式比较适合超标量处理器,不需要打断流水线,但是如果操作系统没有在物理内存中建立好了页表,那硬件没有办法,还是得通过操作系统&lt;/li>
&lt;/ol>
&lt;p>采用硬件处理TLB缺失需要使用硬件状态机来寻址页表,还需要将整个流水线暂停等待MMU处理缺失,但是在处理完之后就可以直接去执行.采用软件处理,需要执行异常处理程序,而且从异常处理程序退出后,将流水线恢复到TLB缺失发生之前的状态&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 189;
flex-basis: 454px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186.png" data-size="720x380">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186.png"
width="720"
height="380"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186_hu10080609097408610238.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113162814186_hu9383525678854467250.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>发生TLB缺失,如果需要的PTE在页表中,则TLB缺失的处理时间需要十几个周期,如果发生Page Fault异常,则需要成百上千个周期&lt;/p>
&lt;p>对于TLB来说,随机替换算法是比较合适的,可以采用称为时钟算法的方法,就是通过计数器去随机取值,128的表项就可以通过7位的计数器来随机编号&lt;/p>
&lt;h4 id="tlb的写入">TLB的写入&lt;/h4>
&lt;p>在使用TLB作为页表的缓存,处理器送出的虚拟缓存会访问TLB,如果直接从TLB得到物理地址的话,会使得TLB对应的&amp;quot;use&amp;quot;set,如果是store,会使得dirty=1.但是,如果TLB采用写回,那此时不会去更新页表,所以页表的信息可能是过时的,一种方法是在Page Fault的时候,把所有TLB的表项写回到页表&lt;/p>
&lt;p>但实际上没有必要,可以认为被TLB记录的页都是要被使用的,是无法被替换的,操作系统可以记录哪些PTE被放到了TLB中,这样实际上也能够避免当物理内存中一个页被踢出了之后,还需要查找它在TLB中是否被记录了,如果有还需要置0&lt;/p>
&lt;p>操作系统也需要有能够控制dcache的能力,因为操作系统在物理内存中选择一个页进行替换的时候,如果这个页是脏的,它最新的内容不一定是在物理内存中,还有可能在dcache中.虽然说,存在在TLB的页不会被替换,那按理来说,存在在dcache的数据所对应的页也不会被替换.但是也有例外,比方说,发生TLB缺失之后,有TLB表项的会被替换,但是此时D-cache是没有发生变化的,&lt;/p>
&lt;h4 id="对tlb进行控制">对TLB进行控制&lt;/h4>
&lt;p>TLB是页表的缓存,如果一个页的映射关系在页表中不存在了,那么它在TLB中也不应该存在&lt;/p>
&lt;p>(1)当一个进程结束,进程的指令(code),数据(data)和堆栈(stack)占据的页表置为无效,此时TLB中可能还存在对应的PTE,可以通过ASID去吧I-TLB和D-TLB的内容置为无效&lt;/p>
&lt;p>(2)当一个进程占用的物理内存过大时,操作系统可能将进程中一部分不经常使用的页写回到硬盘中,也需要将TLB置为无效&lt;/p>
&lt;p>对TLB的管理需要包括,1.能够将I-TLB和D-TLB的所有表项置为无效 2. 能够将I-TLB和D-TLB中的某一个ASID对应的所有表项置为无效 3.能够将某个VPN对应的表项置为无效&lt;/p>
&lt;h5 id="arm的tlb管理">ARM的TLB管理&lt;/h5>
&lt;p>(1)用来管理I-TLB的控制寄存器&lt;/p>
&lt;ol>
&lt;li>将VPN匹配的表项(entry)置为无效的控制寄存器&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>VPN相等&lt;/li>
&lt;li>如果TLB中一个表项的Global位无效,需要ASID相等,如果Global有效,则不需要&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 503;
flex-basis: 1209px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975.png" data-size="635x126">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975.png"
width="635"
height="126"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975_hu2455770362994303047.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113202311975_hu15984741137560243802.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>进程中某些地址的映射信息被改变时,需要将TLB对应的表项置为无效&lt;/p>
&lt;ol start="2">
&lt;li>将TLB中ASID匹配的所有表项置为无效的控制寄存器&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 483;
flex-basis: 1159px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169.png" data-size="657x136">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169.png"
width="657"
height="136"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169_hu3854128643418782147.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113203804169_hu15103547143579885177.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>​ 当一个进程退出的时候,需要将当前进程在TLB中的所有内容都置为无效&lt;/p>
&lt;ol start="3">
&lt;li>将TLB中所有未锁定(unlocker)状态的表项置为无效,锁定状态的表项不发生改变.为了加快处理器某些关键程序的执行时间,可以吧一些表项设为锁定状态&lt;/li>
&lt;/ol>
&lt;p>(2) 用来管理D-TLB的控制寄存器同理&lt;/p>
&lt;p>(3)用于将TLB的内容进行读出和写入&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 216;
flex-basis: 518px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210.png" data-size="510x236">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210.png"
width="510"
height="236"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210_hu1808296226409048137.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113204427210_hu13257119095023359013.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>使用两个寄存器来对应一个表项,data1和data0,当读取TLB时,被读取表项的内容会放在寄存器中,&lt;/p>
&lt;p>上面的寄存器都位于系统控制协处理器中,只需要通过访问协处理器的指令(MCR和MRC)就可以了&lt;/p>
&lt;h5 id="mips风格的tlb管理">MIPS风格的TLB管理&lt;/h5>
&lt;p>MIPS,TLB缺失通过软件来解决,MIPS定义了专门操作TLB的指令,使用这些指令可以直接对TLB进行操作&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 134;
flex-basis: 321px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933.png" data-size="845x630">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933.png"
width="845"
height="630"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933_hu14168470725230903113.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113205448933_hu6626241744745778815.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 292;
flex-basis: 701px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426.png" data-size="555x190">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426.png"
width="555"
height="190"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426_hu14294742867446194869.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113210011426_hu3988204457967568634.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>MIPS处理器中,为了加快寻址页表的过程,硬件会自动将这两个部分(页表的基地址和偏移地址)放在context寄存器中,位于协处理器CP0.由于load指令无法直接使用CP0中的寄存器,首先要把context寄存器放在通用寄存器$k1中,在MIPS架构中,R26和R27只用在中断和异常中,也称为$k1和$k0&lt;/p>
&lt;p>TLBWR将entryHi和EntryLo寄存器的内容写到TLB内随机指定的一个表项中,在发生TLB缺失,会自动将当前未能转换的虚拟地址的VPN以及当前进程的ASID写入到EntryHi寄存器中&lt;/p>
&lt;h3 id="cache的设计">Cache的设计&lt;/h3>
&lt;p>TLB只是加速了从虚拟地址到物理地址的转换,但是没有加速从物理内存中取数据的过程,也可以使用cache来加速&lt;/p>
&lt;p>下面是物理Cache,和没有加入TLB其实是一样的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 390;
flex-basis: 937px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553.png" data-size="578x148">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553.png"
width="578"
height="148"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553_hu15455923065170511424.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113211628553_hu1233705023164367393.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>因为要经过TLB,才能访问物理Cache,所以会增加流水线的延时,如果要获得和之前一样的运行频率,需要再加入一级流水线,但是这样增大了分支预测失败的惩罚,也增大了load指令的延迟&lt;/p>
&lt;p>可以直接使用Virtual Cache来缓存数据&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 368;
flex-basis: 884px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556.png" data-size="538x146">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556.png"
width="538"
height="146"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556_hu1682197753071144083.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113212837556_hu6588021925935794266.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>虚拟Cache会导致两个问题&lt;/p>
&lt;p>(1)同义问题(synonyms),也称为重名(aliasing),即多个不同的名字对应相同的物理位置,会出现Cache不同虚拟地址但实际上对应着相同的物理地址,这样就会浪费Cache的空间,而且load了数据了之后需要对其他虚拟地址的Cache都进行更改,因为实际上它们对应着同一个物理地址.&lt;/p>
&lt;p>如果Cache的容量&amp;lt;4KB,寻址的地址不会&amp;gt;12位,那么对应同一个物理地址的不同虚拟地址也会放在Cache的相同地址上,反之就可能出现同义&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 218;
flex-basis: 523px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617.png" data-size="587x269">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617.png"
width="587"
height="269"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617_hu12388999493876051402.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222410617_hu12531450076396476628.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>要实现同时更新相同物理地址的Cache,就需要使用物理地址作为Cache的Tag部分,&lt;/p>
&lt;p>下图的结构就可以解决同义的问题,&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 141;
flex-basis: 339px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874.png" data-size="434x307">
&lt;img src="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874.png"
width="434"
height="307"
srcset="https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874_hu12138166093619374866.png 480w, https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/image-20241113222603874_hu6070767854557535341.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>未完待续&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>NBDcache</title><link>https://VastCircle.github.io/2024/nbdcache/</link><pubDate>Mon, 11 Nov 2024 16:33:27 +0800</pubDate><guid>https://VastCircle.github.io/2024/nbdcache/</guid><description>&lt;h2 id="dcache结构图">Dcache结构图&lt;/h2>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 141;
flex-basis: 339px"
>
&lt;a href="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png" data-size="996x705">
&lt;img src="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png"
width="996"
height="705"
srcset="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu11066709581250157466.png 480w, https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu15637605824835427283.png 1024w"
loading="lazy"
alt="image-20241111163907552">
&lt;/a>
&lt;figcaption>image-20241111163907552&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>noblockcache 中共例化了3个小模块,writebackUnit,ProbeUnit,MSHRFile&lt;/p>
&lt;h2 id="模块介绍">模块介绍&lt;/h2>
&lt;h3 id="nonblockingdcachemodule">NonBlockingDCacheModule&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">s1_req&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Reg&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">HellaCacheReq&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// s1主要是打了一拍,下面其实是在决定把什么数据打一拍
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// cpu_req : cpu的请求信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cpu&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cpu&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 写回module的请求信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">wb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Cat&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">wb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">wb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">phys&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 控制module的请求信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">prober&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Cat&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">prober&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">prober&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">phys&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">mshrs&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">mshrs&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">s2_recycle&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_req&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s2_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s1_clk_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">out&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#7f848e">//TODO: should be metaReadArb.io.out.fire, but triggers Verilog backend bug
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// metaReadArb按理有5个端口,但是生成的时候端口0貌似被优化了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s2_recycle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s2_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">~&lt;/span>&lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s2_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">mshrs&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">2&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">prober&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">3&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">wb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">4&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cpu&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">4&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cpu&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">4&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cpu&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">untagBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">metaReadArb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">4&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">~&lt;/span>&lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="wbu">WBU&lt;/h3>
&lt;p>&lt;code>WritebackUnit&lt;/code> 模块实现了一个缓存的写回单元，用于将数据从 L1 缓存写回到内存或下一级缓存。它主要负责管理写回请求和发送数据到内存或其他设备，并包含多种信号来控制写回过程&lt;/p>
&lt;p>&lt;code>refillCycles&lt;/code> 表示在发生缓存未命中（cache miss）时，从主存或其他缓存中读取数据并将其填充到目标缓存的过程所需的时钟周期数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">active&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">r1_data_req_fired&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">false&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">r2_data_req_fired&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">r1_data_req_fired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 返回数据并且返回tag的时候
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 拉高r1_data_req_fired
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">r1_data_req_fired&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 计数器+1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#56b6c2">+&lt;/span> &lt;span style="color:#d19a66">1.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">r2_data_req_fired&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 在返回后的第二拍,拉高release.valid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">release&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span>&lt;span style="color:#56b6c2">(!&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">release&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">r1_data_req_fired&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">false&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">r2_data_req_fired&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">false&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 一般都是减去2,除非refilllCycles &amp;lt;= 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#56b6c2">-&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">[&lt;/span>&lt;span style="color:#e5c07b">UInt&lt;/span>&lt;span style="color:#56b6c2">]((&lt;/span>&lt;span style="color:#e06c75">refillCycles&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">B&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">r1_data_req_fired&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#d19a66">2.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#d19a66">1.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span>&lt;span style="color:#56b6c2">(!&lt;/span>&lt;span style="color:#e06c75">r1_data_req_fired&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// We&amp;#39;re done if this is the final data request and the Release can be sent
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">active&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#e06c75">refillCycles&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">release&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 发起请求的时候进行active 和 赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">active&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">req&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 同一时刻获取了多个数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">fire&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">if&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">refillCycles&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">Cat&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">data_req_cnt&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">log2Up&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">refillCycles&lt;/span>&lt;span style="color:#56b6c2">)-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">else&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">rowOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="probe">Probe&lt;/h3>
&lt;p>实现了Cache管理模块的状态机，主要用于处理探测请求的操作，管理Cache的状态，判断命中情况，以及处理数据写回操作,主要针对的是tag,不是data&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 9个状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">s_invalid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#e5c07b">:&lt;/span> &lt;span style="color:#e5c07b">s_meta_read&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span> &lt;span style="color:#e5c07b">s_meta_resp&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span> &lt;span style="color:#e5c07b">s_mshr_req&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s_mshr_resp&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#e5c07b">:&lt;/span> &lt;span style="color:#e5c07b">s_release&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span> &lt;span style="color:#e5c07b">s_writeback_req&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span> &lt;span style="color:#e5c07b">s_writeback_resp&lt;/span> &lt;span style="color:#e5c07b">::&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">s_meta_write&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#e5c07b">:&lt;/span> &lt;span style="color:#e5c07b">Nil&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Enum&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">9&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_meta_resp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// we need to wait one cycle for the metadata to be read from the array
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_meta_resp&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_mshr_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_mshr_req&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">old_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">block_state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 比较有意思,如果没有rdy,不是选择wait,而是retry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// if the read didn&amp;#39;t go through, we need to retry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">mshr_rdy&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">s_mshr_resp&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">s_meta_read&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逻辑是比较简单的,就是当发起请求时,去meta_read,meta_read之后去读mshr,读出mshr之后,当tag_match的时候且为dirty,需要写回,所以切换到s_writeback_req ,否则到release,release之后去meta_write.写回是由wb模块控制的&lt;/p>
&lt;h3 id="l1metadataarray-mata">L1MetadataArray mata&lt;/h3>
&lt;p>meta就是存储tag的地方,是一个同步ram&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// () =&amp;gt; T是函数的写法 ,无输入参数,输出参数是T类型的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">L1MetadataArray&lt;/span>&lt;span style="color:#56b6c2">[&lt;/span>&lt;span style="color:#e5c07b">T&lt;/span> &lt;span style="color:#c678dd">&amp;lt;:&lt;/span> &lt;span style="color:#e5c07b">L1Metadata&lt;/span>&lt;span style="color:#56b6c2">](&lt;/span>&lt;span style="color:#e06c75">onReset&lt;/span>&lt;span style="color:#c678dd">:&lt;/span> &lt;span style="color:#56b6c2">()&lt;/span> &lt;span style="color:#56b6c2">=&amp;gt;&lt;/span> &lt;span style="color:#e06c75">T&lt;/span>&lt;span style="color:#56b6c2">)(&lt;/span>&lt;span style="color:#c678dd">implicit&lt;/span> &lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#c678dd">:&lt;/span> &lt;span style="color:#e5c07b">Parameters&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e06c75">L1HellaCacheModule&lt;/span>&lt;span style="color:#56b6c2">()(&lt;/span>&lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">rstVal&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">onReset&lt;/span>&lt;span style="color:#56b6c2">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">io&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">IO&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">Bundle&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">read&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Flipped&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">Decoupled&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">L1MetaReadReq&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">write&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Flipped&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">Decoupled&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">L1MetaWriteReq&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">resp&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Output&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">Vec&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">rstVal&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cloneType&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">rst_cnt&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">RegInit&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">log2Up&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nSets&lt;/span>&lt;span style="color:#56b6c2">+&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">rst&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">rst_cnt&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#e06c75">nSets&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">waddr&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">rst_cnt&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">wdata&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">rstVal&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">asUInt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// way_en是独热码的形式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">wmask&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span> &lt;span style="color:#56b6c2">==&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#56b6c2">(-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">S&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">asSInt&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">asBools&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">rmask&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span> &lt;span style="color:#56b6c2">==&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#56b6c2">(-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">S&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">asSInt&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">asBools&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#e06c75">rst_cnt&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">rst_cnt&lt;/span>&lt;span style="color:#56b6c2">+&lt;/span>&lt;span style="color:#d19a66">1.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">metabits&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">rstVal&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">getWidth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// way 是路数 , sets是组数 , way_en 就是用来选择路的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// 同步mem
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">tag_array&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">SyncReadMem&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nSets&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">Vec&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">UInt&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">metabits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">wen&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">rst&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">wen&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">tag_array&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">waddr&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">VecInit&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fill&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">)(&lt;/span>&lt;span style="color:#e06c75">wdata&lt;/span>&lt;span style="color:#56b6c2">),&lt;/span> &lt;span style="color:#e06c75">wmask&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// read data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">resp&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">tag_array&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">read&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">()).&lt;/span>&lt;span style="color:#e06c75">map&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">_&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">asTypeOf&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">chiselTypeOf&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">rstVal&lt;/span>&lt;span style="color:#56b6c2">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">wen&lt;/span> &lt;span style="color:#7f848e">// so really this could be a 6T RAM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">rst&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="metareadarb-or-metawritearb">metaReadArb or metaWriteArb&lt;/h3>
&lt;p>metaReadArb仲裁输入为 mshrs , prober , wb&lt;/p>
&lt;h3 id="mshrfile">MSHRFile&lt;/h3>
&lt;p>缓存控制中的关键部分，用于处理多组MSHR（Miss Status Holding Register），协调多种请求（读、写、填充、写回等）在一级缓存（L1 Cache）中的操作。&lt;/p>
&lt;h4 id="cacheable">cacheable&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">cacheable&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">edge&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">manager&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">supportsAcquireBFast&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">lgCacheBlockBytes&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>cacheable&lt;/code>用于检测当前请求的地址是否可以被缓存。&lt;code>edge.manager.supportsAcquireBFast&lt;/code>方法检查缓存控制器是否支持快速获取操作。&lt;/p>
&lt;h4 id="sdq">sdq&lt;/h4>
&lt;p>用于管理store data queue&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 位向量寄存器，用于跟踪SDQ中的空闲条目。每一位代表一个位置，如果为1则表示该位置已被分配，若为0则表示空闲
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">sdq_val&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">RegInit&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 通过优先编码获取其中一个空闲的sdq的id,从左往右第一个0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// 比方说 priorityEncoder(0b0100) = 2 ,priorityEncoder(0b0111) = 2 ,独热转数值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">sdq_alloc_id&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">PriorityEncoder&lt;/span>&lt;span style="color:#56b6c2">(~&lt;/span>&lt;span style="color:#e06c75">sdq_val&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 如果不是全部为1代表有空闲,设为ready
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">sdq_rdy&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">sdq_val&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">andR&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 表示当前请求是否满足写入SDQ的条件 ,需要请求有效,请求能够被接受,可缓存,并且是写命令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">sdq_enq&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">cacheable&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">isWrite&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cmd&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// store data queue ,存放数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">sdq&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mem&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">UInt&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">coreDataBits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 当满足条件,就写入相应数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">sdq_enq&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#e06c75">sdq&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">sdq_alloc_id&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 用于指示是否可以释放存储数据队列中的一个条目,当io.replay.fire（即重放请求有效且被接受）且当前重放指令是写操作（isWrite(io.replay.bits.cmd)）时，free_sdq为true，表示可以释放该条目。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">free_sdq&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">isWrite&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cmd&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">sdq&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">RegEnable&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">replay_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">out&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">sdq_id&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">free_sdq&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">mask&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">replay_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">out&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// sdq_enq代表要去分配sdq了 io_replay.valid 代表sdq使用完了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// uIntToOH(3) = 0b0100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// priotityEncoderOH把最靠近左边的1 set , 比方说 sdq_val = 0b0011, 则 priorityEncoderOH(~sdq_val(cfg.SDQ-1,0)) = 0b0010
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#e06c75">sdq_enq&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">sdq_val&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">sdq_val&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#56b6c2">~(&lt;/span>&lt;span style="color:#e5c07b">UIntToOH&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">replay_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">out&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">sdq_id&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#e5c07b">Fill&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">free_sdq&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span> &lt;span style="color:#7f848e">// reset
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#56b6c2">|&lt;/span> &lt;span style="color:#e5c07b">PriorityEncoderOH&lt;/span>&lt;span style="color:#56b6c2">(~&lt;/span>&lt;span style="color:#e06c75">sdq_val&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#e5c07b">Fill&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nSDQ&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">sdq_enq&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#7f848e">// set
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">replay_arb&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Module&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">Arbiter&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">ReplayInternal&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nMSHRs&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="mshr">mshr&lt;/h4>
&lt;p>每个MSHR处理一个缓存块的缺失请求&lt;/p>
&lt;p>mshr应该就是其中的一个表项,这里通过状态机来判断表项是一次缺失还是二次缺失 ,是不是太奢侈了&lt;/p>
&lt;p>该模块的主要功能是管理和协调多种缓存操作，&lt;/p>
&lt;ol>
&lt;li>处理缓存未命中时的请求。&lt;/li>
&lt;li>向主存发出请求并等待响应。&lt;/li>
&lt;li>维护状态机以跟踪请求的进度。&lt;/li>
&lt;li>根据不同情况执行不同的控制流。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">idxMatch&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Wire&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">Vec&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nMSHRs&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">Bool&lt;/span>&lt;span style="color:#56b6c2">()))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">tagList&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Wire&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">Vec&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nMSHRs&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">Bits&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">tagBits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// idxMatch 只有一个会拉高
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">tag_match&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux1H&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">idxMatch&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">tagList&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">untagBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="状态转移及相应输出">状态转移及相应输出&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// state 是一个寄存器，用于跟踪 MSHR 的状态。状态机的主要状态包括：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_invalid：空闲状态，表示 MSHR 未被占用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_wb_req 和 s_wb_resp：处理写回操作的状态。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_meta_clear：清理缓存元数据。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_refill_req 和 s_refill_resp：处理从主存中获取数据的请求。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_meta_write_req 和 s_meta_write_resp：更新缓存元数据。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// s_drain_rpq：处理重放队列的请求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_drain_rpq&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">deq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_invalid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_meta_write_resp&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// this wait state allows us to catch RAW hazards on the tags via nack_victim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_drain_rpq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_meta_write_req&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_meta_write_resp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_refill_resp&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">refill_done&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">new_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">coh_on_grant&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_meta_write_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">mem_acquire&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// s_refill_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_refill_resp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_meta_clear&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_refill_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_wb_resp&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">acked&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_meta_clear&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">fire&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// s_wb_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_wb_resp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_sec_val&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_sec_rdy&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// s_wb_req, s_wb_resp, s_refill_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">//If we get a secondary miss that needs more permissions before we&amp;#39;ve sent
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// out the primary miss&amp;#39;s Acquire, we can upgrade the permissions we&amp;#39;re
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// going to ask for in s_refill_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cmd&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">dirtier_cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">is_hit_again&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">new_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">dirtier_coh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 首次miss的时候,赋值req,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_val&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_rdy&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">req&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">acked&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">false&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">old_coh&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">old_meta&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">coh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">needs_wb&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">old_coh&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">onCacheControl&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">M_FLUSH&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">_1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">is_hit&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#c678dd">_&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">coh_on_hit&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">old_coh&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">onAccess&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cmd&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag_match&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">when&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">is_hit&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// set dirty bit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">new_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">coh_on_hit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_meta_write_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}.&lt;/span>&lt;span style="color:#e06c75">otherwise&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// upgrade permissions
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">new_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">old_coh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">s_refill_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}.&lt;/span>&lt;span style="color:#e06c75">otherwise&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#7f848e">// writback if necessary and refill
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">new_coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">ClientMetadata&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">onReset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">needs_wb&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">s_wb_req&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">s_meta_clear&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// state === s_meta_write_req or s_mata_clear
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">isOneOf&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">s_meta_write_req&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">s_meta_clear&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">coh&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_meta_clear&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">coh_on_clear&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">new_coh&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">data&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_write&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// state === s_wb_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_wb_req&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">source&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">id&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">old_meta&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">param&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">shrink_param&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">wb_req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">voluntary&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// state === s_refill_req
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">mem_acquire&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_refill_req&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">grantackq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">enq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">mem_acquire&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">edge&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e5c07b">AcquireBlock&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">fromSource&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">id&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">toAddress&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Cat&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">lgSize&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">lgCacheBlockBytes&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">growPermissions&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">grow_param&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">_2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// state === s_drain_rpq
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_drain_rpq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">meta_read&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">way_en&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">~(&lt;/span>&lt;span style="color:#d19a66">0.&lt;/span>&lt;span style="color:#e06c75">U&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">nWays&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">W&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 重放接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_drain_rpq&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">deq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">deq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">phys&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">true&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e5c07b">Cat&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">deq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 115;
flex-basis: 276px"
>
&lt;a href="https://VastCircle.github.io/2024/nbdcache/image-20241106195931879.png" data-size="680x590">
&lt;img src="https://VastCircle.github.io/2024/nbdcache/image-20241106195931879.png"
width="680"
height="590"
srcset="https://VastCircle.github.io/2024/nbdcache/image-20241106195931879_hu6446209596390823114.png 480w, https://VastCircle.github.io/2024/nbdcache/image-20241106195931879_hu13976723951433692804.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="rpq">rpq&lt;/h5>
&lt;ul>
&lt;li>用于暂存未能成功处理的请求，比如因缺少权限、数据尚未准备好等原因导致的请求失败。&lt;/li>
&lt;li>这些请求将在条件满足时重新尝试（重放）。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">rpq&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Module&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">NBDcacheQueue&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">ReplayInternal&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e06c75">cfg&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">nRPQ&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">enq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_val&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_rdy&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_sec_val&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">sec_rdy&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">isPrefetch&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">cmd&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">enq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">bits&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">rpq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">deq&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">replay&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_drain_rpq&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">||&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_invalid&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="addr的划分">addr的划分&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">req&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Reg&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">MSHRReqInternal&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">req_idx&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">untagBits&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">req_tag&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">untagBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">req_block_addr&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">idx_match&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e5c07b">Mux&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">runahead_flag&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">req_block_addr&lt;/span> &lt;span style="color:#56b6c2">=/=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">false&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">B&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#e06c75">req_idx&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_bits&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">addr&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">untagBits&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span>&lt;span style="color:#e06c75">blockOffBits&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">tag&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">req_tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">idx_match&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">=/=&lt;/span> &lt;span style="color:#e06c75">s_invalid&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">idx_match&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 140;
flex-basis: 336px"
>
&lt;a href="https://VastCircle.github.io/2024/nbdcache/image-20241106201348356.png" data-size="584x416">
&lt;img src="https://VastCircle.github.io/2024/nbdcache/image-20241106201348356.png"
width="584"
height="416"
srcset="https://VastCircle.github.io/2024/nbdcache/image-20241106201348356_hu16547176067045010742.png 480w, https://VastCircle.github.io/2024/nbdcache/image-20241106201348356_hu4742350107554157333.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="pri_val和pri_rdy">pri_val和pri_rdy&lt;/h4>
&lt;p>仲裁器的逻辑是多个valid同时拉高,取优先级最高的,然后把相应的ready拉高&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">mshr&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_val&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">alloc_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_rdy&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">state&lt;/span> &lt;span style="color:#56b6c2">===&lt;/span> &lt;span style="color:#e06c75">s_invalid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">alloc_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">in&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">).&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">mshr&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req_pri_rdy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">alloc_arb&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">out&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">ready&lt;/span> &lt;span style="color:#c678dd">:&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">io&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">req&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">valid&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">sdq_rdy&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e06c75">cacheable&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#56b6c2">!&lt;/span>&lt;span style="color:#e06c75">idx_match&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/JACKLJ1998/article/details/124907527" target="_blank" rel="noopener"
>rocket-chip学习基础篇&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>CPU路径查找</title><link>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Thu, 07 Nov 2024 20:15:39 +0800</pubDate><guid>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="rocket-chip">Rocket chip&lt;/h2>
&lt;h3 id="fronted-frontend-tileprcidomain_3sv">Fronted frontend TilePRCIDomain_3.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 229;
flex-basis: 550px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png" data-size="1084x473">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png"
width="1084"
height="473"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu14349559803779590629.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu3287867411019239527.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="icache_3-icache-frontendsv">ICache_3 icache frontend.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 173;
flex-basis: 416px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png" data-size="1040x599">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png"
width="1040"
height="599"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu3808893905549217750.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu1492137510679196975.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="shiftqueue-fq-frontendsv">ShiftQueue fq frontend.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 122;
flex-basis: 293px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108202808587.png" data-size="711x581">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108202808587.png"
width="711"
height="581"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108202808587_hu513558571854330789.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108202808587_hu12987515772162186454.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="fronted-frontend-tileprcidomain_3sv-1">Fronted frontend TilePRCIDomain_3.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 190;
flex-basis: 457px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204659652.png" data-size="1228x644">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204659652.png"
width="1228"
height="644"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204659652_hu5985934486798114724.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204659652_hu17841243896445509685.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="rocket-core-tockettilesv">Rocket core TocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 255;
flex-basis: 612px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204834283.png" data-size="1169x458">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204834283.png"
width="1169"
height="458"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204834283_hu14996134971470249806.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108204834283_hu10214860344796493209.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="ibuf-ibuf-rocketsv">IBuf ibuf Rocket.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 279px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108205159959.png" data-size="1031x884">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108205159959.png"
width="1031"
height="884"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108205159959_hu3759903210282004687.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108205159959_hu13366077453679616817.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="ex">ex&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 2397;
flex-basis: 5754px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211542867.png" data-size="983x41">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211542867.png"
width="983"
height="41"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211542867_hu14339384708395461656.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211542867_hu3540331024596521768.png 1024w"
loading="lazy"
alt="image-20241108211542867">
&lt;/a>
&lt;figcaption>image-20241108211542867&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 218;
flex-basis: 523px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211144708.png" data-size="921x422">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211144708.png"
width="921"
height="422"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211144708_hu6202380733267426743.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211144708_hu8761679022481420618.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="mem">mem&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 1021;
flex-basis: 2450px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211632083.png" data-size="388x38">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211632083.png"
width="388"
height="38"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211632083_hu17307897966553544629.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211632083_hu13539341254218040853.png 1024w"
loading="lazy"
alt="image-20241108211632083">
&lt;/a>
&lt;figcaption>image-20241108211632083&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 2990;
flex-basis: 7178px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211601921.png" data-size="987x33">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211601921.png"
width="987"
height="33"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211601921_hu18111737323352843393.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211601921_hu6438319314320234714.png 1024w"
loading="lazy"
alt="image-20241108211601921">
&lt;/a>
&lt;figcaption>image-20241108211601921&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 471px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211304265.png" data-size="959x488">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211304265.png"
width="959"
height="488"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211304265_hu15403985173756409354.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211304265_hu7971441811045492083.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="wb">wb&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 228;
flex-basis: 547px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211340591.png" data-size="764x335">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211340591.png"
width="764"
height="335"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211340591_hu18344354897185255550.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108211340591_hu1034902917194609187.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 595;
flex-basis: 1430px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231547615.png" data-size="733x123">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231547615.png"
width="733"
height="123"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231547615_hu15759811981115158062.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231547615_hu17846227601883584320.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 184;
flex-basis: 443px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231941051.png" data-size="634x343">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231941051.png"
width="634"
height="343"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231941051_hu4135732964752938484.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108231941051_hu1643998207803390268.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="dcache">dcache&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 480;
flex-basis: 1153px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003838160.png" data-size="740x154">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003838160.png"
width="740"
height="154"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003838160_hu12429423599258332429.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003838160_hu8295382219566744840.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 2569;
flex-basis: 6166px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003912379.png" data-size="591x23">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003912379.png"
width="591"
height="23"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003912379_hu7323887026170601464.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109003912379_hu9603836019243100006.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="rocket-core-tockettilesv-1">Rocket core TocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 173;
flex-basis: 415px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004039636.png" data-size="912x527">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004039636.png"
width="912"
height="527"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004039636_hu2784142330751999404.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004039636_hu10720367498505083357.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="hellacachearbiter_3-dcachearb-rockettilesv">HellaCacheArbiter_3 dcacheArb RocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 256;
flex-basis: 615px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004426330.png" data-size="905x353">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004426330.png"
width="905"
height="353"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004426330_hu1359324853660240157.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004426330_hu9207067885292737744.png 1024w"
loading="lazy"
alt="image-20241109004426330">
&lt;/a>
&lt;figcaption>image-20241109004426330&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 210;
flex-basis: 504px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004355614.png" data-size="956x455">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004355614.png"
width="956"
height="455"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004355614_hu17144604750392189171.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004355614_hu14861537260138690430.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="nonblockingdcache-dcache-rockettilesv">NonBlockingDcache dcache RocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 191;
flex-basis: 458px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004552516.png" data-size="892x467">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004552516.png"
width="892"
height="467"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004552516_hu14173927082951209843.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004552516_hu4669464637936122028.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 142;
flex-basis: 342px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005300769.png" data-size="885x620">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005300769.png"
width="885"
height="620"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005300769_hu13045579091895120762.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005300769_hu12283695045688537668.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="hellacachearbiter_3-dcachearb-rockettilesv-1">HellaCacheArbiter_3 dcacheArb RocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 186;
flex-basis: 447px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005355471.png" data-size="978x525">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005355471.png"
width="978"
height="525"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005355471_hu199804206045985022.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005355471_hu2676843441091233923.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 205;
flex-basis: 493px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005444805.png" data-size="1018x495">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005444805.png"
width="1018"
height="495"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005444805_hu829563224719690987.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109005444805_hu5690625155070373547.png 1024w"
loading="lazy"
alt="image-20241109005444805">
&lt;/a>
&lt;figcaption>image-20241109005444805&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="rocket-core-tockettilesv-2">Rocket core TocketTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 479px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004129640.png" data-size="1257x629">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004129640.png"
width="1257"
height="629"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004129640_hu6503813824269994709.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109004129640_hu8201521590196748229.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="boom">Boom&lt;/h2>
&lt;h3 id="boomfronted-frontend-tileprcidomainsv">BoomFronted frontend TilePRCIDomain.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 248;
flex-basis: 597px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107210802374.png" data-size="1212x487">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107210802374.png"
width="1212"
height="487"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107210802374_hu8124157532190127058.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107210802374_hu10926378619108615829.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="icache-icache-boomfrontendsv">ICache icache BoomFrontend.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 198;
flex-basis: 477px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211007890.png" data-size="1026x516">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211007890.png"
width="1026"
height="516"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211007890_hu12743351659580378863.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211007890_hu11232573669276227398.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 213;
flex-basis: 512px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211954075.png" data-size="1085x508">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211954075.png"
width="1085"
height="508"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211954075_hu2647368183426488806.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107211954075_hu1322618529820894187.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="queue_66-f3-boomfrontendsv">Queue_66 f3 BoomFrontend.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 197;
flex-basis: 473px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107212114562.png" data-size="1285x652">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107212114562.png"
width="1285"
height="652"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107212114562_hu17691459690145034948.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107212114562_hu9433234162199653207.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 232;
flex-basis: 557px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107213632956.png" data-size="1348x580">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107213632956.png"
width="1348"
height="580"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107213632956_hu16113017456054408637.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241107213632956_hu15821295644890650218.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="queue_69-f4-boomfrontendsv">Queue_69 f4 BoomFrontend.sv&lt;/h4>
&lt;p>8条指令,io_enq_bits_insts_ 是单纯的截位,io_enq_bits_exp_insts_ 是做了rvc的判断&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 1570;
flex-basis: 3770px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103010659.png" data-size="487x31">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103010659.png"
width="487"
height="31"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103010659_hu5951583150755631302.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103010659_hu3473756485690163054.png 1024w"
loading="lazy"
alt="image-20241109103010659">
&lt;/a>
&lt;figcaption>image-20241109103010659&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 1307;
flex-basis: 3138px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103033295.png" data-size="497x38">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103033295.png"
width="497"
height="38"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103033295_hu6908723815852712798.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109103033295_hu5621075333682278741.png 1024w"
loading="lazy"
alt="image-20241109103033295">
&lt;/a>
&lt;figcaption>image-20241109103033295&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 279;
flex-basis: 670px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104521482.png" data-size="626x224">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104521482.png"
width="626"
height="224"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104521482_hu13668299054319362810.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104521482_hu473945337481523508.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 2431;
flex-basis: 5835px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104405554.png" data-size="1313x54">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104405554.png"
width="1313"
height="54"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104405554_hu7097474170041832971.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104405554_hu16843539331689123825.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 210;
flex-basis: 505px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104205267.png" data-size="1249x593">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104205267.png"
width="1249"
height="593"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104205267_hu9148221427469936805.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104205267_hu6706071712276065359.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 207;
flex-basis: 498px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104617208.png" data-size="1232x593">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104617208.png"
width="1232"
height="593"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104617208_hu12854826774788874125.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104617208_hu2693818227387067685.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="fetchbuffer-fb-boomfrontendsv">FetchBuffer fb BoomFrontend.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 187;
flex-basis: 450px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104702043.png" data-size="1067x568">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104702043.png"
width="1067"
height="568"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104702043_hu12792520567011280099.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104702043_hu6586511409438130782.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 381px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104807924.png" data-size="1204x757">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104807924.png"
width="1204"
height="757"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104807924_hu8914910778328599144.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109104807924_hu4003191959123110435.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="boomfrontend-frontend-boomtilesv">BoomFrontend frontend BoomTile.sv&lt;/h3>
&lt;p>io_cpu_fetchpacket_bits_uops_0_&lt;/p>
&lt;p>io_cpu_fetchpacket_bits_uops_1_&lt;/p>
&lt;p>io_cpu_fetchpacket_bits_uops_2_&lt;/p>
&lt;p>io_cpu_fetchpacket_bits_uops_3_&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 165;
flex-basis: 397px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109101138570.png" data-size="1397x844">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109101138570.png"
width="1397"
height="844"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109101138570_hu1246486129446085080.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109101138570_hu410650136068419754.png 1024w"
loading="lazy"
alt="image-20241109101138570">
&lt;/a>
&lt;figcaption>image-20241109101138570&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="boomcore-core-boomtilesv">BoomCore core BoomTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 183;
flex-basis: 440px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105055188.png" data-size="1378x750">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105055188.png"
width="1378"
height="750"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105055188_hu13208145581452871035.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105055188_hu11233789284209721795.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="decodeunit-decode_units_0">DecodeUnit decode_units_0&lt;/h4>
&lt;p>有四个0-3&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 119;
flex-basis: 286px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105511186.png" data-size="982x822">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105511186.png"
width="982"
height="822"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105511186_hu4690906208511837126.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105511186_hu3795239866747434098.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 184;
flex-basis: 441px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105617481.png" data-size="878x477">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105617481.png"
width="878"
height="477"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105617481_hu3566629161398775991.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105617481_hu1170947271359572286.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="renamestage-rename_stage">RenameStage rename_stage&lt;/h4>
&lt;p>还有一个 RenameStage_1 fp_rename_stage,路径也是类似的&lt;/p>
&lt;p>0-3 四个&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 312px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105732640.png" data-size="1125x863">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105732640.png"
width="1125"
height="863"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105732640_hu6701258219543442722.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109105732640_hu3383822999881280409.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 120;
flex-basis: 288px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124925068.png" data-size="1051x875">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124925068.png"
width="1051"
height="875"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124925068_hu7472471987826751948.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124925068_hu6162648488386192514.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="basicdispatcher-dispatcher">BasicDispatcher dispatcher&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 185;
flex-basis: 445px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109123625288.png" data-size="1072x577">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109123625288.png"
width="1072"
height="577"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109123625288_hu1005127347685009220.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109123625288_hu9992304637603904959.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>分发有 0_0-3 to mem_issue_unit&lt;/p>
&lt;p>1_0-3 to int_issue_unit&lt;/p>
&lt;p>2_0-3 to fp_pipline&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 132;
flex-basis: 319px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124116287.png" data-size="1145x861">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124116287.png"
width="1145"
height="861"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124116287_hu2302608763164529896.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109124116287_hu2466545148985078565.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="issueunitcollapsing_2-int_issue_unit">IssueUnitCollapsing_2 int_issue_unit&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 168;
flex-basis: 403px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134122796.png" data-size="1092x649">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134122796.png"
width="1092"
height="649"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134122796_hu1942619670432513016.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134122796_hu16532767809806540250.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 132;
flex-basis: 318px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134037314.png" data-size="919x692">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134037314.png"
width="919"
height="692"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134037314_hu12345869928355474807.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109134037314_hu10410368469663258361.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="registerread_1-iregister_read">RegisterRead_1 iregister_read&lt;/h4>
&lt;p>mem_issue int_issue都一样&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 132;
flex-basis: 318px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109125903180.png" data-size="1063x801">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109125903180.png"
width="1063"
height="801"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109125903180_hu5025679811135702471.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109125903180_hu6665662834117967768.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_5_ alu_exe_unit_1&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_4_ alu_exe_unit&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_3_ csr_exe_unit&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_2_ jmp_unit&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_1_ mem_units_1&lt;/p>
&lt;p>_iregister_read_io_exe_reqs_0_ mem_units_0&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 167;
flex-basis: 401px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130000628.png" data-size="1117x667">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130000628.png"
width="1117"
height="667"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130000628_hu15411012171401665733.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130000628_hu5319994541911725384.png 1024w"
loading="lazy"
alt="image-20241109130000628">
&lt;/a>
&lt;figcaption>image-20241109130000628&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="boomcore-core-boomtilesv-1">BoomCore core BoomTile.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 312px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130128445.png" data-size="1141x877">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130128445.png"
width="1141"
height="877"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130128445_hu1758224827039273006.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130128445_hu12208499545330447122.png 1024w"
loading="lazy"
alt="image-20241109130128445">
&lt;/a>
&lt;figcaption>image-20241109130128445&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="lsu-lsu">LSU lsu&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 201;
flex-basis: 483px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130318130.png" data-size="1280x636">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130318130.png"
width="1280"
height="636"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130318130_hu12221615042060531444.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130318130_hu12352088154573499082.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 313px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130605813.png" data-size="1074x821">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130605813.png"
width="1074"
height="821"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130605813_hu15260783431844737919.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109130605813_hu13965397915383728557.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>然后就是lsu到dcache,dcache又返回相应的数据到lsu,lsu再返回到core&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 214;
flex-basis: 514px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131001573.png" data-size="1037x484">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131001573.png"
width="1037"
height="484"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131001573_hu18066360943462275031.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131001573_hu11039348808397819913.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 280px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131048743.png" data-size="1001x856">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131048743.png"
width="1001"
height="856"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131048743_hu14824231925546166624.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131048743_hu3851967468262644325.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 157;
flex-basis: 376px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131127891.png" data-size="1173x747">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131127891.png"
width="1173"
height="747"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131127891_hu8784843170774739462.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131127891_hu10317076730263536326.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 433px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131256339.png" data-size="1269x702">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131256339.png"
width="1269"
height="702"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131256339_hu6307592418389489485.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131256339_hu18062049520677131996.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 239;
flex-basis: 574px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131326286.png" data-size="1460x610">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131326286.png"
width="1460"
height="610"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131326286_hu5337436626393385559.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109131326286_hu8028557597829778329.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>如果不是访存肯定就不走lsu那条路径&lt;/p>
&lt;p>下面就是unit完成执行之后给rob valid信号,rob应该会相应restore指令,然后给rename_stage commit的一些信息&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 206;
flex-basis: 495px"
>
&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109135135557.png" data-size="1401x679">
&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109135135557.png"
width="1401"
height="679"
srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109135135557_hu8439613037524709407.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241109135135557_hu14250129126697904379.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="file:////home/wzy/.config/QQ/nt_qq_95f270aa33a78f2188856503295283bb/nt_data/Pic/2024-11/Thumb/59a7d36b70a63511388f26b4bafaf34c_720.jpg" >
&lt;img src="file:////home/wzy/.config/QQ/nt_qq_95f270aa33a78f2188856503295283bb/nt_data/Pic/2024-11/Thumb/59a7d36b70a63511388f26b4bafaf34c_720.jpg"
loading="lazy"
alt="img">
&lt;/a>
&lt;figcaption>img&lt;/figcaption>
&lt;/figure>&lt;/p></description></item><item><title>Scalar_runahead_execution</title><link>https://VastCircle.github.io/2024/scalar_runahead_execution/</link><pubDate>Thu, 31 Oct 2024 20:13:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/scalar_runahead_execution/</guid><description>&lt;h3 id="introduction">introduction&lt;/h3>
&lt;p>(i) 一种适用于顺序执行核心的高性能、低开销的硬件预取技术，称为标量前推执行（𝑆𝑅𝐸）。𝑆𝑅𝐸在寄存器传输级有效预取复杂的内存访问模式，并实现了硬件优化策略，以尽量减少能量和面积的开销（如图1所示）。&lt;/p>
&lt;p>(ii) 为解决前推执行和缓存替换对有效预取的掩盖问题，我们引入了一种新的工作负载分析方法。该方法通过探索独特的工作负载特性，增强了前推技术在隐藏内存延迟方面的能力，从而缩短总执行时间。&lt;/p>
&lt;p>(iii) 利用自定义指令，我们提出了三种不同的模式，以解决前推技术的安全漏洞，并进一步提升性能。&lt;/p>
&lt;h3 id="background">background&lt;/h3>
&lt;p>A.标量核心中的长延迟内存访问&lt;/p>
&lt;p>顺序执行核心在面积和功耗方面相比乱序执行核心具有显著优势，使其本质上更适合需要长时间运行的场景。然而，在访问稀疏数据结构时，乱序核心可以通过诸如ROB（重排序缓冲区）、保留站、加载缓冲区和存储缓冲区等组件缓解由末级缓存未命中引起的内存访问延迟。相比之下，顺序执行核心缺乏应对内存延迟的有效策略，甚至L1缓存未命中也会显著影响性能。在严重情况下，执行时间的大部分都花费在等待内存上，导致顺序核心的平均每指令周期（CPI）可能达到数十。因此，解决内存延迟问题对于提升顺序执行核心的性能至关重要。&lt;/p>
&lt;p>B. runahead technique
然而，由于高开销，它们并不适合在顺序处理器上实现。以原始的runahead execute为例，当一条长延迟内存访问指令位于指令窗口的头部，导致指令窗口已满并阻塞流水线时，处理器会对架构寄存器文件和分支历史寄存器的状态进行检查点操作，促使处理器进入runahead mode。阻塞指令窗口的内存访问指令的目标寄存器将被标记为INV（无效），并在后续指令流中传播，以防止错误的内存请求。当内存请求返回时，处理器退出前推模式并恢复相关的架构状态。&lt;/p>
&lt;h3 id="overview">overview&lt;/h3>
&lt;p>目前处理器中的推测预取技术能够有效管理复杂的间接内存访问模式，但在微架构设计中带来了显著的硬件开销，使其不适用于小型核心。在周期精确的仿真器中实现这些技术会导致设计侵入性，并需开发专门的拦截电路。𝑆𝑅𝐸在寄存器传输级开发，通过一系列优化策略来减轻开销，从而确保在低成本的情况下实现高性能。&lt;strong>在runahead execute进入条件中集成了一种间接内存访问检测机制&lt;/strong>，提升了预取的准确性和覆盖范围。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 200;
flex-basis: 480px"
>
&lt;a href="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241031202810483.png" data-size="1296x648">
&lt;img src="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241031202810483.png"
width="1296"
height="648"
srcset="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241031202810483_hu7108600535510953162.png 480w, https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241031202810483_hu7882577258176118585.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在RCU中，为拦截正常执行模式下预取数据的回写，MSHR追踪每个&lt;strong>缓存未命中请求的详细信息，包括回写位置、请求地址和顺序&lt;/strong>。在寄存器文件中构建了拦截电路（图2a）。在寄存器文件中还建立了一个CP提取和回写电路，并包含多端口的CP（图2b），通过与级联控制电路集成，利用多个周期提取和回写处理器的状态信息。&lt;/p>
&lt;p>对于在runahead阶段的内存未命中请求以及瞬态执行(transient execution)期间识别的&lt;strong>无效内存未命中&lt;/strong>请求，会检测随后使用缺失数据的寄存器编号，并在scoreboard上重置相应位置（图2c）。开发了一个无效检测和传播机制，用于追踪负责流水线释放的寄存器编号和内存未命中地址，从而防止错误的预取请求。此外，构建了一个紧凑的dual-way cache，用于在runahead 阶段收集存储指令的存储值，确保内存指令的正确执行（图2d）。&lt;/p>
&lt;p>我们还开发了一个自定义ISA接口以增强灵活性，包括（图2e）：(i) Safe Mode，解决在前推推测执行期间因分支预测错误导致的机密数据泄漏风险；(ii) Miss Counter Table,，一个双入口表，用于自定义前推过程的终止点，以优化不同硬件和工作负载的性能；(iii) Aggressive Mode，提供禁用前推期间的FPU选项，防止在浮点运算密集型工作负载中长指令阻塞，并允许发出更多预取请求。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 124;
flex-basis: 297px"
>
&lt;a href="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241105214333838.png" data-size="1021x823">
&lt;img src="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241105214333838.png"
width="1021"
height="823"
srcset="https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241105214333838_hu3909055623410473370.png 480w, https://VastCircle.github.io/2024/scalar_runahead_execution/image-20241105214333838_hu5376785459573156400.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="微架构">微架构&lt;/h2>
&lt;p>选择了开源的Rocket Chip SoC作为𝑆𝑅𝐸微架构的基础。Rocket Chip包含一个低功耗的Rocket核心，支持开源的RV64GC RISC-V指令集，并使用Chisel硬件描述语言编写。它具备支持基于页面的虚拟内存的内存管理单元（MMU）、一个非阻塞数据缓存，以及带有分支预测功能的前端。&lt;/p>
&lt;p>A. The Runahead Control Unit
进入 pseudo-enter 阶段的条件通过处理来自L2缓存MSHR的未命中请求信息（回写位置）来确定。对于non-blocking cache的stall-on-use机制，在&lt;strong>解码&lt;/strong>阶段检测数据使用的时机，使处理器能够在该周期进入pseudo-enter阶段（图3a）。在pseudo-enter阶段，处理器检查是否存在&lt;strong>间接内存访问&lt;/strong>。如果检测到这种访问，处理器将转入runahead execution phase，通常持续十个周期（图3b）。在runahead execution phase，为了便于后续释放流水线并有效管理数据回写寄存器，必须跟踪来自L1缓存MSHR的Load-Miss和Gain-Miss信息，其中包括回写寄存器编号、请求地址和读/写指针等详细信息（图3c）。同时，为防止Load-Miss和Gain-Miss阻塞流水线，通过识别未命中回写寄存器编号来释放流水线并使对应的寄存器和地址无效（图3d）。在进入伪退出阶段时，目标是拦截与Gain-miss相关的数据回写。通过基于L1缓存MSHR中的请求回写寄存器编号、地址和读/写指针，精确拦截相同或不同块的回写请求来实现。此外，同一块内的Gain-miss会触发MSHR重放机制，可能会中断前推过程。拦截电路的扩展设计通过检测并拦截重复请求来解决此问题，以防止此类中断（图3f）。&lt;/p>
&lt;p>B. The Runahead Control FSM
为了实现对预取架构的精确控制，我们将有限状态机（FSM）机制与前推执行模式紧密集成，以增强处理器在处理长延迟内存访问时的效率。FSM通过在各状态间切换动态管理预取操作，确保处理器在内存延迟期间仍保持高效。FSM从伪进入状态开始，在该状态下，它处理来自L2缓存的未命中状态保持寄存器（MSHR）的未命中请求信息（回写位置）。此时，由于数据缓存的“stall on use”机制，处理器不仅不会完全停顿，还会继续执行指令。在这里，处理器检查流水线指令，识别出间接内存访问后，进入前推进入状态。此状态下处理器保存当前状态和寄存器，为后续从前推模式无缝恢复正常操作做好准备，以维护系统完整性（图3a）。完成前推进入状态的相关处理后，处理器直接进入前推执行状态。在前推执行状态下，处理器继续执行指令而不将结果提交至寄存器文件，通过在Load-Miss解决前预取数据来有效减少空闲时间。&lt;/p>
&lt;p>为实现此目的，FSM从L1缓存的MSHR中跟踪Load-Miss和Gain-Miss的详细信息，包括回写寄存器编号、请求地址和读/写指针。流水线被释放，对应的寄存器和地址被无效化，以防止阻塞。一旦Load-Miss数据返回，FSM便切换至前推通过状态，该状态作为中介，决定处理器应进入伪退出状态还是直接进入正常退出状态。FSM在两种情况下会进入伪退出状态：(i) 在数据回写前达到效益点，通过比较请求地址和读/写指针；或(ii) Gain-Miss计数器在数据回写后达到指定值，表明已达到效益点。在伪退出状态，FSM通过准确检测相同和不同块的重复请求来拦截与Gain-Miss相关的回写请求。此拦截机制防止了因相同块中的Gain-Miss触发重放机制而中断前推过程。FSM随后完成操作，确保所有前推执行的指令已完成或安全丢弃。&lt;/p>
&lt;p>如果前推过程中没有未解决的依赖关系，FSM将进入前推退出状态，允许处理器恢复正常处理。然而，若前推执行期间存在无法解决的依赖关系或执行异常，FSM可能会暂时切换至前推无效状态，并通过控制流水线停顿、等待Load-Miss正常返回后再退出前推模式。&lt;/p>
&lt;p>C. 多周期检查点和释放电路&lt;/p>
&lt;p>处理器状态的checkpoint and restore，包括 GHR（全局历史寄存器）、RAS（返回地址堆栈）和架构寄存器文件，对于确保超前运行中的正确操作至关重要。模式和普通模式。 GHR 和 RAS 处理分支历史记录和返回地址跟踪。当处理器进入超前运行模式时，这些结构在单个周期内设置检查点，保留分支预测和返回地址计算所需的信息。退出超前运行模式后，先前保存的分支历史记录和返回地址将被恢复，从而保持准确的控制流，而不会增加显着的性能开销。相比之下，存储处理器架构状态的架构寄存器文件涉及更多数据和复杂性。为了管理这一点，使用了多周期检查点和释放机制，这减少了对扩展模块接口的需求并降低了处理器之间的通信压力。尽管对架构寄存器文件进行检查点需要多个周期，但它与在超前运行模式和正常模式之间转换时清除和重新填充管道所需的五个周期过程相一致，从而避免了任何额外的性能损失。&lt;/p>
&lt;p>D. 预取管理单元
我们设计了预取管理单元（PMU）以检测和拦截错误的预取请求，从而使推测执行能够有效处理内存访问指令。PMU由两个主要结构组成：无效集合单元（ISU），用于拦截错误的预取地址，以及前推缓存（RC），用于在前推过程中存储存储指令的值。&lt;/p>
&lt;p>&lt;strong>ISU（无效集合单元）&lt;/strong>：Invfile用于存储无效寄存器编号和地址信息，类似于记分板。每个寄存器编号或前推缓存条目都有一个指示其有效性的位（图4 a）。Load-miss和Gain-miss的写回寄存器编号以及在前推过程中存储的无效地址，通常是Invfile的来源，相关机制检测到时，Invfile被激活。我们将来自执行阶段的RS与内存请求地址进行比较，并与Invfile中的相应位进行比对，产生三种情况（图4 b）：&lt;/p>
&lt;ol>
&lt;li>当源寄存器编号存在于Invfile中时，启动无效传播机制，设置相应的目标寄存器编号。&lt;/li>
&lt;li>如果加载指令的地址有效或所有源寄存器有效，则触发无效重置机制，重置相应寄存器编号的无效位。&lt;/li>
&lt;li>如果发现存储地址有效，则激活无效重置机制，重置相应地址位。&lt;/li>
&lt;/ol>
&lt;p>基于这些操作的结果，无效寄存器信号转变为内存访问阻塞信号和在写回阶段对处理器的流水线释放信号。无效地址信号被转发到前推缓存模块，以确定加载块是否有效命中前推缓存。&lt;/p>
&lt;p>&lt;strong>RC（前推缓存）&lt;/strong>：前推缓存被设计为紧凑的二路关联存储结构，每个条目包含标签和数据信息，每个数据条目的大小为两个字（具体为16B）（图4 c）。在前推过程中，加载地址同时访问该缓存和L1缓存。它根据内存访问地址的索引信息选择行，匹配适当的集合，然后根据偏移信息选择字节，最后根据方式命中检索匹配的数据。命中机制涉及将内存访问地址的标签信息与前推缓存的标签信息进行比较。如果匹配，则进一步验证数据的有效性。如果有效，则生成命中信号，并用作数据选择的控制信号（图4 d）。在退出前推时，前推缓存中的所有值都被置为无效，以防止访问过时的值，直到新的前推过程重置存储的地址。对于数据替换机制，我们采用伪LRU替换策略选择最不常用的方式进行替换。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>处理器成功运行的标志</title><link>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</link><pubDate>Thu, 31 Oct 2024 13:11:58 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</guid><description>&lt;h2 id="处理器运行">处理器运行&lt;/h2>
&lt;p>总共的过程应该是在exit之后,处理器(core0)会循环执行下面的代码,主要是要向0x80001ec0写入数据1,会写入到dcache那边&lt;/p>
&lt;p>而serdesser会去l2读取0x80001ec0的数据,中间通过fbus,sbus到l2,如果读取到数据为1的话,就会相应的去发送相关exit信号&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 279;
flex-basis: 670px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094843063.png" data-size="802x287">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094843063.png"
width="802"
height="287"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094843063_hu10834925242811752114.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094843063_hu15820108949805341374.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于fbus_serdesser那边什么时候发送的a_valid ,粗略的看了一下是它和SerialRAM里的serdesser有相互依赖的关系,最后估计会追溯到c代码那边去,从波形图看的话,发送是较为规律的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 366;
flex-basis: 878px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112101917914.png" data-size="1380x377">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112101917914.png"
width="1380"
height="377"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112101917914_hu11155479995035520656.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112101917914_hu15662451549408405609.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="路径">路径&lt;/h2>
&lt;h5 id="tileprcidomain-tile_prici_domain-digitaltopsv">TilePRCIDomain tile_prici_domain DigitalTop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 248;
flex-basis: 595px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095854692.png" data-size="1176x474">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095854692.png"
width="1176"
height="474"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095854692_hu14349239179337440927.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095854692_hu3909130621525587775.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="systembus-subsystem_sbus-digitaltopsv">SystemBus subsystem_sbus DigitalTop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 360;
flex-basis: 865px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095656683.png" data-size="1424x395">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095656683.png"
width="1424"
height="395"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095656683_hu4604888188722323693.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095656683_hu16983584808876366820.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 339;
flex-basis: 815px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095407141.png" data-size="1608x473">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095407141.png"
width="1608"
height="473"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095407141_hu17372420628291058920.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112095407141_hu8216488962024402803.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="coherencemanagerwrapper-subsystem_l2_wrapper-digitaltopsv">CoherenceManagerWrapper subsystem_l2_wrapper DigitalTop.sv&lt;/h5>
&lt;p>已经从l2读取数据&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 417;
flex-basis: 1001px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094514289.png" data-size="1594x382">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094514289.png"
width="1594"
height="382"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094514289_hu6759119080851267310.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112094514289_hu6581819576431925325.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 254;
flex-basis: 611px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005435034.png" data-size="1434x563">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005435034.png"
width="1434"
height="563"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005435034_hu3657893311516738575.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005435034_hu17225638964003990272.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="systembus-subsystem_sbus-digitaltopsv-1">SystemBus subsystem_sbus DigitalTop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 359;
flex-basis: 863px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005336223.png" data-size="1453x404">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005336223.png"
width="1453"
height="404"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005336223_hu5300597055102052288.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112005336223_hu10407911388166034952.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 355;
flex-basis: 854px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004328753.png" data-size="1644x462">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004328753.png"
width="1644"
height="462"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004328753_hu9126771300717696823.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004328753_hu8868113206527878079.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="tlbuffer_2-subsystem_fbus_buffer-digitaltopsv">TLBuffer_2 subsystem_fbus_buffer Digitaltop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 290;
flex-basis: 696px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004109412.png" data-size="1479x510">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004109412.png"
width="1479"
height="510"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004109412_hu4526944589407405904.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112004109412_hu16418225234376789943.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 149;
flex-basis: 357px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003733355.png" data-size="1100x738">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003733355.png"
width="1100"
height="738"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003733355_hu11001060511033817350.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003733355_hu2657521878439941150.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="tlinterconnectcoupler_16-subsystem_fbus_coupler_from_port_named_serial_tl_ctrl-digitaltopsv">TLInterconnectCoupler_16 subsystem_fbus_coupler_from_port_named_serial_tl_ctrl Digitaltop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 283;
flex-basis: 680px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003617281.png" data-size="1344x474">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003617281.png"
width="1344"
height="474"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003617281_hu16922644344907968853.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112003617281_hu17719202674284953709.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 203;
flex-basis: 487px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002846883.png" data-size="1553x764">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002846883.png"
width="1553"
height="764"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002846883_hu14592278883094086627.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002846883_hu4833152105054023305.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="tlserdesser-subsystem_fbus_serdesser-digitaltopsv">TLSerdesser subsystem_fbus_serdesser Digitaltop.sv&lt;/h5>
&lt;p>serdesser应该在定时发送请求&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 363;
flex-basis: 872px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002506790.png" data-size="1635x450">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002506790.png"
width="1635"
height="450"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002506790_hu12038551549462248417.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002506790_hu443204763364450633.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 563;
flex-basis: 1351px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002039647.png" data-size="1408x250">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002039647.png"
width="1408"
height="250"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002039647_hu8643445582540208317.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112002039647_hu11892537281396842399.png 1024w"
loading="lazy"
alt="image-20241112002039647">
&lt;/a>
&lt;figcaption>image-20241112002039647&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="asyncqueue-subsystem_fbus_out_async--digitaltopsv">AsyncQueue subsystem_fbus_out_async Digitaltop.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 381;
flex-basis: 914px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001843957.png" data-size="1441x378">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001843957.png"
width="1441"
height="378"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001843957_hu8581469363293127232.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001843957_hu9406776523032479155.png 1024w"
loading="lazy"
alt="image-20241112001843957">
&lt;/a>
&lt;figcaption>image-20241112001843957&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="digitaltop-system-chiptopsv">DigitalTop system ChipTop.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 597;
flex-basis: 1434px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001700816.png" data-size="1452x243">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001700816.png"
width="1452"
height="243"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001700816_hu13870121274252969278.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001700816_hu10613041319749448004.png 1024w"
loading="lazy"
alt="image-20241112001700816">
&lt;/a>
&lt;figcaption>image-20241112001700816&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="chiptop-chiptop0-testharnesssv">ChipTop chiptop0 TestHarness.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 265;
flex-basis: 636px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001324352.png" data-size="1121x423">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001324352.png"
width="1121"
height="423"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001324352_hu9204217543704736704.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241112001324352_hu124251101865932250.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="serialram-ram-testharnesssv">SerialRAM ram TestHarness.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 223;
flex-basis: 536px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111235459860.png" data-size="1020x456">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111235459860.png"
width="1020"
height="456"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111235459860_hu301635820281566860.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111235459860_hu7170903320587178141.png 1024w"
loading="lazy"
alt="image-20241111235459860">
&lt;/a>
&lt;figcaption>image-20241111235459860&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 223;
flex-basis: 537px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111234654487.png" data-size="732x327">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111234654487.png"
width="732"
height="327"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111234654487_hu3335290317010757017.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241111234654487_hu11996125452438590909.png 1024w"
loading="lazy"
alt="image-20241111234654487">
&lt;/a>
&lt;figcaption>image-20241111234654487&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="simtsi-success_exit_sim-testharnesssv">SimTSI success_exit_sim TestHarness.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 238;
flex-basis: 573px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031135417464.png" data-size="803x336">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031135417464.png"
width="803"
height="336"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031135417464_hu13613305115897699263.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031135417464_hu11887304916702126665.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-verilog" data-lang="verilog">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">input&lt;/span> &lt;span style="color:#e06c75">clock&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">input&lt;/span> &lt;span style="color:#e06c75">reset&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">input&lt;/span> &lt;span style="color:#e06c75">tsi_out_valid&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">output&lt;/span> &lt;span style="color:#e06c75">tsi_out_ready&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">input&lt;/span> [&lt;span style="color:#d19a66">31&lt;/span>&lt;span style="color:#56b6c2">:&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>] &lt;span style="color:#e06c75">tsi_out_bits&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">output&lt;/span> &lt;span style="color:#e06c75">tsi_in_valid&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">input&lt;/span> &lt;span style="color:#e06c75">tsi_in_ready&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">output&lt;/span> [&lt;span style="color:#d19a66">31&lt;/span>&lt;span style="color:#56b6c2">:&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>] &lt;span style="color:#e06c75">tsi_in_bits&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">output&lt;/span> [&lt;span style="color:#d19a66">31&lt;/span>&lt;span style="color:#56b6c2">:&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>] &lt;span style="color:#e06c75">exit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 115;
flex-basis: 276px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031132938852.png" data-size="801x696">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031132938852.png"
width="801"
height="696"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031132938852_hu1086351026104805095.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031132938852_hu16573299286926149045.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 108;
flex-basis: 260px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031142422181.png" data-size="810x747">
&lt;img src="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031142422181.png"
width="810"
height="747"
srcset="https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031142422181_hu9005692429509185126.png 480w, https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/image-20241031142422181_hu2502667652843423368.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p></description></item><item><title>Big_soc_路径查找</title><link>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 30 Oct 2024 16:25:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="路径查找">路径查找&lt;/h2>
&lt;h3 id="bootrom-clocksinkdomain_1sv">Bootrom ClockSinkDomain_1.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 158;
flex-basis: 381px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png" data-size="567x357">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png"
width="567"
height="357"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu13999121753685267221.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu10622608143385405980.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="clocksinkdomain_1-bootromdomainwrapper-digitaltopsv">ClockSinkDomain_1 bootROMDomainWrapper DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 265;
flex-basis: 638px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164741290.png" data-size="907x341">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164741290.png"
width="907"
height="341"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164741290_hu102353570205705049.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164741290_hu2590073761771574827.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="peripherybus_1-subsystem_cbus--digitaltopsv">PeripheryBus_1 subsystem_cbus DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 306;
flex-basis: 735px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030165640444.png" data-size="923x301">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030165640444.png"
width="923"
height="301"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030165640444_hu10383002120596061510.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030165640444_hu18402210719830523042.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlinterconnectcoupler_33-coupler_to_bootrom-tlinterconnectcoupler_33sv">TLInterconnectCoupler_33 coupler_to_bootrom TLInterconnectCoupler_33.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 133;
flex-basis: 321px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031010752745.png" data-size="870x650">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031010752745.png"
width="870"
height="650"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031010752745_hu3992272573636306381.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031010752745_hu9979219063896286076.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlxbar_5-out_xbar--peripherybus_1sv">TLXbar_5 out_xbar PeripheryBus_1.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 166;
flex-basis: 398px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030185219084.png" data-size="793x477">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030185219084.png"
width="793"
height="477"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030185219084_hu10448680742370513107.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030185219084_hu17420875698955200549.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 181;
flex-basis: 435px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202332950.png" data-size="713x393">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202332950.png"
width="713"
height="393"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202332950_hu9250519818328254813.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202332950_hu8645570273136880355.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlfifofixer_2-fixer-peripherybus_1sv">TLFIFOFixer_2 fixer PeripheryBus_1.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 152;
flex-basis: 365px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202242426.png" data-size="776x510">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202242426.png"
width="776"
height="510"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202242426_hu1671350503351295985.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202242426_hu2891245334902017403.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 110;
flex-basis: 265px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202200430.png" data-size="679x613">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202200430.png"
width="679"
height="613"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202200430_hu4279736998364245208.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202200430_hu6367668441550391184.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlbuffer_4-buffer-peripherybus_1sv">TLBuffer_4 buffer PeripheryBus_1.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 117;
flex-basis: 281px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202115325.png" data-size="703x599">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202115325.png"
width="703"
height="599"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202115325_hu2093073729786551643.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104202115325_hu9788218670477972827.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 312px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201933229.png" data-size="681x523">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201933229.png"
width="681"
height="523"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201933229_hu14151955852051181800.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201933229_hu10350937311788669531.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlatomicautomata_1-atomics-peripherybus_1sv">TLAtomicAutomata_1 atomics PeripheryBus_1.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 139;
flex-basis: 333px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201838520.png" data-size="740x532">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201838520.png"
width="740"
height="532"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201838520_hu15474228921633105648.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201838520_hu18177123055238767923.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 121;
flex-basis: 291px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201741377.png" data-size="715x589">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201741377.png"
width="715"
height="589"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201741377_hu12807145140930188950.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201741377_hu16454610261658107867.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlxbar_4-in_xbar-peripherybus_1sv">TLXbar_4 in_xbar PeripheryBus_1.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 471px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201652036.png" data-size="721x367">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201652036.png"
width="721"
height="367"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201652036_hu15463308738735522326.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201652036_hu11076147321959160063.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 128;
flex-basis: 308px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201454888.png" data-size="760x591">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201454888.png"
width="760"
height="591"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201454888_hu1648661250605773999.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104201454888_hu9220552418403513128.png 1024w"
loading="lazy"
alt="image-20241104201454888">
&lt;/a>
&lt;figcaption>image-20241104201454888&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="peripyherybus_1-subsystem_cbus-digitaltopsv">PeripyheryBus_1 subsystem_cbus DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 247;
flex-basis: 594px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200308864.png" data-size="1196x483">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200308864.png"
width="1196"
height="483"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200308864_hu2987058579385441560.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200308864_hu8238927459530301682.png 1024w"
loading="lazy"
alt="image-20241104200308864">
&lt;/a>
&lt;figcaption>image-20241104200308864&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="systembus-subsystem_sbus-digitaltopsv">SystemBus subsystem_sbus DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 390;
flex-basis: 937px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200104409.png" data-size="1051x269">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200104409.png"
width="1051"
height="269"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200104409_hu3587345545705323987.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104200104409_hu7002349993959100018.png 1024w"
loading="lazy"
alt="image-20241104200104409">
&lt;/a>
&lt;figcaption>image-20241104200104409&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="tlinterconnectcoupler-aoupler_to_bus_named_subsystem_cbus-systembussv">TLInterconnectCoupler aoupler_to_bus_named_subsystem_cbus SystemBus.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 124;
flex-basis: 299px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104203908777.png" data-size="957x768">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104203908777.png"
width="957"
height="768"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104203908777_hu6125513517208744189.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104203908777_hu17150586439581193941.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlxbar-system_bus_xbar-systembussv">TLXbar system_bus_xbar SystemBus.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 472px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204100508.png" data-size="850x432">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204100508.png"
width="850"
height="432"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204100508_hu4689703313920921600.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204100508_hu3866374991973846319.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 157;
flex-basis: 377px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204343965.png" data-size="885x562">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204343965.png"
width="885"
height="562"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204343965_hu5442870221149858326.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204343965_hu15635827722560487754.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlfifofixer-fixer-systembussv">TLFIFOFixer fixer SystemBus.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 209;
flex-basis: 503px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204454714.png" data-size="898x428">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204454714.png"
width="898"
height="428"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204454714_hu17321549004515328782.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204454714_hu3268317837269684717.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 269;
flex-basis: 647px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204645357.png" data-size="1111x412">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204645357.png"
width="1111"
height="412"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204645357_hu14169484330165946716.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104204645357_hu1129588965761359889.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="systembus-subsystem_sbus-digitaltopsv-1">SystemBus subsystem_sbus DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 338;
flex-basis: 812px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205256635.png" data-size="1138x336">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205256635.png"
width="1138"
height="336"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205256635_hu7523165942051679694.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205256635_hu15364917323929948535.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="tileprcidomain-tile_prci_domain-digitaltopsv">TilePRCIDomain tile_prci_domain DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 318;
flex-basis: 763px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205613883.png" data-size="1168x367">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205613883.png"
width="1168"
height="367"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205613883_hu5550151832250196451.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205613883_hu16612706730424766286.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlbuffer_15-buffer-tileprcidomainsv">TLBuffer_15 buffer TilePRCIDomain.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 154;
flex-basis: 370px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205853472.png" data-size="770x499">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205853472.png"
width="770"
height="499"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205853472_hu264810291881296659.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205853472_hu13279160373168244277.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 173;
flex-basis: 416px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205948237.png" data-size="668x385">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205948237.png"
width="668"
height="385"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205948237_hu18143089294266212219.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104205948237_hu3551002334042921988.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="toomtile-tile_reset_domain_boom_tile-tileprcidomainsv">ToomTile tile_reset_domain_boom_tile TilePRCIDomain.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 129;
flex-basis: 310px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104210127393.png" data-size="716x554">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104210127393.png"
width="716"
height="554"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104210127393_hu18425995802566615571.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104210127393_hu3630265501328523238.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h5 id="tlxbar_8-tlmasterxbar-boomtilesv">TLXbar_8 tlMasterXbar BoomTile.sv&lt;/h5>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 169;
flex-basis: 406px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104214423660.png" data-size="725x428">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104214423660.png"
width="725"
height="428"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104214423660_hu6573180292948110858.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104214423660_hu2808990919005740674.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 96;
flex-basis: 230px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104215304702.png" data-size="681x708">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104215304702.png"
width="681"
height="708"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104215304702_hu285788930342095181.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241104215304702_hu11573631366708722688.png 1024w"
loading="lazy"
alt="image-20241104215304702">
&lt;/a>
&lt;figcaption>image-20241104215304702&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 176;
flex-basis: 422px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241105144018651.png" data-size="1394x792">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241105144018651.png"
width="1394"
height="792"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241105144018651_hu16716922515995658433.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241105144018651_hu12977846780869885404.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;hr>
&lt;hr>
&lt;p>后面可以不看了&lt;/p>
&lt;h3 id="coherencemanagerwrapper-subsystem_l2_wrapper-digitaltopsv">CoherenceManagerWrapper subsystem_l2_wrapper DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 174;
flex-basis: 419px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031013341985.png" data-size="1192x682">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031013341985.png"
width="1192"
height="682"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031013341985_hu4239901299354339721.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031013341985_hu17551902722383602852.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="inclusivecache-l2--coherencemanagerwrappersv">InclusiveCache l2 CoherenceManagerWrapper.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 117;
flex-basis: 283px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031112634641.png" data-size="717x608">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031112634641.png"
width="717"
height="608"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031112634641_hu2709144765505328249.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031112634641_hu17114887769523885667.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 95;
flex-basis: 229px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113153384.png" data-size="746x780">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113153384.png"
width="746"
height="780"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113153384_hu10994807932654197116.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113153384_hu9974981150287781469.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="tlcachecork-cork--coherencemanagerwrappersv">TLCacheCork cork &lt;strong>CoherenceManagerWrapper.sv&lt;/strong>&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 101;
flex-basis: 244px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113807118.png" data-size="816x802">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113807118.png"
width="816"
height="802"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113807118_hu9076489822654885813.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113807118_hu17825230885535812463.png 1024w"
loading="lazy"
alt="image-20241031113807118">
&lt;/a>
&lt;figcaption>image-20241031113807118&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 131;
flex-basis: 315px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113912098.png" data-size="795x604">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113912098.png"
width="795"
height="604"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113912098_hu13582625459371530707.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113912098_hu14921006148919335977.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="bankbinder-binder-coherencemanagerwrappersv">BankBinder binder CoherenceManagerWrapper.sv&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 106;
flex-basis: 254px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113951757.png" data-size="835x787">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113951757.png"
width="835"
height="787"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113951757_hu4867654425878897104.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031113951757_hu416188532021133310.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="coherencemanagerwrapper-subsystem_l2_wrapper--digitaltopsv">CoherenceManagerWrapper subsystem_l2_wrapper DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 192;
flex-basis: 463px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095210458.png" data-size="1258x652">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095210458.png"
width="1258"
height="652"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095210458_hu1991859796095460662.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095210458_hu12504717475907084572.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="memorybus-subsystem_mbus-digitaltopsv">memorybus subsystem_mbus DigitalTop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 223;
flex-basis: 536px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095313158.png" data-size="1290x577">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095313158.png"
width="1290"
height="577"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095313158_hu10547067537806860942.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241031095313158_hu8519425387056163879.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 129;
flex-basis: 310px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204624185.png" data-size="721x558">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204624185.png"
width="721"
height="558"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204624185_hu4951593277296956299.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204624185_hu17132605656731841606.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="digitaltop-system-chiptopsv">DigitalTop system chiptop.sv&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 353;
flex-basis: 849px"
>
&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204011379.png" data-size="1012x286">
&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204011379.png"
width="1012"
height="286"
srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204011379_hu8900226278681400073.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030204011379_hu973512857469762760.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="dram">Dram&lt;/h3>
&lt;p>略&lt;/p></description></item><item><title>Chipyard的三个highest_level</title><link>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</link><pubDate>Tue, 29 Oct 2024 21:56:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</guid><description>&lt;p>Chipyard SoC 中三个最高层次是&lt;code>ChipTop&lt;/code>(DUT)、&lt;code>TestHarness&lt;/code>和&lt;code>TestDriver&lt;/code>。&lt;code>ChipTop&lt;/code>和&lt;code>TestHarness&lt;/code>均由 Chisel 生成器发出。&lt;code>TestDriver&lt;/code>用作我们的测试平台，是 Rocket Chip 中的 Verilog 文件。&lt;/p>
&lt;h2 id="chiptopdut">ChipTop(DUT)&lt;/h2>
&lt;p>ChipTop 是顶层模块，负责实例化 System 子模块，通常是 DigitalTop 的具体实例。设计的大部分内容位于 System 中。ChipTop 层中存在的其他组件通常是 IO 单元、时钟接收器和多路复用器、重置同步器以及其他需要存在于 System 之外的模拟 IP。IOBinders 负责实例化与 System 的 IO 相对应的 ChipTop IO 的 IO 单元。HarnessBinders 负责实例化测试夹具，以连接到 ChipTop 端口。大多数类型的设备和测试夹具都可以使用自定义的 IOBinders 和 HarnessBinders 进行实例化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-verilog" data-lang="verilog">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">DigitalTop&lt;/span> &lt;span style="color:#e06c75">system&lt;/span> ( &lt;span style="color:#7f848e">// @[ChipTop.scala:28:35]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> .&lt;span style="color:#e06c75">clock&lt;/span> (&lt;span style="color:#e06c75">_system_auto_implicitClockGrouper_out_clock&lt;/span>), &lt;span style="color:#7f848e">// @[ChipTop.scala:28:35]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> .&lt;span style="color:#e06c75">reset&lt;/span> (&lt;span style="color:#e06c75">_system_auto_implicitClockGrouper_out_reset&lt;/span>), &lt;span style="color:#7f848e">// @[ChipTop.scala:28:35]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> .&lt;span style="color:#e06c75">auto_prci_ctrl_domain_reset_setter_clock_in_member_allClocks_uncore_clock&lt;/span> (&lt;span style="color:#e06c75">clock_uncore_clock&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#e06c75">auto_prci_ctrl_domain_reset_setter_clock_in_member_allClocks_uncore_reset&lt;/span> (&lt;span style="color:#e06c75">reset_io&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#e06c75">resetctrl_hartIsInReset_0&lt;/span> (&lt;span style="color:#e06c75">_system_auto_subsystem_cbus_fixedClockNode_out_reset&lt;/span>), &lt;span style="color:#7f848e">// @[ChipTop.scala:28:35]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> .&lt;span style="color:#e06c75">resetctrl_hartIsInReset_1&lt;/span> (&lt;span style="color:#e06c75">_system_auto_subsystem_cbus_fixedClockNode_out_reset&lt;/span>), &lt;span style="color:#7f848e">// @[ChipTop.scala:28:35]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#56b6c2">---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="自定义-chiptop">自定义 ChipTop&lt;/h2>
&lt;p>默认的标准 ChipTop 提供了一个最小的、基本的模板，以便 IOBinders 在 DigitalTop 特性周围生成 IO 单元。对于 tapeout、集成模拟 IP 或其他非标准用例，Chipyard 支持使用 BuildTop 键指定自定义 ChipTop。一个使用非标准 IO 单元的自定义 ChipTop 示例位于 &lt;code>generators/chipyard/src/main/scala/example/CustomChipTop.scala&lt;/code>。&lt;/p>
&lt;p>您还可以指定一个完全自定义的 ChipTop，该 ChipTop 不使用任何 RocketChip 或 Chipyard SoC 组件。示例位于 &lt;code>generators/chipyard/src/main/scala/example/EmptyChipTop.scala&lt;/code>。可以使用以下命令构建 EmptyChipTop 示例：&lt;code>make CONFIG=EmptyChipTopConfig TOP=EmptyChipTop&lt;/code>。&lt;/p>
&lt;h2 id="systemdigitaltop">System/DigitalTop&lt;/h2>
&lt;p>Rocket Chip SoC 的系统模块是通过 cake-pattern 组合而成的。具体而言，DigitalTop 扩展了 System，System 扩展了 Subsystem，Subsystem 又扩展了 BaseSubsystem。&lt;/p>
&lt;h3 id="basesubsystem">BaseSubsystem&lt;/h3>
&lt;p>BaseSubsystem 在 &lt;code>generators/rocketchip/src/main/scala/subsystem/BaseSubsystem.scala&lt;/code> 中定义。查看 BaseSubsystem 抽象类，我们看到该类实例化了顶层总线（frontbus、systembus、peripherybus 等），但没有指定拓扑结构。该类还定义了多个 ElaborationArtefacts，这些文件是在 Chisel 细化后生成的（例如，设备树字符串和外交图可视化 GraphML 文件）。&lt;/p>
&lt;h3 id="subsystem">Subsystem&lt;/h3>
&lt;p>在 &lt;code>generators/chipyard/src/main/scala/Subsystem.scala&lt;/code> 中，我们可以看到 Chipyard 的 Subsystem 是如何扩展 BaseSubsystem 抽象类的。Subsystem 混入了 HasBoomAndRocketTiles 特性，该特性根据指定的参数定义并实例化 BOOM 或 Rocket 瓦片。我们在这里为每个瓦片连接一些基本的 IO，特别是 hartids 和复位向量。&lt;/p>
&lt;h3 id="system">System&lt;/h3>
&lt;p>&lt;code>generators/chipyard/src/main/scala/System.scala&lt;/code> 完成了 System 的定义。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HasHierarchicalBusTopology&lt;/strong> 在 Rocket Chip 中定义，指定顶层总线之间的连接。&lt;/li>
&lt;li>&lt;strong>HasAsyncExtInterrupts&lt;/strong> 和 &lt;strong>HasExtInterruptsModuleImp&lt;/strong> 添加外部中断的 IO，并将其适当地连接到瓦片。&lt;/li>
&lt;li>&lt;strong>CanHave&amp;hellip;AXI4Port&lt;/strong> 添加各种主从 AXI4 端口，添加 TL-to-AXI4 转换器，并将其连接到适当的总线。&lt;/li>
&lt;li>&lt;strong>HasPeripheryBootROM&lt;/strong> 添加 BootROM 设备。&lt;/li>
&lt;/ul>
&lt;h2 id="tops">Tops&lt;/h2>
&lt;p>SoC Top 继承 System 类，并包含自定义组件的特性。在 Chipyard 中，这包括添加 NIC、UART 和 GPIO，以及为引导方法设置硬件。&lt;/p>
&lt;h2 id="testharness">TestHarness&lt;/h2>
&lt;p>TestHarness 与 Top 之间的连接是在添加到 Top 的特性中定义的方法中执行的。当这些方法从 TestHarness 中调用时，它们可以在scope of the harness内实例化模块，然后将其连接到 DUT。例如，从 CanHaveMasterAXI4MemPortModuleImp 特性定义的 &lt;code>connectSimAXIMem&lt;/code> 方法，在 TestHarness 中调用时，会实例化 SimAXIMems，并将其连接到顶层的正确 IO。&lt;/p>
&lt;p>尽管这种间接方式连接顶层 IO 可能看起来不必要地复杂，但它允许设计师组合自定义特性，而无需担心任何特定特性的实现细节。&lt;/p>
&lt;h2 id="testdriver">TestDriver&lt;/h2>
&lt;p>TestDriver 在 &lt;code>generators/rocketchip/src/main/resources/vsrc/TestDriver.v&lt;/code> 中定义。该 Verilog 文件通过实例化 TestHarness、驱动时钟和复位信号以及解释成功输出来执行仿真。该文件与为 TestHarness 和 Top 生成的 Verilog 一起编译，以生成仿真器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-verilog" data-lang="verilog">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">`MODEL&lt;/span> &lt;span style="color:#e06c75">testHarness&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#e06c75">clock&lt;/span>(&lt;span style="color:#e06c75">clock&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#e06c75">reset&lt;/span>(&lt;span style="color:#e06c75">reset&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#e06c75">io_success&lt;/span>(&lt;span style="color:#e06c75">success&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>TestDriver就是完全的仿真文件&lt;/p>
&lt;p>TestHarness 中包含simdram等仿真组件&lt;/p>
&lt;p>ChipTop 是顶层模块，负责实例化 System 子模块，通常是 DigitalTop 的具体实例&lt;/p>
&lt;p>整个system就是一个soc,包含core和外设&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 174;
flex-basis: 419px"
>
&lt;a href="https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/image-20241105165859293.png" data-size="1533x878">
&lt;img src="https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/image-20241105165859293.png"
width="1533"
height="878"
srcset="https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/image-20241105165859293_hu3616408519887204638.png 480w, https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/image-20241105165859293_hu8294092583105720998.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/ucb-bar/chipyard/blob/main/docs/Advanced-Concepts/Top-Testharness.rst" target="_blank" rel="noopener"
>Tops,Test-Harnesses,and the Test-Driver&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Rocket Chip学习</title><link>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 29 Oct 2024 17:12:22 +0800</pubDate><guid>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h2 id="rocket-chip-框图">rocket-chip 框图&lt;/h2>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 93;
flex-basis: 224px"
>
&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png" data-size="685x733">
&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png"
width="685"
height="733"
srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu14119112562339422234.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu6804879921133493359.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 384px"
>
&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/1b76004cd81da403ee6061bc5f28c8a4.png" data-size="920x574">
&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/1b76004cd81da403ee6061bc5f28c8a4.png"
width="920"
height="574"
srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/1b76004cd81da403ee6061bc5f28c8a4_hu10081888447368840699.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/1b76004cd81da403ee6061bc5f28c8a4_hu7103377815266656506.png 1024w"
loading="lazy"
alt="rocket-chip流水线">
&lt;/a>
&lt;figcaption>rocket-chip流水线&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 151;
flex-basis: 362px"
>
&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/606757a6f155fc39d830d2669766510d.png" data-size="812x537">
&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/606757a6f155fc39d830d2669766510d.png"
width="812"
height="537"
srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/606757a6f155fc39d830d2669766510d_hu2470859002471598808.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/606757a6f155fc39d830d2669766510d_hu17716410241867253808.png 1024w"
loading="lazy"
alt="rocket-chip Icache">
&lt;/a>
&lt;figcaption>rocket-chip Icache&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 140;
flex-basis: 337px"
>
&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/d5b43f3a013f1952dcc43774d22b5d37.png" data-size="1042x742">
&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/d5b43f3a013f1952dcc43774d22b5d37.png"
width="1042"
height="742"
srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/d5b43f3a013f1952dcc43774d22b5d37_hu12111035731917621890.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/d5b43f3a013f1952dcc43774d22b5d37_hu6353591107662034634.png 1024w"
loading="lazy"
alt="rocket-chip Dcache">
&lt;/a>
&lt;figcaption>rocket-chip Dcache&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="rocket-chip-代码结构">rocket-chip 代码结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## rocket-chip generator的一级目录结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　bootrom : 在BootROM的bootloader第一阶段所使用的代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csrc Verilator: 仿真用的C代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　emulator Verilator :用来编译和跑仿真的工作目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　project Scala: 构建工具sbt用来构建Scala的工作目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　regression: 定义的持续的整合和一套nightly regression
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　scripts: 用来分析仿真的输出或者处理代码文件的内容
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　vsim VCS: 用来编译和跑仿真的工作目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　vsrc Verilog: 代码，包含接口、测试框架和Verilog过程接口VPI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　chisel3 :包含Chisel自定义的各种类和规则，用来生成RTL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　firrtl: 存放Chisel编译器处理代码而生成的一种中间表示，由中间表示能生成Verilog代码或C++代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　hardfloat: 用chisel写成的浮点单元
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　riscv-tools: 支持RISC-V的一套软件，与生成RTL有关
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　torture: 用来生成压力测试所需的一些随机指令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## src/main/scala: 构筑rocket-chip的代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amba: 协议的实现代码，包括AXI4，AHB-lite，APB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config: 提供能配置Generator的Scala的接口
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　coreplex: 包含Rocket核、系统总线、coherence agents、debug设备、中断处理、面向外部的外设、时钟同步处理和TileLink到外设总线转换
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　devices: 一些外设，包括debug模块和各种挂在TileLink的从设备
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　diplomacy: 用来扩展Chisel，通过允许对硬件进行两个阶段的阐述，可以让参数在模块之间协调传递
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　groundtest: 生成可综合的硬件测试平台，通过发出随机的访问存储器指令流，进行对核外的存储器系统进行压力测试
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　jtag: 用来生成JTAG总线接口
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　regmapper: 用来生成带有能访问内存映射寄存器的标准接口的从设备
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　rocket: 用来生成顺序核Rocket、L1指令cache和L1数据cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　tile: 包含可以与Rocket核组成tile的组件，如FPU和RoCC协处理器
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　tilelink: 用来生成TileLink总线（协议），包含一些适配器和转其他总线（协议）的转换器
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　system:Rocket Chip的顶层代码包，同时也是用作测试的硬件平台的顶层代码包
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　unittest: 用作生成硬件测试平台来测试单独的一个个模块
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　util: 提供一些能被其他代码包调用的通用的Scala和Chisel结构
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="srcmainscalasystem">/src/main/scala/system&lt;/h3>
&lt;h4 id="testharnessscala">TestHarness.scala&lt;/h4>
&lt;p>TestHarness 模块通过模拟配置、接口连接和调试信号设置，构建了一个测试环境，用于验证 ExampleRocketSystem的功能&lt;/p>
&lt;h4 id="testgenerationscala">TestGeneration.scala&lt;/h4>
&lt;p>这段代码定义了RISC-V处理器的测试框架，它主要由一些抽象和具体的测试套件类组成，用于生成用于RISC-V测试的Makefile脚本片段。以下是代码的主要结构与功能：&lt;/p>
&lt;p>RocketTestSuite 抽象类：
这个抽象类定义了一个通用的测试套件结构，包含测试目录、目标名称、测试用例集合等关键参数。postScript属性生成用于链接目标文件的Makefile命令模板。&lt;/p>
&lt;p>AssemblyTestSuite 类：&lt;/p>
&lt;p>这是RocketTestSuite的子类，用于定义汇编语言的测试套件。每个实例表示特定环境（如rv32ui）下的测试集合，并生成包含测试文件的Makefile片段。
BenchmarkTestSuite 类：&lt;/p>
&lt;p>用于定义基准测试套件，支持特定目录中的多个基准测试，例如性能评估用的程序。
RegressionTestSuite 类：&lt;/p>
&lt;p>包含一组用于回归测试的测试文件，通过简单定义makeTargetName来统一生成Makefile片段。
TestGeneration 对象：&lt;/p>
&lt;p>该对象定义了添加测试套件并生成Makefile片段的逻辑。通过gen方法根据测试类型和环境生成目标名称和Perl脚本，用于捕获和处理测试结果。
DefaultTestSuites 对象：&lt;/p>
&lt;p>包含多个默认测试套件的实例，这些测试套件涵盖了不同类型的RISC-V指令集扩展，例如rv32ui、rv64ui、rv32ua、rv64ua等。还包括了一些性能基准和单一回归测试的示例。&lt;/p>
&lt;h4 id="configsscala">Configs.scala&lt;/h4>
&lt;p>TestHarness.scala 就是testbench，而 ExampleRocketSystem.scala 就是SOC的层次，包括Core以外的其他外设&amp;amp;总线，Configs.scala 就是核心Core的配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">BaseConfig&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e5c07b">Config&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithDefaultMemPort&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithDefaultMMIOPort&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithDefaultSlavePort&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithTimebase&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">BigInt&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">1000000&lt;/span>&lt;span style="color:#56b6c2">))&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span> &lt;span style="color:#7f848e">// 1 MHz
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithDTS&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#98c379">&amp;#34;freechips,rocketchip-unknown&amp;#34;&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">Nil&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">WithNExtTopInterrupts&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">2&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">BaseSubsystemConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="examplerocketsystemscala">ExampleRocketSystem.scala&lt;/h4>
&lt;p>对于SOC层面的设计&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">/** Example Top with periphery devices and ports, and a Rocket subsystem */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">ExampleRocketSystem&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">implicit&lt;/span> &lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#c678dd">:&lt;/span> &lt;span style="color:#e5c07b">Parameters&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e5c07b">RocketSubsystem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">with&lt;/span> &lt;span style="color:#e5c07b">HasAsyncExtInterrupts&lt;/span> &lt;span style="color:#7f848e">// 提供异步外部中断接口，允许系统处理来自外部设备的异步中断信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">with&lt;/span> &lt;span style="color:#e5c07b">CanHaveMasterAXI4MemPort&lt;/span> &lt;span style="color:#7f848e">// 添加 AXI4 主接口，用于连接存储器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">with&lt;/span> &lt;span style="color:#e5c07b">CanHaveMasterAXI4MMIOPort&lt;/span> &lt;span style="color:#7f848e">// 添加 AXI4 主接口，用于连接内存映射的 I/O 端口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">with&lt;/span> &lt;span style="color:#e5c07b">CanHaveSlaveAXI4Port&lt;/span> &lt;span style="color:#7f848e">// 添加 AXI4 从接口，支持与其他主设备的交互
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// optionally add ROM devices
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// 可选地添加 ROM 设备
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// Note that setting BootROMLocated will override the reset_vector for all tiles
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#7f848e">// 设置 BootROMLocated 将覆盖所有核心的重置向量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">bootROM&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">BootROMLocated&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">location&lt;/span>&lt;span style="color:#56b6c2">)).&lt;/span>&lt;span style="color:#e06c75">map&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#e5c07b">BootROM&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">attach&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">_&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#c678dd">this&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">CBUS&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span> &lt;span style="color:#7f848e">// 连接 BootROM 到 CBUS，以配置系统启动入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">maskROMs&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">MaskROMLocated&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e06c75">location&lt;/span>&lt;span style="color:#56b6c2">)).&lt;/span>&lt;span style="color:#e06c75">map&lt;/span> &lt;span style="color:#56b6c2">{&lt;/span> &lt;span style="color:#e5c07b">MaskROM&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">attach&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">_&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#c678dd">this&lt;/span>&lt;span style="color:#56b6c2">,&lt;/span> &lt;span style="color:#e5c07b">CBUS&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span> &lt;span style="color:#7f848e">// 将 MaskROMs 连接到 CBUS，作为只读存储器使用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">override&lt;/span> &lt;span style="color:#c678dd">lazy&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">module&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">ExampleRocketSystemModuleImp&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">this&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#7f848e">// 延迟加载模块实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="simaximemscala">simAXIMem.scala&lt;/h4>
&lt;p>Memory with AXI port for use in elaboratable test harnesses(一个mem的仿真模型)&lt;/p>
&lt;h3 id="srcmainscalarocket">/src/main/scala/rocket&lt;/h3>
&lt;p>此 RTL 包生成 Rocket 顺序流水线核心以及 L1 指令和数据缓存。此库旨在供芯片生成器使用，该生成器在内存系统中实例化核心并将其连接到外部世界。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/a_weiming/article/details/84594781" target="_blank" rel="noopener"
>rocket-chip目录&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/meton-robean/ResearchNote/issues/23" target="_blank" rel="noopener"
>rocketchip学习笔记&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/gujiangtaoFuture/articles/11766114.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/gujiangtaoFuture/articles/11766114.html&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>rocket-src微架构代码解读</title><link>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</link><pubDate>Sun, 27 Oct 2024 21:23:02 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid><description>&lt;h2 id="差异文件">差异文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 新加入的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RCU.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_cache.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RH_Cache.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_data.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_tag.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Runahead_cache.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 修改过的 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/BTB.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Frontend.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCacheArbiter.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCache.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/NBDcache.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RocketCore.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/Configs.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/SystemBus.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tile/Core.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Bundles.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Edges.scala
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</link><pubDate>Sat, 26 Oct 2024 15:23:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</link><pubDate>Sat, 26 Oct 2024 15:06:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="重排序缓存">重排序缓存&lt;/h2>
&lt;h3 id="一般结构">一般结构&lt;/h3>
&lt;p>ROB是一个FIFO&lt;/p>
&lt;p>(1)Complete:表示一条指令是否执行完毕&lt;/p>
&lt;p>(2)Areg:指令在原始程序中指定的目的寄存器,逻辑寄存器&lt;/p>
&lt;p>(3)Preg:指令的Areg经过寄存器重命名之后,对应的物理寄存器编号&lt;/p>
&lt;p>(4)OPreg:指令的Areg被重命名为新的Preg之前,对应的旧的Preg,当指令发生异常(exception)进行恢复,会用到&lt;/p>
&lt;p>(5)PC:指令对应的PC值,当发生中断或异常之后,需要保存指令的PC值&lt;/p>
&lt;p>(6)Exception:指令发生异常的异常类型&lt;/p>
&lt;p>(7)Type:指令的类型会被记录到这里,当指令retire时,不同类型的指令会有不同的动作,例如store指令写D-cache(那执行在干嘛)&lt;/p>
&lt;p>在流水线的分发阶段,指令会按照进入流水线的顺序写入ROB,ROB中对应的complete会被置0,执行完成之后会被置1.指令的计算结果可以放在ROB中,也可以放在物理寄存器堆(PRF)中.&lt;/p>
&lt;p>异常的处理统一放在提交阶段&lt;/p>
&lt;p>指令表项的编号会一直随着指令在流水线中流动&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 229;
flex-basis: 551px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241018201606114.png" data-size="699x304">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241018201606114.png"
width="699"
height="304"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241018201606114_hu3029882811398972242.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241018201606114_hu11810229668060151238.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>i1是除法指令,i2使用i1的结果,所以i1,i2执行时间很长&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 143;
flex-basis: 345px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160416090.png" data-size="535x372">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160416090.png"
width="535"
height="372"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160416090_hu526346446613648332.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160416090_hu11969902543979219059.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 150;
flex-basis: 361px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160430956.png" data-size="843x559">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160430956.png"
width="843"
height="559"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160430956_hu15166723323535760280.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160430956_hu17217095718010947724.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="端口需求">端口需求&lt;/h3>
&lt;p>对于一个4-way的超标量处理器来说,在ROB中每周期可以退休的指令不少于4条,ROB选择那些Complete的指令进行退休,但是由于是顺序的,如果连续4条中出现一条not ready ,后续的就无法retire&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 146;
flex-basis: 352px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160826543.png" data-size="413x281">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160826543.png"
width="413"
height="281"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160826543_hu2060967638341698444.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026160826543_hu6471094479480740589.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)4个读端口:retire时检测指令是否complete&lt;/p>
&lt;p>(2)8个读端口 : 在流水线的寄存器重命名阶段,需要从ROB读取4条指令的源操作数 ????&lt;/p>
&lt;p>(3)4个写端口:分发阶段需要向ROB写入4条指令 ????&lt;/p>
&lt;p>(4)最少4个写端口:在write back 阶段,需要写入最小4条指令的结果 (最少是由于很多处理器的issue width &amp;gt; machine width)&lt;/p>
&lt;h2 id="管理处理器的状态">管理处理器的状态&lt;/h2>
&lt;ol>
&lt;li>Architecture State , 通用寄存器的值,PC的值,存储器的值&lt;/li>
&lt;li>Speculative State,超标量处理器内部的状态,例如重命名使用的物理寄存器,重排序缓存(ROB),发射队列(Issue Queue)和store buffer 等,这些状态超前于指令集定义的状态&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 472px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026162140931.png" data-size="663x337">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026162140931.png"
width="663"
height="337"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026162140931_hu18410339645903847302.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026162140931_hu15498842930549422733.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于采用将通用寄存器扩展进行寄存器重命名的架构,需要将目的寄存器的值从物理寄存器搬移到通用寄存器中&lt;/p>
&lt;p>对于采用通用的物理寄存器进行重命名的架构,需要将目的寄存器在物理寄存器堆中标记为外界可见的状态???&lt;/p>
&lt;p>如果退休的指令是store, 需要把store buffer对应的值写到D-cache去(难道不是写完了再退休的吗)&lt;/p>
&lt;p>如果退休的指令是分支指令,需要进行状态恢复,并且冲刷错误指令,从正确地址取地址 ,&lt;/p>
&lt;p>在提交阶段还需要对异常进行统一处理&lt;/p>
&lt;p>两种方法&lt;/p>
&lt;p>(1)使用ROB管理指令集定义的状态&lt;/p>
&lt;p>(2)使用物理寄存器管理指令集定义的状态&lt;/p>
&lt;h3 id="使用rob管理指令集定义的状态-retire-register-file">使用ROB管理指令集定义的状态 (Retire Register File)&lt;/h3>
&lt;p>当指令退休的时候,指令的结果可以对指令集定义的状态进行更新,此时会将指令的结果从ROB中搬移到指令集中定义的逻辑寄存器中.逻辑寄存器存储了所有退休指令对应的目的寄存器的值&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 191;
flex-basis: 459px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026192854827.png" data-size="584x305">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026192854827.png"
width="584"
height="305"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026192854827_hu6872805367257657893.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026192854827_hu6988686517471031140.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一般情况下,使用ROB管理指令集定义的状态,都对应着使用数据捕捉的结构来进行发射(issue),因为指令的内容会存在在ROB和通用寄存器当中,通过数据捕捉可以在执行阶段把数据送到payload RAM ,可以直接从payload RAM去获取所有数据&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 207;
flex-basis: 497px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026193358686.png" data-size="729x352">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026193358686.png"
width="729"
height="352"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026193358686_hu14794657159944181992.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026193358686_hu17778871549113846091.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于非捕获队列,没有payload RAM,相应的数据是直接从ROB或者通用寄存器获取,所有需要发射队列支持额外的写端口(通知操作数的位置变动),和额外的旁路网络来&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 224;
flex-basis: 539px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026195235072.png" data-size="690x307">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026195235072.png"
width="690"
height="307"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026195235072_hu12509796414499110516.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026195235072_hu13364150662557934682.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="使用物理寄存器管理指令集定义的状态">使用物理寄存器管理指令集定义的状态&lt;/h3>
&lt;p>当物理寄存器的结果被计算出来之后,指令的状态变成了complete,当它退休的时候,直接把相应的状态标记为 Architecture state ,直到另一条指令写入同样的目标寄存器并且退休了,就相当于直接把指令集定义的逻辑寄存器融入到物理寄存器中&lt;/p>
&lt;p>(1)当指令从ROB中退休之后,不需要把指令的结果进行搬移,便于实现低功耗&lt;/p>
&lt;p>(2)在基于ROB进行状态管理时,需要ROB开辟空间存放指令的结果,但例如store,比较指令,分支指令是没有目的寄存器的,ROB会有一部分空间浪费掉了,但是这种方法只会对于存在目的寄存器的指令分配空间&lt;/p>
&lt;p>(3)ROB是集中管理方式,指令需要从其中读取操作数,同时指令也需要把结果写入其中,需要大量的读写端口,但是使用物理寄存器可以采用cluster结构等方式来避免多端口的负面影响&lt;/p>
&lt;p>但是这样会造成寄存器重命名比较复杂 ,使用ROB管理时,只需要写入ROB就完成了重命名,但是使用物理寄存器管理,需要额外的表格存放哪些物理寄存器是空闲的,并且重映射关系的建立和释放都比较困难,并且需要一个额外的表格来存放那些物理寄存器是Architecture state (这不是加一个标志位就可以了)&lt;/p>
&lt;h2 id="特殊情况的处理">特殊情况的处理&lt;/h2>
&lt;p>分支预测错误,或者异常&lt;/p>
&lt;p>store指令只有在retire阶段才能够真正改变处理器的状态(写D-cache),如果发射了D-cache缺失,会阻碍流水线中所以后面指令继续退休&lt;/p>
&lt;h3 id="分支预测失败">分支预测失败&lt;/h3>
&lt;p>以流水线的寄存器重命名为分界&lt;/p>
&lt;p>前端的状态回复(front-end recovery):将流水线中重命名阶段之前的所有指令都抹掉,将分支预测器中的历史状态标进行恢复,并使用正确的地址取指令&lt;/p>
&lt;p>后端的状态恢复(back-end recovery time):把处理器中所有内部组件(Issue Queue,Store Buffer 和 ROB)错误的指令都抹掉,恢复重命名映射表(RAT),以便那些错误指令对RAT的修改进行改正,同时被错误的指令占据的物理寄存器和ROB的空间需要被释放&lt;/p>
&lt;p>满足后端恢复的时间小于前端恢复的时间+取指和寄存器重命名的时间,不需要暂停流水线&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 917;
flex-basis: 2202px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201405204.png" data-size="514x56">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201405204.png"
width="514"
height="56"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201405204_hu16380282229336755602.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201405204_hu13274219510865086437.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 265;
flex-basis: 636px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201634076.png" data-size="873x329">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201634076.png"
width="873"
height="329"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201634076_hu12408654504628570787.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026201634076_hu13341318665468000535.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="基于rob重命名的架构基于扩展的arf进行寄存器重命名同理">基于ROB重命名的架构(基于扩展的ARF进行寄存器重命名同理)&lt;/h4>
&lt;p>当寄存器位于ROB时,在RAT中存储在ROB的位置,位于ARF,直接进行寻址 , RAT的地址是逻辑寄存器的值,数据是存储类型及对应具体位置&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 135;
flex-basis: 324px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026202221475.png" data-size="550x407">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026202221475.png"
width="550"
height="407"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026202221475_hu14505643750566939328.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026202221475_hu15297449480776893135.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一条退休的指令将目的寄存器从ROB搬移到ARF中后,并不一定表示以后指令需要从ARF读取寄存器的值&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">A :ADD R1,R2,R3
B :ADD R1,R1,R4
C :ADD R1,R1,R5
&lt;/code>&lt;/pre>&lt;p>只有指令C的映射关系会写入到RAT中, 即使指令A从流水线中退休了,后续的指令也只使用指令C的结果(why???).为了实现能够在指令实现搬移之后从ARF读取寄存器的值,在ROB中的每条指令都会检查自身是否是最新的映射关系,只有当一条指令从ROB中退休的时候,发现自身也是最新的映射关系,才能够将RAT中对应的内容改为ARF状态&lt;/p>
&lt;p>从ROB中退休的指令检查自身是不是最新的映射关系:在指令退休的时候,使用目的寄存器读取RAT,读出逻辑寄存器此时对应的ROB pointer,如果发现它和当前退休指令在ROB中占据的地址是一样的,表面这条退休的指令是最新的映射关系&lt;/p>
&lt;p>在流水线中发现分支预测失败时(一般是在执行阶段),此时流水线中有一部分指令是在分支指令之前进人到流水线的，它们可以被继续执行，因此当发现分支指令预测失败时，并不马上进行状态修复，而是停止取新的指令，让流水线继续执行，这个过程称为将&lt;strong>流水线抽干(drain out)&lt;/strong>,直到分支指令之前的所有指令(包括分支指令本身)都退休。此时 ARF 中所有寄存器的内容都是正确的，同时在流水线中的所有指令都是处于错误的路径上，可以将流水线中的指令全部抹掉，然后将 RAT 中所有的内容都标记为 ARF 状态，这样处理器就从分支预测失败的状态恢复过来了，此时可以从正确的地址开始取指.&lt;/p>
&lt;p>优点:重命名易于实现,状态恢复容易&lt;/p>
&lt;h4 id="基于统一的prf进行重命名的架构">基于统一的PRF进行重命名的架构&lt;/h4>
&lt;p>两个RAT (前端RAT(Speculative RAT)和后端RAT(Architecture RAT)),可以使用后端RAT对处理器进行状态恢复&lt;/p>
&lt;p>和前面类似,当发现分支指令预测失败时，并不马上进行状态修复，而是停止取新的指令，让流水线继续执行，这个过程称为将&lt;strong>流水线抽干(drain out)&lt;/strong>,直到分支指令之前的所有指令(包括分支指令本身)都退休,之后可以将流水线中的指令全部抹掉，然后将后端RAT 中所有的内容都复制到前端RAT，这样处理器就从分支预测失败的状态恢复过来了，此时可以从正确的地址开始取指.这种方法就是&lt;strong>Recovery at Retire&lt;/strong>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 153;
flex-basis: 368px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026214726040.png" data-size="609x397">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026214726040.png"
width="609"
height="397"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026214726040_hu6396325282664157643.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026214726040_hu7500078327809743159.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>还是会遇到问题,就是分支指令之前存在D-cache缺失的指令,会等待时间过程导致分支预测失败时的惩罚(mis-prediction penalty)过大&lt;/p>
&lt;p>为了解决上述问题,可以使用checkpoint,即在每条分支指令改变处理器状态之前,把处理器的状态保存起来,然后通过分支指令编号选择性去抹除流水线错误路径的指令,然后使用checkpoint去恢复RAT,基于SRAM的RAT需要保存整个表格,基于CAM的RAT只需要保存映射表中的状态位&lt;/p>
&lt;p>还可以去选择性的分配checkpoint的资源,对于分支预测错误率比较高的才分配checkpoint,但是如果分支预测失败,还是需要采用Recovery at Retire恢复,也可以使用ROB进行恢复,因为ROB中还是保存着旧的映射关系,即记录着每条指令对于重命名映射表的修改&lt;/p>
&lt;h3 id="异常的处理">异常的处理&lt;/h3>
&lt;p>使用ROB去顺序的执行所有的异常&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 393;
flex-basis: 945px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220112144.png" data-size="831x211">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220112144.png"
width="831"
height="211"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220112144_hu16578964903247613817.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220112144_hu7093890399153564677.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在指令即将要退休的时候,如果发生了异常就不能退休,而是要去转而处理异常&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 330;
flex-basis: 794px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220145671.png" data-size="791x239">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220145671.png"
width="791"
height="239"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220145671_hu12721806047334324940.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241026220145671_hu12980922077329163659.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>精确异常:处理器能够知道哪条指令发生了异常,并且这条发生异常的指令之后所有的指令都不允许改变处理器的状态,这样在处理完异常之后,可以精确的进行返回,返回地方有两种,(1)返回到发生异常指令本身,重新执行指令(TLB缺失),(2)不重新执行指令,而是返回到它的下一条指令(系统调用) ,精确异常需要抹去产生异常的指令后面的所有指令,并回复处理器修改的状态&lt;/p>
&lt;p>可以采用前面所说的Recovery ai Retire来恢复异常&lt;/p>
&lt;p>还有一种方法就是WALK,通过ROB保存的旧数据来恢复&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 234;
flex-basis: 562px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027150107021.png" data-size="727x310">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027150107021.png"
width="727"
height="310"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027150107021_hu11962430676454193348.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027150107021_hu7737992814455827596.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在使用统一的PRF进行寄存器重命名的方式中,和RAT相关的还有两个表格,一个存储那些物理寄存器是空闲的,Free Register ,一个存储物理寄存器的值是否被计算出来,Busy Table&lt;/p>
&lt;p>对于Free Register Pool ,因为刚刚读取的内容不会消失,不会被退休的指令覆盖,所以只需要恢复读指针,可以利用ROB的旧映射关系来进行恢复(如果是顺序读取Free Register Pool的话其实感觉只需要回退读指针就可以了)&lt;/p>
&lt;p>对于Busy Table,由于指令运算完成之后,就可以在写回阶段写入对应的物理寄存器,所以在发生异常时,Busy Table已经进行了多次修改.还是可以通过ROB,在从ROB读取指令时,每读取一条指令,就将指令的目的寄存器在Busy Table对应的内容置为无效 ,这样后续的指令也不会使用到错误的值了&lt;/p>
&lt;p>对于统一的PRF进行重命名的架构,使用WALK的方法是合适的,因为涉及到对Free Register Pool和Busy Table的恢复&lt;/p>
&lt;h3 id="中断的处理">中断的处理&lt;/h3>
&lt;p>中断是处理器外部发生的 ,是异步的&lt;/p>
&lt;p>(1)马上处理,当中断发生时,就将流水线中的指令全部抹掉,按照异常处理的方式进行恢复,并将流水线中最旧的指令PC值(还有其他状态寄存器)保存起来,然后跳转到对应的中断处理程序,返回时,使用保存的PC值重新取指令 .这种方式实时性最强,但是相当于之前的那些指令需要重新执行&lt;/p>
&lt;p>(2)延迟处理 .当中断发生时，流水线停止取指令，但是要等到流水线中所有的指令都退休(retire)之后才对这个中断进行处理，这样能够保证流水线中这些已有的指令不被“浪费”,而且当流水线中所有的指令都退休之后，此时流水线的状态肯定是正确的，也就不需要进行状态恢复了。&lt;/p>
&lt;p>(1)如果在流水线中的这些指令发生了 D-Cache 缺失，那么需要很长的时间才能够解决，这样导致了过长的中断响应时间。
(2)如果在流水线中发现了一条预测失败的分支指令，那么首先需要对这个情况进行处理，将处理器的状态进行恢复，这需要消耗一定的时间，也造成了中断响应时间的增大。&lt;/p>
&lt;p>(3)如果流水线中的这些指令中发生了异常(exception),那么是先对异常进行处理，还是先对中断进行处理？这需要仔细地进行权衡，但是一般来说，应该是先对中断进行处理， 因为很多类型的异常处理需要耗费很长的时间，如 D-Cache 缺失、TLB 缺失或者 Page Fault等，这样会导致中断的响应时间讨长而无法忍受。&lt;/p>
&lt;h3 id="store指令的处理">store指令的处理&lt;/h3>
&lt;p>store指令通常在retire之前都是不写入D-cache的,它会写入store buffer,这样load指令就会从store buffer 或者D-cache去获取数据.这种方法最安全,但是一旦store指令D-cache缺失,需要等待很长的时间,会造成ROB的堵塞&lt;/p>
&lt;p>可以在store buffer中增加一个状态位,标记store指令是否具备退休的条件,这样store在缓存中有3个状态&lt;/p>
&lt;p>un-complete(未执行完毕),当store指令在分发阶段占据一个store buffer的时候标记为un-complete&lt;/p>
&lt;p>complete(已经执行完毕),当store指令已经得到地址和数据,但是没有变成最旧的指令,标记为complete&lt;/p>
&lt;p>(retire)离开流水线,当store指令成为最旧的指令并退休是,在store buffer标记该状态,这样store指令可以离开ROB,就不会阻碍后面的指令离开流水线,而硬件会自动将store buffer中处于retire状态的store指令写到D-cache中,并且此时store buffer中的retire的内容也会成为Architecture state的一部分&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 222;
flex-basis: 532px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154045976.png" data-size="715x322">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154045976.png"
width="715"
height="322"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154045976_hu1744290998666272899.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154045976_hu16397971302973277069.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>store buffer中的指令只有在完成写D-cache的任务之后才会释放空间,这样会造成分发之前的流水线发生阻塞,可以把已经退休的store指令存储在一个叫做write back buffer的地方,硬件会自动将write back buffer的store指令写到D-cache中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 277;
flex-basis: 665px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154430488.png" data-size="721x260">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154430488.png"
width="721"
height="260"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154430488_hu13023071255000305450.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027154430488_hu3884197430323085139.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>这样write back buffer也会成为Architecture state的一部分,load指令需要在store buffer和write back buffer中查找.一旦write back buffer没有空间了,就不能再将store指令退休&lt;/p>
&lt;p>store 指令也是顺序进入write back buffer的,但是在进入的同时需要查找有没有写入相同地址的store指令,有的话需要把前面的store指令置为无效 ,保证load能够查找罪行的数据&lt;/p>
&lt;p>对于软件处理TLB缺失的处理器,在store指令需要退休时,如果ROB中记录了TLB缺失的异常,那么store指令不能够进入write back buffer,而是需要异常的处理,需要将流水线清空,进行处理器的状态恢复.然后跳转到对应的异常处理程序中去,处理完之后重新执行store,这样可以保证所有进入write back buffer中的store指令不会产生TLB缺失&lt;/p>
&lt;h3 id="指令离开流水线的限制">指令离开流水线的限制&lt;/h3>
&lt;p>在4-way的超标量处理器中,如果ROB中最旧的四条指令都处于complete状态,理论上四条指令都能够退休&lt;/p>
&lt;p>但是
(1)每周期有四条store指令退休,意味着D-Cache或者Write Back Buffer需要支持四个写端口&lt;/p>
&lt;p>(2)每周期有四条分支指令退休,意味着没周期需要将四条分支指令的信息写回分支预测器,这需要分支预测器中是偶有部件需要支持四个写端口,同时需要能够将Checkpoint资源在每周期释放四个&lt;/p>
&lt;p>(3)如果在处理器中对 store/load 指令之间的相关性实现了预测，即预测一条 load 指令是否会和它之前的 store 指令存在相关性，在这种情况下，如果每周期有四条 load 指令退休，意味着每周期需要将四条 load 指令的信息写回到相关的预测器中，这也导致了四个写端口的需求。&lt;/p>
&lt;p>但是上述情况出现的概率很小,所以增加硬件结构不如对指令进行限制,比方说限制每次退休的分支指令只能有1条之类的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 251;
flex-basis: 604px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027205917686.png" data-size="735x292">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027205917686.png"
width="735"
height="292"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027205917686_hu8938038301564095761.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/image-20241027205917686_hu5547790577299267913.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>br_mask = 1110 (如果假设分支指令是1,那对分支指令进行异或应该能够得到1110这一串数字), st_mask = 1111 , ld_mask = 1111 ,那么代表第四条指令是第二条分支指令,再把3个结果相与,得到1110,代表只有前三条指令有资格退休&lt;/p>
&lt;p>同理,对于异常指令,也只能退休一条,所以在检测到异常指令之后,需要对后续的指令进行屏蔽&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>执行</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</link><pubDate>Tue, 22 Oct 2024 13:17:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 135;
flex-basis: 326px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png" data-size="560x412">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png"
width="560"
height="412"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu15249404520933549812.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu12474515009045795584.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>旁路网络:负责将FU的运算结果送到需要的地方&lt;/p>
&lt;p>每个FU都和一个1-of-M的仲裁电路一一对应,被选择的指令去读取物理寄存器堆(或者payload RAM),从而得到对应的操作数,每个仲裁电路和物理寄存器也数一一对应的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 130;
flex-basis: 312px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143442602.png" data-size="596x458">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143442602.png"
width="596"
height="458"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143442602_hu14086456258735412881.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143442602_hu12825982916654345585.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="fu的类型">FU的类型&lt;/h2>
&lt;h3 id="alu">ALU&lt;/h3>
&lt;h3 id="aguaddress-generate-unit">AGU(address generate unit)&lt;/h3>
&lt;p>用于计算访问存储器类型的指令在指令中携带的地址&lt;/p>
&lt;h3 id="brubranch-unit">BRU(Branch Unit)&lt;/h3>
&lt;p>负责处理程序控制流(control flow)类型的指令&lt;/p>
&lt;p>负责将分支指令携带的目标地址计算出来,并且根据一定的情况来决定是否使用地址,同时对进行分支预测正确与否的判断&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 137;
flex-basis: 330px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145819993.png" data-size="361x262">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145819993.png"
width="361"
height="262"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145819993_hu14722048187769645653.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145819993_hu16491768975060659322.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于ARM和PowerPC在每一条指令都加入的条件码,不局限于分支指令,相当于吧程序中的控制相关性使用数据相关性代替了,这样可以降低分支指令使用的频率,但是条件执行会占据指令编码的位数,减少指令中分配给通用寄存器的部分,并且可能会出现很多条无效的指令,反而可能会降低效率&lt;/p>
&lt;p>而且,如果跳转指令的条件不成立,比方说下面的ADD指令,可能就会使用错误的数据,可以通过暂停流水线或者预测的方式来解决&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 239;
flex-basis: 575px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145959666.png" data-size="571x238">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145959666.png"
width="571"
height="238"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145959666_hu13405921241260827723.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023145959666_hu16403348829444298644.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 369;
flex-basis: 887px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023151843118.png" data-size="551x149">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023151843118.png"
width="551"
height="149"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023151843118_hu7430235981767082100.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023151843118_hu13488875576436232187.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="select-uop指令">select-uOP指令&lt;/h4>
&lt;p>对于Intel,通过硬件插入额外的指令来选择正确的结果&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 296;
flex-basis: 711px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023152400515.png" data-size="516x174">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023152400515.png"
width="516"
height="174"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023152400515_hu5632629170899648535.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023152400515_hu18321081067909416502.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过加入uOP来选择结果,但是这要求条件执行的指令必须成对出现,但是这样对编译器存在一定的制约,可以采取对于每一条条件指令都加入select-uOP的方法来解决,就相当于在执行完成条件指令之后,又对执行条件指令之后的值和执行条件指令之前的值进行了一次选择,将选择的值用于后续的寄存器重命名&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 324;
flex-basis: 777px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023153031814.png" data-size="713x220">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023153031814.png"
width="713"
height="220"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023153031814_hu12476907188911963936.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023153031814_hu4524719064748493901.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于ARM指令,有一个条件寄存器CPSR,对于每一条条件指令例如ADDEQ,都需要先去判断条件寄存器的值,再决定执行不执行&lt;/p>
&lt;p>BRU还负责对于分支指令结果的检查,通过分支缓存和BRU单元的结果进行对比来实现,因为分支缓存中是保存了所有预测跳转的指令&lt;/p>
&lt;h2 id="旁路网络">旁路网络&lt;/h2>
&lt;p>从FU的输出端到输入端架起一个通路,可以将FU的结果送到所有FU的输入端,物理寄存器堆,payload RAM,即旁路网络&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 560;
flex-basis: 1345px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155021269.png" data-size="740x132">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155021269.png"
width="740"
height="132"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155021269_hu5668004785509550045.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155021269_hu11767405952031318563.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 379;
flex-basis: 910px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155047254.png" data-size="789x208">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155047254.png"
width="789"
height="208"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155047254_hu1657959911695311649.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155047254_hu13703149774171246216.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在更为现实的处理器中,在Regfile read 之后还会加入一个流水段称为 source Drive,因为对于一条指令从源操作数从物理寄存器读出来之后,还需要经过很长的一段布线,才能达到输入端,而且FU的输入端有大量的多路选择器,用来从不同的旁路网路或者物理寄存器堆选择合适的操作数,同理 FU的输出段也需要经过复杂的网路到达输入端,也需要一级,即Result drive&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 521;
flex-basis: 1251px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155120596.png" data-size="845x162">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155120596.png"
width="845"
height="162"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155120596_hu17500992777549816955.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023155120596_hu14460900288832725067.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="简单的旁路网络">简单的旁路网络&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 223;
flex-basis: 536px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023160723616.png" data-size="827x370">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023160723616.png"
width="827"
height="370"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023160723616_hu18169707612863153657.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023160723616_hu13065555197707174522.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一个FU中也会有多个计算单元,一个周期只能送一条指令进FU,如果计算单元需要的周期数(latency)相等,那无所谓,但是如果不能,就可能出现在不同周期被送进来,但是在相同周期计算出结果,都想通过旁路网络进行传送&lt;/p>
&lt;p>一种解决方法就是对于一条指令正常进行唤醒和仲裁,在FU中被执行前,首先检查当前FU是否可以被自己使用(通过周期数,上周期接收了一条latency=2的指令,当周期就不要接收latency=1的指令),如果不行,放回发射队列,重新进行仲裁.&lt;/p>
&lt;p>但是这样会造成一些本来可以仲裁成功的指令被耽搁了,因此可以直接让latency作为某个值的指令就不参与仲裁的过程&lt;/p>
&lt;p>在设计发射队列时,也需要考虑是否当前的FU是能够被使用的&lt;/p>
&lt;p>对每个仲裁电路设计一个位宽为2位的控制寄存器,高位用来拦截所有latency=2的指令,低位拦截latency=1的指令,并且在发射队列的表项中增加两个信号,指示latency=1 or 2&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 153;
flex-basis: 367px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023162500495.png" data-size="852x556">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023162500495.png"
width="852"
height="556"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023162500495_hu14593910934300950979.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023162500495_hu16586514541434976942.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>每个周期都需要对两位寄存器进行赋值,也要进行移位,比方说 latency = 3,就将两位寄存器赋值为10,latency = 2 ,就将两位寄存器赋值为01&lt;/p>
&lt;p>如果第一个周期选中了latency = 3的指令 , 第二个周期选中了latency = 3的指令 ,cycle 1 , a = 10 , cycle 2 , a = 11 = (10 &amp;raquo; 1 )| 10&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 209;
flex-basis: 502px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164412302.png" data-size="519x248">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164412302.png"
width="519"
height="248"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164412302_hu2180771558406431873.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164412302_hu18316455888187908961.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="复杂设计的旁路网络">复杂设计的旁路网络&lt;/h3>
&lt;p>(1)指令 B 只能在流水线的 Execute 阶段，从指令 A 的 Result drive 阶段获得操作数。&lt;/p>
&lt;p>(2)指令 C 可以在流水线的 Source drive 阶段，从指令 A 的 Result drive 阶段获得操作数；或者指令 C 也可以在流水线的 Execute 阶段，从指令 A 的 Write back 阶段获得操作数。
(3)指令 D可以在流水线的 Source drive 阶段，从指令 A 的 Write back 阶段获得操作数。
(4)指令 E 在流水线的 RF Read 阶段读取物理寄存器堆(PRF)时，就可以得到指令 A 的结果了，因此它不需要从旁路网络中获得操作数，这里假设物理寄存器堆可以在前半个周期写人，后半个周期读取。&lt;/p>
&lt;p>&lt;strong>对于每一个指令,不一定是在执行阶段得到旁路网络的结果&lt;/strong>&lt;/p>
&lt;p>execute阶段的操作数除了来自于上一级流水线,还可以来自于两个FU计算的结果 ,来自于流水线的 Result Drive (B相对于A)&lt;/p>
&lt;p>Source Drive 阶段,操作数除了来自于上一级流水线,还可以来自于以前流水线的结果,分布在Result Drive(C相对A)和Write Back(D相对于A)&lt;/p>
&lt;p>A和E是不需要旁路网络的 ,即某一条指令处在RF Read 里,另一条指令处在Write back 里,就不需要进行旁路&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 432px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164621687.png" data-size="754x418">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164621687.png"
width="754"
height="418"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164621687_hu11888635452023152137.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023164621687_hu11255700068533527627.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 94;
flex-basis: 226px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023193442904.png" data-size="666x706">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023193442904.png"
width="666"
height="706"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023193442904_hu13004870574175724935.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023193442904_hu2537975837088478881.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)当两条指令处在相邻周期,旁路路径只能发生在Execute 和 Result Drive&lt;/p>
&lt;p>(2)当两条指令相差一个周期,旁路路径能够发生在Source Drive和Result Drive, Execute 和Write Back 之间&lt;/p>
&lt;p>(3)当两条指令相差两个周期,旁路路径只能发生在Source Drive 和 Write Back 之间&lt;/p>
&lt;p>提供数据的指令一定得在Execute后,接受数据的指令一定要在RF read后&lt;/p>
&lt;h3 id="操作数的选择">操作数的选择&lt;/h3>
&lt;p>ScoreBoard&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 478px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023195557026.png" data-size="477x239">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023195557026.png"
width="477"
height="239"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023195557026_hu224179638028002947.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023195557026_hu16682950285114137150.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>FU#:记录物理寄存器从哪个FU中被计算出来,当一条指令被仲裁电路选中的时候,如果指令存在目的寄存器,就将这条指令在哪个FU中执行的信息写到表格中&lt;/p>
&lt;p>R:表示物理寄存器的值已经从FU中计算出来了,并且已经被写到物理寄存器堆中了(在写回的时候更新)&lt;/p>
&lt;p>指令B通过读取scoreBoard可以得知需要从FU中取数据&lt;/p>
&lt;p>指令C可以得知可以从PRF中取数据&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 381;
flex-basis: 916px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023200505179.png" data-size="737x193">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023200505179.png"
width="737"
height="193"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023200505179_hu13854645784151382880.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023200505179_hu11359890069373188788.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以把读取scoreboard的过程放到流水线的RF Read阶段,使得ScoreBoard和PRF同时读取,但是这样会出现问题就是比方说指令A和指令C,如果移动到了Regfile Read阶段,指令C无法获知指令A修改的ScordBoard的值,需要加入比较逻辑,当ScoreBoard写入和读取的编号一致的话,就设置为从PRF取得操作数&lt;/p>
&lt;p>对于能够并行执行N条指令的处理器,需要2N个读端口,2N个写端口&lt;/p>
&lt;p>用最简单的方法,就是因为每个FU会把一条指令的计算结果广播送到FU输入和物理寄存器堆,同时也会送出对应的寄存器编号,所以可以直接和源寄存器进行比较就行,需要选择操作数的两个周期Source Drive 和 Execute阶段(为什么是两个阶段????)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 183;
flex-basis: 439px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024203513613.png" data-size="713x389">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024203513613.png"
width="713"
height="389"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024203513613_hu8458801169996393152.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024203513613_hu9604523862459205188.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="cluster">Cluster&lt;/h2>
&lt;h3 id="cluster-iq">Cluster IQ&lt;/h3>
&lt;p>通过将一个集中式的发射队列分成几个小的分布式发射队列,每个发射队列只对应一个仲裁电路和FU,这样每个分布式发射队列只需要存储对应的FU能够执行的指令&lt;/p>
&lt;p>(1)可以减少每个分布式发射队列的端口个数&lt;/p>
&lt;p>(2)每个分布式发射队列的仲裁电路只需要从少量的指令进行选择,可以加快每个仲裁电路的速度&lt;/p>
&lt;p>(3)分布式发射队列的容量比较小,指令被唤醒的速度也比较快&lt;/p>
&lt;p>缺点就是一个发射队列的指令对其他发射队列指令进行唤醒时,需要经历很长的走线,可能需要增加一级流水线,这样当两条存在相关性的相邻指令属于两个不同Cluster事,不能背靠背执行&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 191;
flex-basis: 460px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024205608529.png" data-size="836x436">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024205608529.png"
width="836"
height="436"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024205608529_hu8384213802176442674.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024205608529_hu1594713213561487067.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>但是通过对指令进行合理的算法分配cluster,也可以做到周期的合理使用&lt;/p>
&lt;p>对于普通的集中式发射队列,需要3个周期,如果A,B,E在同一个cluster,C,D在另一个cluster那需要5个周期,但是如果A,C分到一个cluster,B,D,E分到另一个cluster中,那就只需要3个周期&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 228;
flex-basis: 547px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210359607.png" data-size="438x192">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210359607.png"
width="438"
height="192"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210359607_hu2303037202705240120.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210359607_hu9192380050617067700.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 209;
flex-basis: 502px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210424365.png" data-size="526x251">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210424365.png"
width="526"
height="251"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210424365_hu6627521120969527641.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210424365_hu7444645623256956563.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 211;
flex-basis: 507px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210535873.png" data-size="535x253">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210535873.png"
width="535"
height="253"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210535873_hu8861715288620074021.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024210535873_hu2374024891856620924.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于非数据捕捉结果的处理器,指令会先读取物理寄存器堆,需要PRF支持多个读端口,所以可以对寄存器堆也采用cluster结构,对每一个采用cluster结构的发射队列使用同一个物理寄存器堆&lt;/p>
&lt;p>原来4个FU有8个读端口,4个写端口,可以变成4个读端口,4个写端口,不过需要让两个PRF保持一致,还需要去更新另一个寄存器(那不是会影响并u行性)&lt;/p>
&lt;p>当两个存在相关性的连续指令属于两个不同的cluster时,后续的指令需要等到前面的指令更新完寄存器堆之后,才能够从寄存器堆读取操作数????? 因为旁路网络最好不好跨越两个cluster&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 198;
flex-basis: 477px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212016007.png" data-size="829x417">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212016007.png"
width="829"
height="417"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212016007_hu12563989265596371535.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212016007_hu7321058393778903345.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="cluster-bypass">cluster bypass&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 177;
flex-basis: 426px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212557051.png" data-size="854x481">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212557051.png"
width="854"
height="481"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212557051_hu4965631951152540929.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024212557051_hu12953251598118112777.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>采用cluster结构的可以直接去除流水线的Source Drive 和 Result Drive流水段&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 322;
flex-basis: 774px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024213929124.png" data-size="858x266">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024213929124.png"
width="858"
height="266"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024213929124_hu207480023195120802.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024213929124_hu15840521158928439603.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在顺序执行的处理器,由于硬件无法调度不相关的指令,非完全的旁路网络会带来很大的负面影响,会产生大量的气泡,显然降低了处理器的性能,因此尽量会采用完全的旁路网络&lt;/p>
&lt;p>可以类比发射队列,在相邻的cluster加入一级流水线来降低路径延时,形成完全的旁路网络&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 279;
flex-basis: 670px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214301619.png" data-size="765x274">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214301619.png"
width="765"
height="274"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214301619_hu735835723770192725.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214301619_hu17445429456382917378.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>发射队列的流水和旁路网络的流水导致的延时不会叠加&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 207;
flex-basis: 497px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214434028.png" data-size="531x256">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214434028.png"
width="531"
height="256"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214434028_hu13183690665095587033.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241024214434028_hu9770905204137056385.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="存储器指令的加速">存储器指令的加速&lt;/h2>
&lt;h3 id="memory-diambiguation">memory diambiguation&lt;/h3>
&lt;p>访存地址也会存在相关性,但是这个相关性是在执行阶段计算出访存的指令之后才能够被发现 ,在解码阶段是无法被发现的&lt;/p>
&lt;p>大部分的store是按照顺序执行的(in-order),可以避免WAW相关性(why?)&lt;/p>
&lt;p>load指令可以分为&lt;/p>
&lt;p>(1)完全的顺序执行,没有WAW和WAR相关性&lt;/p>
&lt;p>(2)部分的乱序执行,顺序执行的store将程序分成不同的块,每当一条指令store的地址被计算出来,store指令和后续的store指令之间的所有load指令可以乱序执行,可以避免WAR相关性的发生&lt;/p>
&lt;p>当一条store指令地址被计算出来后,load指令就具备判断RAW相关性的条件了,每条load指令把它携带的地址计算出来之后,需要和前面所有已经执行的store指令携带的地址进行比较.通过 store buffer保存已经被仲裁电路选择倒是没有离开流水线的指令&lt;/p>
&lt;p>当store被选中时,其实就可以去允许后面的load指令参与仲裁,因为store指令地址计算的结果肯定先于load地址
存在的问题就是,如果在BCD没有被选中完毕之后,指令E被选择了,此时如果指令E和指令D的地址一致,指令D也不应该获取指令E的内容,所有需要判断出那些store指令在load的前面,哪些在后面&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 118;
flex-basis: 285px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025213624613.png" data-size="301x253">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025213624613.png"
width="301"
height="253"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025213624613_hu14399999219861116549.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025213624613_hu16921245988269030946.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>PC值,但是存在向前跳转的指令&lt;/li>
&lt;li>ROB,ROB是顺序的,但是由于访存指令还是少数,所以会比较稀疏&lt;/li>
&lt;li>解码阶段为load/store指令分配编号&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 359;
flex-basis: 862px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025214623161.png" data-size="611x170">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025214623161.png"
width="611"
height="170"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025214623161_hu12201052963255340503.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241025214623161_hu8831078567315548889.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于上述指令,部分的乱序也是会浪费很多性能&lt;/p>
&lt;p>(3)完全的乱序执行,WAR和RAW都需要在流水线中执行&lt;/p>
&lt;p>只要load指令的操作数准备好了,就可以直接发起仲裁请求了&lt;/p>
&lt;p>可以让load/store共用发射队列,但还是需要独立的仲裁电路,store指令的仲裁电路需要根据年龄,找到最旧的指令(in-order),load指令,只需要选择准备好的最老的一条指令就行了(out-of-order)&lt;/p>
&lt;p>如果分开发射队列的话,store的发射队列只需要使用FIFO结构&lt;/p>
&lt;p>需要精确的预测机制来避免RAW的相关性,例如如果发现一条LOAD指令和之前的STORE指令存在RAW相关性,就先进行记录,在后续从store buffer 中获取数据 ,这样其实也可以去减少store buffer需要的端口和比较电路&lt;/p>
&lt;h3 id="非阻塞cache">非阻塞cache&lt;/h3>
&lt;p>阻塞cache:在发生cache缺失的时候,就锁定D-Cache与数据内存之间的数据通路,处理器无法执行其他的load/store指令&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 387;
flex-basis: 930px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026141835829.png" data-size="659x170">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026141835829.png"
width="659"
height="170"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026141835829_hu8881803643920320762.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026141835829_hu2616120719687539429.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>非阻塞cache:在发生缺失时还是可以执行其它的load/store指令,所以需要去保存load/store相应的一些数据,比方说store的数据 ,load的目的寄存器,但是实际上访问存储器还是通过一条数据通路&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 332;
flex-basis: 798px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142115052.png" data-size="692x208">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142115052.png"
width="692"
height="208"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142115052_hu16210908296073923288.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142115052_hu14757556971080052922.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>为了支持非阻塞cache,需要将那些已经产生D-cache缺失的load/store指令保存起来(MSHR(Miss Status/infornmation Holding Register))&lt;/p>
&lt;p>(1)首次缺失 ,对于一个给定的地址,访问D-Cache时第一次产生的缺失&lt;/p>
&lt;p>(2)再次缺失,首次缺失但是没有被解决,后续访问存储器的指令再次访问发生缺失的cache line ,再次缺失针对的是cache line 不是相同的地址,&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 201;
flex-basis: 482px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142859357.png" data-size="674x335">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142859357.png"
width="674"
height="335"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142859357_hu551379707438212741.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026142859357_hu12241835318558202936.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>MSHR:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>V:valid ,指示当前的表项(entry)是否被占用 ,首次缺失MSHR本体的一个表项会被占用,Valid置一,直到Cache line从下级存储器被取回来.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Block Address : Cache line 数据块的公共地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Issued: 表示发生首次缺失的load/store指令是否已经开始处理,即是否向一级存储器发送读数据的请求&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>LOAD/STORE Table&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Valid : 表示一个表项是否被占用,无论是首次缺失还是再次缺失&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MSHR entry : 表示发生缺失的指令属于MSHR本体的哪个表项,产生缺失的指令可能会对应同一个cache line , 为了避免重复占用下一级存储器的带宽,只会占据同一个MSHR entry ,但是占据多个LOAD/STORE Table&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dest.register : 对于load指令,记录目的寄存器的编号, 对于store指令,这部分记录store指令在store buffer中的编号,一是可以找到store指令所携带的数据,以便和下级存储器中取出的数据块合并,二是能够释放store指令占据的store buffer中的空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Type :记录访问存储器指令的类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Offset:访问存储器的指令所需要的数据在数据块中的位置&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当发生缺失是,首先查找MSHR的本体,如果有相同的表项,代表再次缺失,只需要写到LOAD/STORE Table ,如果没有,需要写入MSHR和LOAD/SOTRE Table&lt;/p>
&lt;p>如果满了,就无法去处理新的访问存储器指令,就阻塞了&lt;/p>
&lt;p>对于load指令,需要把数据送到对应目的寄存器,并写到D-cache里 ,&lt;/p>
&lt;p>对于store指令,需要从Store buffer中找到对应的数据,和数据块合并,然后写到D-cache 里,然后释放store buffer&lt;/p>
&lt;p>(in-cache MSHR )&lt;/p>
&lt;p>在分支预测失败之后,需要去删除LOAD/SOTRE Table正在执行的load/store指令 ,并且如果针对于一个数据块的所有load/store指令都处于分支预测的路径上,那这个数据块也不能去更新到D-cache上去&lt;/p>
&lt;h3 id="关键字优先">关键字优先&lt;/h3>
&lt;p>就是去改进读取cache块数据的顺序 ,本来是0,1,2,3,4,5,6,7,8,可以修改为 &amp;mdash; 之类的 ,可以去把访存需要的数据提前&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 296;
flex-basis: 712px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151114817.png" data-size="591x199">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151114817.png"
width="591"
height="199"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151114817_hu396055995009789009.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151114817_hu14091866778141281238.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 264;
flex-basis: 633px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151122926.png" data-size="536x203">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151122926.png"
width="536"
height="203"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151122926_hu17293496163497610529.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151122926_hu13979690035990851764.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="提前开始">提前开始&lt;/h3>
&lt;p>在Cache line读取到指令需要的数据之后,就可以让CPU去继续执行了 ,相比于关键字优先不需要额外的硬件,但是如果数据处在数据块比较后面的位置,那就没有太大的用处&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 226;
flex-basis: 544px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151237967.png" data-size="490x216">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151237967.png"
width="490"
height="216"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151237967_hu3679352889834253705.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151237967_hu13572565010743933473.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于I-cache ,虽然指令需要做到顺序取出,但是由于存在分支跳转,也可以通过非阻塞的操作来加快取指,不同于D-cahce的是取出的指令必须是顺序的,如果前面的指令没有被取出来也必须进行等待直到数据被取出&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 200;
flex-basis: 480px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151523608.png" data-size="521x260">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151523608.png"
width="521"
height="260"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151523608_hu5704554154872303021.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151523608_hu14489172107682820978.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 298;
flex-basis: 716px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151504187.png" data-size="660x221">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151504187.png"
width="660"
height="221"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151504187_hu6937163011637089782.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241026151504187_hu5649834906388973804.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>发射</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</link><pubDate>Sat, 19 Oct 2024 20:25:19 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令&lt;/p>
&lt;p>发射时序一般处在处理器的关键路径上,直接影响处理器的周期时间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 164;
flex-basis: 394px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png" data-size="596x363">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251.png"
width="596"
height="363"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu10933506266918888330.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019211023251_hu6047188780366288377.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)发射队列(Issue Queue),用来存储已经被寄存器重命名,但是没有被送到FU执行的指令,也称为保留站(Reservation station)&lt;/p>
&lt;p>(2)分配(allocation)电路,用来从发射队列中找到空闲的空间,将寄存器重命名之后的指令存储在其中&lt;/p>
&lt;p>(3)选择电路(仲裁电路),发射队列中多条指令的操作数都准备好了,电路会按照一定规律,从其中找到最合适的指令,送到Fu中去&lt;/p>
&lt;p>(4)唤醒电路,当一条指令经过FU执行而得到结果数据时,会将其通知给发射队列中所有等待数据的指令,指令对应的源寄存器就会被设置为有效的状态,即为唤醒.&lt;/p>
&lt;h3 id="集中式-or-分布式发射队列">集中式 or 分布式发射队列&lt;/h3>
&lt;p>如果所有FU共用一个发射队列,即为集中式发射队列(centralized issue queue,CIQ)&lt;/p>
&lt;p>如果每一个FU都有单独的发射队列,称为分布式发射队列(Distributed issue queue,DIQ)&lt;/p>
&lt;p>CIQ容量大,选择电路和唤醒电路复杂,电路利用率高&lt;/p>
&lt;p>DIQ会出现一个发射队列满了,其他发射队列没有满,但是最终数据被阻塞的情况,就会出现效率低下的问题&lt;/p>
&lt;h3 id="数据捕捉-or-非数据捕捉">数据捕捉 or 非数据捕捉&lt;/h3>
&lt;p>寄存器的数据读取时间&lt;/p>
&lt;h4 id="数据捕捉">数据捕捉&lt;/h4>
&lt;p>流水线的发射阶段之前读取寄存器,被寄存器重命名的指令会先读取物理寄存器堆,然后将读取到的值一起写入到发射队列,没有被计算出来的数据会以编号的形式写入,供唤醒时使用,会被标记为无法获得状态(non-available),这些值会通过旁路网络获取.在发射队列中,存储指令操作数的地方称为payload RAM&lt;/p>
&lt;p>一条指令被仲裁电路选中发射到FU中去,它会将目标寄存器进行广播,其他在发射队列的指令就会去对比,有相等的情况时就会在payload RAM进行标记,在FU计算完成之后会写入到payload RAM 对应的位置 .&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 249;
flex-basis: 598px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png" data-size="776x311">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505.png"
width="776"
height="311"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu17079656071217617578.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019212613505_hu4889682781684174770.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>machine width : 每周期实际解码和重命名的指令个数&lt;/p>
&lt;p>issue width : 每周期最多可以在FU中并行执行的指令个数&lt;/p>
&lt;p>在RISC 里 machine width &amp;lt;= issue width&lt;/p>
&lt;p>物理寄存器的端口数 = machine width * 2&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 109;
flex-basis: 262px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png" data-size="482x441">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857.png"
width="482"
height="441"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu9745096111898785255.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214007857_hu6496583278703640029.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>大多数源操作数会经历两读1写,从寄存器读取出来,送到发射队列,从发射队列中读取送到FU ,功耗高 ,面积大&lt;/p>
&lt;p>寄存器重命名方便 ,指令在顺利离开流水线的时候,需要将结果从重排序缓存中搬移到ARF中,采用数据捕捉的方式可以不用惯性指令结果的变化??????&lt;/p>
&lt;h4 id="非数据捕捉">非数据捕捉&lt;/h4>
&lt;p>在发射阶段之后读取物理寄存器堆,被重命名之后的指令不去读取物理寄存器堆,而是直接将源寄存器堆的编号放到发射队列中去.当指令被选中时,通过编号读取物理寄存器堆,将读取值送到FU中&lt;/p>
&lt;p>寄存器堆的读端口 = issue width ,比较大&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 278px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png" data-size="543x468">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455.png"
width="543"
height="468"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu17049688566279640447.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019214531455_hu12853474364071027865.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="压缩-or-非压缩">压缩 or 非压缩&lt;/h3>
&lt;h4 id="压缩">压缩&lt;/h4>
&lt;p>当一条指令被选中离开发射队列之后,指令上面所有的指令都会下移一格&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 177;
flex-basis: 425px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png" data-size="620x350">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572.png"
width="620"
height="350"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu11413087233639779848.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215435572_hu6794216728322161169.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过多路选择器进行压缩&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 230;
flex-basis: 554px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png" data-size="702x304">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440.png"
width="702"
height="304"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu14122326088059142316.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215543440_hu10310402141209563975.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>这种方式选择电路比较简单,通过优先编码选择最旧的就行了,oldest-first方法 ,但是选择电路的延时很长&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 162;
flex-basis: 390px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png" data-size="512x315">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085.png"
width="512"
height="315"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu10969826154039478454.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241019215909085_hu1981833134611443612.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>优点如下:&lt;/p>
&lt;p>1.分配电路简单,发射队列中的空闲空间总是处于上层,只需要使用发射队列的写指针,指向第一个空闲空间&lt;/p>
&lt;p>2.选择电路简单.最旧的指令存在的RAW相关性也越多,先执行可以最大程度释放和它存在RAW相关性的指令&lt;/p>
&lt;p>但是&lt;/p>
&lt;p>1.实现起来浪费面积&lt;/p>
&lt;p>2.功耗大&lt;/p>
&lt;h4 id="非压缩">非压缩&lt;/h4>
&lt;p>没有移动&lt;/p>
&lt;h2 id="发射过程中的流水线">发射过程中的流水线&lt;/h2>
&lt;h3 id="非数据捕捉结构的流水线">非数据捕捉结构的流水线&lt;/h3>
&lt;p>要被FU执行&lt;/p>
&lt;p>(1)指令所有的源操作数准备好了&lt;/p>
&lt;p>(2)指令被发射队列选中&lt;/p>
&lt;p>(3)能够从寄存器,payload RAM或者旁路网络获得源操作数&lt;/p>
&lt;p>下图发射过程被分为了唤醒(wake-up)和仲裁(Select)两个流水线阶段&lt;/p>
&lt;p>唤醒阶段,发射队列中的所有相关寄存器会被置为准备好的状态&lt;/p>
&lt;p>仲裁阶段,会使用仲裁电路选择一条最合适的指令送到FU中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 357;
flex-basis: 857px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png" data-size="836x234">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036.png"
width="836"
height="234"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu13578928480996287574.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020130427036_hu15483047359496982778.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>tomasulo算法:在指令执行完才对相关指令进行唤醒&lt;/p>
&lt;p>可以通过将唤醒过程提前来获得更高性能&lt;/p>
&lt;p>即在指令A被仲裁电路选中后就对其他寄存器进行唤醒,这样指令B在下一个周期就能够被仲裁&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 267;
flex-basis: 643px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png" data-size="611x228">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465.png"
width="611"
height="228"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu12261158574036134191.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131005465_hu15538349812895092404.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>意思是 Select 和 wake-up应该是在同一个周期的串行,A被唤醒才能够去selectB&lt;/p>
&lt;p>这种操作称为&amp;quot;原子的&amp;quot;&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 210;
flex-basis: 504px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png" data-size="818x389">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841.png"
width="818"
height="389"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu14381474285825173627.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020131410841_hu7271168370352068712.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>拆分流水线可以使得主频升高,但是&lt;/p>
&lt;p>(1)分支预测失败,惩罚增加&lt;/p>
&lt;p>(2)cache访问的周期数增加&lt;/p>
&lt;p>(3)功耗增大&lt;/p>
&lt;p>以上是假设执行是一个周期,实际上并不止&lt;/p>
&lt;h3 id="数据捕捉结构的流水线">数据捕捉结构的流水线&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 237;
flex-basis: 568px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png" data-size="858x362">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404.png"
width="858"
height="362"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu7642558332426759119.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020132530404_hu738880975121771762.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以把select和payload放在同一个流水段 ,在指令被仲裁电路选中之后,在同一个周期对发射队列其他的指令进行唤醒,同时去读取payload RAM,这两个操作是并行进行的,在这个流水段还会负责payload RAM的读取和写入,会导致处理器的周期时间变得过大.&lt;/p>
&lt;p>旁路网络这样是啥意思????&lt;/p>
&lt;p>另一种设计方式是把payload单独放成一个流水段,旁路和执行分成两个流水段,在旁路阶段,FU的结果会被送到payload RAM和FU的输入端&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 241;
flex-basis: 579px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png" data-size="799x331">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478.png"
width="799"
height="331"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu15363317278529565932.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020134351478_hu3440636031536888040.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="分配">分配&lt;/h2>
&lt;p>对于非压缩的方式设计的发射队列,需要分配电路扫描整个发射队列,找到四个空闲的表项并将四条指令写入&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 111;
flex-basis: 268px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png" data-size="478x427">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425.png"
width="478"
height="427"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu915797298984400432.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140342425_hu13892753167635664755.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>
可以使用一个表格来记录所有空闲表项的编号,按照FIFO的方式管理,也可以简单把发射队列分为多个部分,每个段选一个空闲编号,但是会出现问题就是如果有一个表项非空的话,会阻碍其他指令的放入,甚至由于在寄存器重命名阶段是in-order状态A的无法放入会导致后续指令都无法放入&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 117;
flex-basis: 282px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png" data-size="529x450">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280.png"
width="529"
height="450"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu16173649002378560098.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020140649280_hu10959566968097053341.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="仲裁">仲裁&lt;/h2>
&lt;p>最好实现oldest-first功能的仲裁&lt;/p>
&lt;h3 id="1-of-m仲裁">1-of-M仲裁&lt;/h3>
&lt;p>可以通过指令在ROB中的位置作为指令的年龄信息,但是由于ROB是一个循环队列,所有单纯的地址是无法表征年龄的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 387;
flex-basis: 930px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png" data-size="834x215">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470.png"
width="834"
height="215"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu11734813543713119581.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143224470_hu2948785691697860533.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>其实我觉得,直接比较读写地址可以的吧,读指针 &amp;gt; 写指针 , 下新上旧 , 读指针 &amp;lt; 写指针 , 上新下旧 ,其实读指针 &amp;gt; 写的时候,也代表两者不是一面的&lt;/p>
&lt;p>可以在ROB中地址前面再加入一位,称为位置值.想当于对于读写地址又加了一位&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 83;
flex-basis: 199px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png" data-size="333x400">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564.png"
width="333"
height="400"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu8819546655997073234.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020143555564_hu10037926471509499272.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 121;
flex-basis: 292px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png" data-size="550x451">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180.png"
width="550"
height="451"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu12240918921388596847.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020201905180_hu6071650023988884185.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1)位置值相同时,ROB地址越小,对应的指令越旧&lt;/p>
&lt;p>(2)位置值不同时,ROB地址越大,对应的指令越旧,比方说情况2的 0 10 与 1 01 比较,明显是0 10 旧&lt;/p>
&lt;p>先根据是否rdy选出指令,再根据年龄进行筛选&lt;/p>
&lt;p>二分&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 385px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png" data-size="472x294">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467.png"
width="472"
height="294"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu15299360207959238160.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020202810467_hu12909387690140829006.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 128;
flex-basis: 307px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png" data-size="806x629">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042.png"
width="806"
height="629"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu1482760444792659261.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203048042_hu4089846200509570806.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>该电路能够得到最小的年龄值,但是还需要得到最小年龄值对应的指令,最方便的是将指令信息也一同附上去&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 145;
flex-basis: 350px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png" data-size="496x340">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063.png"
width="496"
height="340"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu10454207305702131865.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020203340063_hu4651879014994689033.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="n-of-m-仲裁电路">N of M 仲裁电路&lt;/h3>
&lt;p>几个FU共用一个发射队列,发射队列需要在一个周期内为没一个FU选择出一条指令,就要求有一个N of M的仲裁电路&lt;/p>
&lt;p>可以通过两级仲裁电路实现,第一级选择一条指令后对第二级进行标记,但是这样延时极大&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 172;
flex-basis: 414px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png" data-size="601x348">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330.png"
width="601"
height="348"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu14705004795844087432.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204057330_hu18352542851947980875.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对每一个FU使用一个1 of M的仲裁器, 根据指令类型进行分类,这样就会存在相同类型的指令会阻塞或者一部分FU处在空闲状态的问题&lt;/p>
&lt;p>可以通过增加FU的数量解决上述问题,但是比方数两个ALU,指令该分配给哪个ALU又是一个问题,可以通过轮换分配法实现,但是这样是无法保证严格的oldest-first原则的,而且有可能会浪费FU资源&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 268;
flex-basis: 645px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png" data-size="828x308">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711.png"
width="828"
height="308"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu5869953476708852689.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020204725711_hu13988473186677534807.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>一般来说,加减法,逻辑运算,移位运算合成一个FU,&lt;/p>
&lt;p>惩罚和除法合成一个,&lt;/p>
&lt;p>访问存储器和访问协处理器合并在一起,&lt;/p>
&lt;p>浮点运算合并在一起&lt;/p>
&lt;h2 id="唤醒">唤醒&lt;/h2>
&lt;h3 id="单周期的唤醒">单周期的唤醒&lt;/h3>
&lt;p>唤醒是指被仲裁器选中的指令将目的寄存器的编号(dst_tag)和发射队列中所有源寄存器的编号进行比较,并将那些比较结果相等的源寄存器进行标记的过程&lt;/p>
&lt;p>下面的电路是所有仲裁电路共享一个发射队列的情况, 所以发射队列只会接受到一个响应,因为同一时刻肯定只有一条指令被仲裁,每个FU都会使用一个仲裁电路&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 209;
flex-basis: 503px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png" data-size="881x420">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752.png"
width="881"
height="420"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu12195273095659706992.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020213306752_hu9126926194952235300.png 1024w"
loading="lazy"
alt="image-20241020213306752">
&lt;/a>
&lt;figcaption>image-20241020213306752&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>(1)ValL:指令中是否存在第一个源寄存器&lt;/p>
&lt;p>(2)SrcL:指令中第一个源寄存器的编号&lt;/p>
&lt;p>(3)RdyL:指令中第一个源寄存器是否已经被唤醒而处于准备好的状态&lt;/p>
&lt;p>(4)ValR:第二个&lt;/p>
&lt;p>(5)Dest:目的寄存器的编号&lt;/p>
&lt;p>(6)Issued:一条指令被仲裁电路选中之后,可能不会马上离开发射队列,需要进行标记,这样的指令不会向仲裁电路发出请求信号&lt;/p>
&lt;p>为什么有四个仲裁电路?????是不是指多个FU,但是多个FU不是应该可以接受多个请求&lt;/p>
&lt;p>发射队列的每一个表项都会根据四个响应信号的值,将自身的目的寄存器编号送到对应的总线上去,每个仲裁电路对应一个总线&lt;/p>
&lt;ol>
&lt;li>被仲裁电路选择的指令会将它的目的寄存器编号送到对应的总线上&lt;/li>
&lt;li>每一条总线的值会和发射队列中所有指令的源寄存器的编号进行比较,如果发现相等,标记为准备好的状态&lt;/li>
&lt;li>当发射队列某条指令的操作数都准备好了,并且没有被仲裁电路选中过,就可以想仲裁电路发送请求信号&lt;/li>
&lt;li>如果仲裁电路发现有更高优先级的指令发出请求,当前指令不会得到有效响应信号,需要再之后的周期继续发送请求信号.在一些设计中,可以轮流向多个仲裁电路发送请求.如果从仲裁电路中得到有效信号,就会吧issued置位.一条被选中的指令不会立刻离开发射队列,因为一个指令如果使用了load指令的结果,即使被仲裁电路选中,也不能离开&lt;/li>
&lt;li>发射队列的指令更具响应信号,,把目的寄存器编号送到对应总线上去,用来唤醒发射队列中所有相关的源寄存器&lt;/li>
&lt;/ol>
&lt;h3 id="多周期的唤醒">多周期的唤醒&lt;/h3>
&lt;p>单周期的唤醒能够在一个周期被FU执行完毕,但是当一条指令无法在一个周期执行完毕时,需要根据她在FU中的周期数,将唤醒过程延迟&lt;/p>
&lt;p>根据唤醒的过程&lt;/p>
&lt;h4 id="延迟广播">延迟广播.&lt;/h4>
&lt;p>发现被仲裁电路选中的指令执行周期大于1,则在选中的当前周期,不讲指令的目的寄存器编号送到总线上,而是根据选中指令需要执行的周期数(N),延迟N-1周期,才送到总线上去&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 490;
flex-basis: 1176px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png" data-size="838x171">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850.png"
width="838"
height="171"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu3236811294374040669.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020215810850_hu5826633055030736483.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>延迟广播之后可能出现tag bus产生冲突,比方说下面的MUL和ADD在同一时刻需要将目的寄存器的值送到tag broadcast bus上&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 290;
flex-basis: 696px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png" data-size="836x288">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829.png"
width="836"
height="288"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu16861531667843717354.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241020220227829_hu3627428205873869122.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以通过增加总线的数量,也可以利用表格,记录下FU执行指令所需要的周期数,被仲裁电路选中的指令,如果发现冲突,被选中的指令不会送到FU中执行,而是在下一个周期继续参与仲裁&lt;/p>
&lt;p>但是还是存在一个问题,就是指令B被否决(cycle 1),本身指令C是可以被仲裁的,但是C比B要新,所以这个周期被浪费掉了,所以可以先检查是否冲突,如果冲突的话就不向仲裁电路发起请求了(不发请求很奇怪啊,发请求在仲裁的时候否决行不行),但是这样访问网络和仲裁电路是串行的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 168;
flex-basis: 403px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png" data-size="580x345">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298.png"
width="580"
height="345"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu3250847906907956578.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021131316298_hu13178792662719264520.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="延迟唤醒">延迟唤醒&lt;/h4>
&lt;p>最优解就就是要去实现背对背执行,一条指令的执行和后一条指令的执行是先后的&lt;/p>
&lt;p>在比较结果相等时,不马上置为准备好的状态,而是根据指令所需要的执行周期数,进行相应周期的延时,然后再改变发射队列中源寄存器的状态&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 237;
flex-basis: 570px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png" data-size="632x266">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495.png"
width="632"
height="266"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu13815543178213961515.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133753495_hu9998523058420159875.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 408;
flex-basis: 979px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png" data-size="816x200">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852.png"
width="816"
height="200"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu12597106233390159010.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021133917852_hu3885520225871445685.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过移位寄存器实现延迟唤醒的效果.在解码阶段对每条指令执行周期数进行编码,称为DELAY,在将目的寄存器送到总线外,还需要将DELAY值也送到总线上去.称为DELAY bus .&lt;/p>
&lt;p>Freed :表项是否空闲&lt;/p>
&lt;p>Issued:指令是否被仲裁电路选择&lt;/p>
&lt;p>SrcL:第一个源寄存器编号&lt;/p>
&lt;p>SrcL_M:当寄存器编号比较结果相等时,置1;当接收到仲裁电路的响应信号后,清0,它是移位寄存器进行算数右移的使能标志&lt;/p>
&lt;p>SrcL_SHIFT:移位寄存器,当编号比较结果相等时,将DELAY写入移位寄存器,每周期进行算数右移&lt;/p>
&lt;p>Rdy:表示第一个源寄存器是否准备好了&lt;/p>
&lt;p>SrcR_imm_valid :表示第二个操作数是否是立即数&lt;/p>
&lt;p>ROB ID:指令在ROB的位置,使得其能够实现oldest-first选择&lt;/p>
&lt;p>编码形式是类似于11111000(8位),在经过3个算数右移之后最低位就是1,就是Rdy=1&lt;/p>
&lt;p>直到被仲裁电路响应或者说选择之后,SrcL_M,srcL_SHIFT都会清零,其他时候Rdy都会保持着1的状态发送请求,直到被仲裁&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 153;
flex-basis: 368px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046.png" data-size="847x552">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046.png"
width="847"
height="552"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046_hu3664706843096973520.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021142521046_hu17387076878035751376.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="推测唤醒">推测唤醒&lt;/h3>
&lt;p>对于某些指令,指令在FU中执行的周期数是可以被预测的,这样才可能分配一个确定的DELAY值&lt;/p>
&lt;p>但是对于&lt;/p>
&lt;p>(1)Load指令&lt;/p>
&lt;p>(2)某些处理器的特殊情况,例如RowerPC 603处理器存在early out,即当被除数值比较小时能够被提前预测指令&lt;/p>
&lt;p>比较简单的方法就是等指令执行完了之后再去唤醒其他指令&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 345;
flex-basis: 828px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731.png" data-size="787x228">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731.png"
width="787"
height="228"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731_hu13555257517852508750.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192837731_hu3376860337472421188.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>可以优化一下就是一般load指令在第一个周期计算地址,第二个周期访问Tag SRAM,第三个周期将读取到的数据写入目的寄存器,所以在第二个周期就可以判断,命中后去唤醒&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 304;
flex-basis: 730px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962.png" data-size="654x215">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962.png"
width="654"
height="215"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962_hu15428221746190009120.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192904962_hu17889552520785745816.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>假设d-cache是一直命中的,就能够得到一个比较理想的情况&lt;figure
class="gallery-image"
style="
flex-grow: 287;
flex-basis: 690px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840.png" data-size="633x220">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840.png"
width="633"
height="220"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840_hu15789197913931500280.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021192917840_hu5995376768543292965.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>但是一旦指令A发生了D-cache缺失,此时B就不能停住而等待操作数,这样会使得FU无法接受其他新指令,严重影响处理器的性能.最好的办法是将指令B重新放回发射队列(Issue Queue),因为load指令在D-cache缺失之后,会到L2 cache寻找数据,此时可以假设L2 cache是命中的,并按照命中时间重新对相关寄存器进行唤醒,还是使用延迟唤醒&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 244;
flex-basis: 587px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840.png" data-size="798x326">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840.png"
width="798"
height="326"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840_hu12103557051335753409.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241021210622840_hu10406948929904864418.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于不确定周期的指令,可以去预测指令执行的周期数,在指令得到结果之前,对相关的指令进行唤醒操作&lt;/p>
&lt;p>预测成功就执行,预测失败就去进行状态会被,被唤醒的所有寄存器需要重新设置为(not ready)状态,如果一些指令离开了发射队列,还需要从流水线中抹去,放回发射队列&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 283;
flex-basis: 681px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769.png" data-size="724x255">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769.png"
width="724"
height="255"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769_hu17984726890091083280.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/image-20241022113730769_hu12546290877630753377.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>未完待续&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>寄存器重命名(超标量+过程恢复)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</link><pubDate>Sat, 19 Oct 2024 11:46:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</guid><description>&lt;h2 id="超标量处理器的寄存器重命名">超标量处理器的寄存器重命名&lt;/h2>
&lt;p>对于 Dest = Src1 op ASrc2&lt;/p>
&lt;p>(1)从RAT中找到Src1和Src2对应的物理寄存器Psrc1和Psrc2&lt;/p>
&lt;p>(2)从空闲列表(Free list)中找到一个空闲的物理寄存器Pdest,将其作为指令的目的寄存器Dest对应的物理寄存器&lt;/p>
&lt;p>(3)将逻辑寄存器Dest和物理寄存器Pdest的映射关系写到RAT中&lt;/p>
&lt;p>RAT需要3个读端口(Src1,Src2和Dest作为地址) Dest这个端口用于和ROB进行交互,将之前的映射关系写入ROB中&lt;/p>
&lt;p>对于超标量,就需要成倍的端口&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 101;
flex-basis: 244px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468.png" data-size="542x533">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468.png"
width="542"
height="533"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468_hu9722805920825487102.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163241468_hu15333852949318292347.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 355;
flex-basis: 853px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413.png" data-size="491x138">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413.png"
width="491"
height="138"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413_hu8255966269358325669.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019163436413_hu10341188819607733508.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>(1) A,B存在RAW相关性 , 所以r0对应的物理寄存器之列来自于指令A对应的P30,不来自于从RAT读取的值&lt;/p>
&lt;p>(2)A,B,D存在WAW相关性,&lt;/p>
&lt;p>A.在写入RAT时,如果多条命令有同一个目标寄存器,那映射关系实际上写的还是最新的那条指令&lt;/p>
&lt;p>B.在将旧映射关系写入ROB的时候,如果发现一个周期内有多条指令都使用的同一个目的寄存器,此时写入到ROB中的旧映射关系不再来自于RAT读取的值,还是直接来自于和他存在WAW相关的指令,例如指令B的物理寄存器来自r0,或者所物理寄存器来自于P31&lt;/p>
&lt;p>(3)B,D存在WAR相关性,通过寄存器重命名可以客服&lt;/p>
&lt;h3 id="解决raw相关性">解决RAW相关性&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 225;
flex-basis: 542px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893.png" data-size="479x212">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893.png"
width="479"
height="212"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893_hu15093054276736074816.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019171311893_hu12400791209209954972.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>意思就是如果在同一周期进行寄存器重命名,对于源寄存器,应该获取当前赋值给目的寄存器的物理寄存器(P31),而不是之前的物理寄存器(P25),所以需要进行组内相关性检查,由于此时是顺序的,所以相关性检查和顺序处理器相似,只需要比较源寄存器与目的寄存器的编号就可以了&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 157;
flex-basis: 378px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923.png" data-size="671x426">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923.png"
width="671"
height="426"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923_hu2388780508683478430.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172619923_hu5401642006917474835.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 175;
flex-basis: 421px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946.png" data-size="700x399">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946.png"
width="700"
height="399"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946_hu10836408520997120333.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019172840946_hu14788717271551015671.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="解决waw相关性">解决WAW相关性&lt;/h3>
&lt;h4 id="对写rat进行检查">对写RAT进行检查&lt;/h4>
&lt;p>在寄存器重命名周期,如果存在多个指令的目的寄存器都相等的情况,那么只有最新的那条指令的映射关系才运行写入到RAT中 ,可以通过检查目标寄存器来实现,例如对于dst0只要和dst1,dst2,dst3中的任意一个存在相同的情况,就不需要将dst0对应的映射关系写到RAT中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 433px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453.png" data-size="649x359">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453.png"
width="649"
height="359"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453_hu17123479746391636632.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173408453_hu741281326496473227.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="对写rob进行检查">对写ROB进行检查&lt;/h4>
&lt;p>为了能够释放掉那些不再使用的物理寄存器,同时可以对处理器的状态进行恢复,每条指令需要从RAT中读出他以前对应的物理寄存器,并将其写到ROB当中,如果两条指令存在WAW,那么比较新的这条指令对应的就的物理寄存器就直接来自与比较旧的那条指令,而不是RAT中&lt;/p>
&lt;p>通过比较指令与前面指令的目的寄存器就可以实现&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 235;
flex-basis: 565px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215.png" data-size="471x200">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215.png"
width="471"
height="200"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215_hu14294549447914897059.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019173932215_hu11321073359892355193.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 152;
flex-basis: 366px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687.png" data-size="818x536">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687.png"
width="818"
height="536"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687_hu5261038282723109657.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019174347687_hu1035297534865978118.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="rat的sram结构">RAT的SRAM结构&lt;/h3>
&lt;p>读优先 : 当前写入的数据在下一个周期才能被读取&lt;/p>
&lt;p>写优先:当前写入的数据在当前数据就能够被读取&lt;/p>
&lt;p>对于RAT,需要做到先读,读完再修改,所以采取读优先&lt;/p>
&lt;p>对于读取目的寄存器,由于本来就要获取目的寄存器之前对应的物理寄存器,所以读优先是必须的&lt;/p>
&lt;p>对于读取源寄存器,其实需要得到新的映射,需要使用之前的RAW相关性的检查和处理电路&lt;/p>
&lt;h3 id="特殊情况的标记">特殊情况的标记&lt;/h3>
&lt;p>对于没有一个目标寄存器和两个源寄存器的指令,采取以下方式&lt;/p>
&lt;p>(1)根据需要重命名的目的寄存器个数,觉得当前周期需要从空闲列表读取数字的个数&lt;/p>
&lt;p>(2)使用目的寄存器读取RAT时,目的寄存器不存在的指令不会读取RAT&lt;/p>
&lt;p>(3)使用源寄存器读取RAT时,源寄存器不存在的指令不会读取RAT&lt;/p>
&lt;p>(4)在RAW和WAW相关性检查时,如果源寄存器和目的寄存器不存在,那就忽略&lt;/p>
&lt;h2 id="寄存器重命名的恢复">寄存器重命名的恢复&lt;/h2>
&lt;h3 id="使用checkpoint对rat进行恢复">使用checkpoint对RAT进行恢复&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 294;
flex-basis: 707px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227.png" data-size="820x278">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227.png"
width="820"
height="278"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227_hu9554526713186701756.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195538227_hu243255152380488361.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>SRAM的最小存储单元(Main Bit Cell,MBC), (Checkpoint Bit Cell ,CBC)&lt;/p>
&lt;p>当需要对RAT进行状态保存时,将MBC的内容复制到指定的CBC中(Allocation),当对RAT进行状态恢复时,将对应CBC的内容复制到MBC中(Restore)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 244;
flex-basis: 585px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542.png" data-size="747x306">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542.png"
width="747"
height="306"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542_hu12124988756168614648.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019195909542_hu3605033107495912464.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="使用walk对rat进行恢复">使用WALK对RAT进行恢复&lt;/h3>
&lt;p>对每一条指令,在ROB中都储存了这条指令之前对应的物理寄存器,利用这个信息,可以将RAT的状态逐步&amp;quot;倒回去&amp;quot;,使得那些处在错误路径上的指令,对RAT的修改都进行修复&lt;/p>
&lt;p>ROB中储存着物理寄存器,逻辑寄存器,之前的物理寄存器,一条一条回退到之前的物理寄存器,应该就可以做到&lt;/p>
&lt;h3 id="使用architecture-state对rat进行恢复">使用Architecture State对RAT进行恢复&lt;/h3>
&lt;p>在流水线提交阶段有一个RAT,,叫做aRAT(architecture RAT),它所保存的物理寄存器和逻辑寄存器的映射是完全正确的&lt;/p>
&lt;p>对于如下的指令,在重命名阶段的RAT,对于r1的映射应该是P34,但是实际上此时指令D是处在推测阶段,是有可能被冲刷掉的,但是对于aRAT,它保存的就是已经提交的指令之间的映射,例如R1对应P31,它的状态是完全正确的&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 311;
flex-basis: 748px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702.png" data-size="371x119">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702.png"
width="371"
height="119"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702_hu131409708023009198.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/image-20241019200728702_hu14698438627090399126.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>所以说,可以通过aRAT进行恢复,具体就是在分支预测失败时,让指令继续执行,直到分支指令变成最旧的一条指令,那此时所保存的状态就是分支指令之前的指令所得到的状态,再复制,就能够恢复了&lt;/p>
&lt;p>等到分支指令变到流水线最旧的指令,才恢复RAT的另一个好处就是,如果在一条分支指令之前存在异常或者另一个分支预测失败,那这条分支指令就不会被处理,也避免了一些无用功&lt;/p>
&lt;h3 id="分发">分发&lt;/h3>
&lt;p>(1) 发射队列 (out-of-order),指令在送到FU中被执行之前,先被放到一个缓存中,每个FU都对应一个发射队列,&lt;/p>
&lt;p>只要一条指令的所有源操作数都准备好了,就可以直接送到FU中执行,不用理会指令的原始顺序,在多发射处理器中,需要从缓存中找到多个空闲的表项&lt;/p>
&lt;p>(2)发射队列(in-order),分支指令和store指令是按照顺序执行的,该队列就是FIFO&lt;/p>
&lt;p>(3)重排序缓存(ROB),将乱序拉回顺序&lt;/p>
&lt;p>分发就是将寄存器重命名之后的指令写到发射队列和重排序队列当中&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>寄存器重命名(方式+映射表)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</link><pubDate>Fri, 18 Oct 2024 19:25:31 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>WAW 和 WAR (写后写 和读后写) 可以通过更换寄存器的名字来解决相应冲突&lt;/p>
&lt;h3 id="存在原因">存在原因&lt;/h3>
&lt;p>(1)有限个数的寄存器&lt;/p>
&lt;p>(2)循环体,很容易出现写后写冲突&lt;/p>
&lt;p>(3)代码重用,一些小函数被频繁的调用&lt;/p>
&lt;p>物理寄存器(Physical Register)和逻辑寄存器(Logical Register或者 architecture Register)物理寄存器数量多于逻辑寄存器&lt;/p>
&lt;p>重命名映射表 (Register Renaming Table, Register Alias Table ,RAT)空闲寄存器列表(Free Register List)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 142;
flex-basis: 342px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065.png" data-size="565x396">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065.png"
width="565"
height="396"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065_hu12948031862022571597.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018194219065_hu6665644479148694185.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="寄存器重命名的方式">寄存器重命名的方式&lt;/h2>
&lt;p>(1)将逻辑寄存器(architecture Register File,ARF)扩展来实现&lt;/p>
&lt;p>(2)使用统一的物理寄存器(Physical Register File,PRF)实现&lt;/p>
&lt;p>(3)使用ROB实现&lt;/p>
&lt;h3 id="rob">ROB&lt;/h3>
&lt;p>将ROB作为物理寄存器,存储所有**推测状态(speculative)**的结果,使用逻辑寄存器(ARF)存储所有正确的结果&lt;/p>
&lt;p>当一条指令被写入ROB中的一个表项(entry)时,表项的编号即为物理寄存器,这样将逻辑寄存器和表项建立了关系,&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 104;
flex-basis: 249px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542.png" data-size="520x500">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542.png"
width="520"
height="500"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542_hu17786506562862009958.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018200347542_hu13468767093701107792.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>ROB存储着所有没有离开流水线的指令结果,逻辑寄存器(ARF)存储着所有&amp;quot;最新&amp;quot;离开流水线的指令结果&lt;/p>
&lt;p>重命名映射表用来指示每一个逻辑寄存器的值是位于ROB中还是位于ARF中&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224.png" data-size="547x343">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224.png"
width="547"
height="343"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224_hu13515659451589263706.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018204416224_hu16314137865859507292.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="缺点">缺点&lt;/h4>
&lt;p>(1)即使没有目的寄存器也会占用ROB的一个表项,代表物理寄存器的浪费&lt;/p>
&lt;p>(2)对应ROB和ARF需要有多个读端口来支持多条指令的访问&lt;/p>
&lt;h3 id="arf扩展">ARF扩展&lt;/h3>
&lt;p>可以使用一个独立的存储部件来存储流水线中所有指令的结果,只有那些存在目的寄存器的指令才会占据该部件,称为 PRF(Physical Register File),PRF和ROB类似,只是在没有目标寄存器的指令不会占据PRF,寄存器重命名时存在目的寄存器的指令会占据PRF的空间,在退休时,结果会从PRF搬移到ARF中&lt;/p>
&lt;p>重命名映射表用来指示每一个逻辑寄存器的值是位于PRF中还是位于ARF中,需要保存PRF的地址空间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 174;
flex-basis: 417px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777.png" data-size="707x406">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777.png"
width="707"
height="406"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777_hu16404446892470360470.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018205336777_hu9368343665924381625.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="使用统一的prf">使用统一的PRF&lt;/h3>
&lt;p>存储所有推测的和正确的寄存器值,&lt;/p>
&lt;p>使用空闲列表记录PRF哪些寄存器处在空闲状态&lt;/p>
&lt;p>当指令被寄存器重命名,并且存在目的寄存器的时候,就会占据PRF当中的一个寄存器,该寄存器会经历值未被计算,值被计算但是没有退休,退休三个过程&lt;/p>
&lt;p>通过重命名映射表存储每个逻辑寄存器和物理寄存器的对应关系&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 281;
flex-basis: 676px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250.png" data-size="741x263">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250.png"
width="741"
height="263"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250_hu5765812971098335496.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018210442250_hu13651381351086792579.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>寄存器重命名时,&lt;/p>
&lt;p>源寄存器:查找重命名的映射表(RAT),找出对应物理寄存器的编号&lt;/p>
&lt;p>目的寄存器:给目的寄存器指定一个空闲状态的物理寄存器,并且该关系会被更新到RAT中&lt;/p>
&lt;p>指令退休之后释放物理寄存器&lt;/p>
&lt;p>一条指令之后在退休的时候,结果才会被外部看到,推测时是无法被外界看到的,需要使用另外一个RAT,存储所有&amp;quot;退休&amp;quot;状态的指令和物理寄存器的对应关系(啥时候释放?),外部只能通过查找这个RAT,找到逻辑寄存器对应的物理寄存器&lt;/p>
&lt;p>**只有后续的指令不使用物理寄存器之后,物理寄存器才能够变成空闲.**可以采取比较保守的方式,就是当一个指令和后面的莫条指令都写到同一个目的寄存器时,前面指令的物理寄存器可以释放了,**所以在ROB中除了记录逻辑寄存器当前对应的物理寄存器之外,还需要存储它之前对应的物理寄存器,**以便在指令退休的时候,将旧映射关系释放&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 462;
flex-basis: 1109px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285.png" data-size="587x127">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285.png"
width="587"
height="127"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285_hu9704412521937681004.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018212115285_hu16598331625486021963.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="优点">优点&lt;/h4>
&lt;p>(1)寄存器的值只需要被写入一次?&lt;/p>
&lt;p>(2)源寄存器的值只能存储在一个地方,即PRF中&lt;/p>
&lt;h2 id="重命名映射表rat">重命名映射表(RAT)&lt;/h2>
&lt;p>RAT是一个表格,使用逻辑寄存器作为地址寻址,对于指令的源寄存器,可以从表格中得到对应的物理寄存器的编号&lt;/p>
&lt;p>对指令的目的寄存器来说,会将物理寄存器编号写到这个表格,即建立映射关系&lt;/p>
&lt;p>可以使用多端口的SRAM(sRAT)和CAM(cRAT)实现,CAM(内容寻址的存储器)&lt;/p>
&lt;p>SRAM表项个数等于逻辑寄存器的个数,里面存放对应物理寄存器的编号,位宽为log(物理寄存器数量)&lt;/p>
&lt;p>CAM表项个数等于物理寄存器的个数,里面存放对应逻辑寄存器的编号,位宽为log(逻辑寄存器数量),寻址时逻辑寄存器的编号会和每个表项进行对比,返回对应的地址&lt;/p>
&lt;p>使用SRAM寻址功耗小,面积小&lt;/p>
&lt;p>由于对于cRAT进行checkpoint只需要保存状态位(V),而不需要将整个cRAT进行保存,能够大大减少checkpoint电路的面积,当checkpoint数量大时,反而cRAT具有优势&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 200;
flex-basis: 480px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733.png" data-size="801x400">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733.png"
width="801"
height="400"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733_hu11917421335245838524.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241018213712733_hu1566958612408089329.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="基于sram的重命名映射表">基于SRAM的重命名映射表&lt;/h3>
&lt;p>checkpoint需要把整个sRAT都保存下来&lt;/p>
&lt;p>对于4-way的超标量处理器,每周期最多需要对四条指令进行寄存器重命名,sRRAT需要8个读端口和4个写端口(每条指令包含2个源寄存器和1个目的寄存器)&lt;/p>
&lt;p>新写入到sRAT的值会覆盖掉原来旧的对应关系,需要记录下来&lt;/p>
&lt;p>(1)方便指令在退休的时候,将对应的物理寄存器变为空闲状态???? (&lt;del>还是无法理解,按理来说覆盖了说明该逻辑寄存器又分配了新的物理寄存器,那原来那个确实可以删除了&lt;/del>)(覆盖的时候后面的指令还没有退休,是有可能无效的(分支失败异常之类的,那后面分配的必定是要被还原的,所以物理寄存器是应该在后面指令退休的时候再变成空闲状态))&lt;/p>
&lt;p>(2)当一条指令之前存在异常或者分支预测失败时,需要从流水线中被抹去 ,同时这条指令对于RAT的修改需要被恢复过来,通过将旧的映射关系保存下来,可以协助RAT的修复&lt;/p>
&lt;p>缺点就是无法使用多的checkpoint&lt;/p>
&lt;p>只要预测的足够准,就不怎么需要checkpoint ,就可以去减少checkpoint的数量,但是如果预测错了又没有checkpoint,那对于RAT的恢复也会很麻烦&lt;/p>
&lt;p>??? RAT里面的值不是应该也是保存在ROB里的吗,那保存ROB不就行了,为什么还要RAT&lt;/p>
&lt;h3 id="基于cam的重命名映射表">基于CAM的重命名映射表&lt;/h3>
&lt;p>任意时刻,每个逻辑寄存器都只有一个物理寄存器与之对应,可以使用一个有效位(V)表示&lt;/p>
&lt;p>cRAT需要8个读端口和4个写端口(每条指令包含2个源寄存器和1个目的寄存器)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 136;
flex-basis: 328px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693.png" data-size="427x312">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693.png"
width="427"
height="312"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693_hu13747216310678279473.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019105549693_hu9494608413689815968.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>SRAM + CAM ,SRAM用来存储每个物理寄存器对应的逻辑寄存器,CAM用来进行内容的比较&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 104;
flex-basis: 249px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724.png" data-size="436x419">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724.png"
width="436"
height="419"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724_hu9710394290090467635.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019110223724_hu9996034423044171934.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>需要等到后面写入到同一个逻辑寄存器的指令退休(retire)的时候,才可以将这个逻辑寄存器之前对应的物理寄存器变为空闲状态&lt;/p>
&lt;p>并不是一个物理寄存器对应的有效位为0,就表示物理寄存器是空闲状态,有可能是这个映射关系刚刚被覆盖了.通过使用ROB和空闲列表可以管理物理寄存器何时变为空闲&lt;/p>
&lt;p>在分支指令寄存器重命名之前,将cRAT的有效位保存起来;在流水线的后续阶段,发现分支指令预测失败是,将分支指令对应的checkpoint写回到cRAT的有效位就完成恢复了(why?这样能保证恢复映射关系?)&lt;/p>
&lt;p>恢复时可能把一些本身处在非空闲状态的物理寄存器变成了空闲状态,因为非空闲状态的物理寄存器有效位也可以是0&lt;/p>
&lt;p>有可能在进行checkpoint保存的时候为0,到了状态恢复的时候变成1了.典型情况是物理寄存器在变为空闲之后又被新的指令使用了.但是该指令处在分支预测失败或者异常路径上.应该是要恢复为0的&lt;/p>
&lt;h4 id="举例">举例&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 121;
flex-basis: 291px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359.png" data-size="250x206">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359.png"
width="250"
height="206"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359_hu1962377548689383665.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112218359_hu12246078549466636233.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>在指令F进行寄存器重命名时,需要对cRAT进行Checkpoint保存&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 198;
flex-basis: 477px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099.png" data-size="742x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099.png"
width="742"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099_hu17598209733909211804.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019112714099_hu1293636208337311542.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>分支F被发现了分支预测失败,对cRAT进行状态恢复前 ,在F解码时,就保存了此时的状态,所以如果预测失败写回,就直接恢复了那之前的表&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 172;
flex-basis: 415px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106.png" data-size="749x433">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106.png"
width="749"
height="433"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106_hu11760825212501167464.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/image-20241019113041106_hu9948112582823394189.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>每次在流水线的寄存器重命名阶段遇到分支2指令时,都会从表7.2找出一个空闲的GC来存储此时的有效位(V),并将GC的编号放在分支指令的信息中,这样当得到分支预测的结果之后,就可以根据编号来找到与之对应的GC.在分支预测失败之后直接进行相应的复原&lt;/p>
&lt;p>为了保证正确性,在分支预测失败进行恢复的时候,需要对空闲列表(free list)也进行状态恢复,那些别占用的物理寄存器都将重新变为空闲的状态(通过恢复free list的读指针)&lt;/p>
&lt;p>对cRAT进行状态恢复,就是要还原出逻辑寄存器真正对应的物理寄存器,因为会续分支预测失败路径上的指令可能会修改对应关系,需要进行纠正.对于物理寄存器的空闲管理交给ROB和free list&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>分支预测(目标地址预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</link><pubDate>Wed, 16 Oct 2024 18:26:42 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</guid><description>&lt;h2 id="分支预测的目标地址预测">分支预测的目标地址预测&lt;/h2>
&lt;p>对于直接跳转的分支指令,由于它的偏移值(offset)是以立即数的形式固定在指令中,目标地址是固定的,只需要记录分支指令的目标地址即可.&lt;/p>
&lt;p>对于间接分支跳转,大部分是CALL和Return ,所以可以进行一定程度的预测&lt;/p>
&lt;h3 id="直接跳转类型的分支预测">直接跳转类型的分支预测&lt;/h3>
&lt;p>(1)当分支指令不发生跳转时,&lt;/p>
&lt;p>目标地址 = 当前分支指令的PC值 + Sizeof(fetch group)&lt;/p>
&lt;p>(2)当发生跳转时&lt;/p>
&lt;p>目标指令 = 当前分支指令的PC值 + Sign_Eextend(offset)&lt;/p>
&lt;h4 id="btb">BTB&lt;/h4>
&lt;p>通过BTB(Branch Target Buffer)(相当于一个cache)使得多个PC值共用一个空间来存储目标地址,&lt;/p>
&lt;p>index + tag ,&lt;/p>
&lt;p>BTA (Branch Target Address)分支目标地址&lt;/p>
&lt;p>可以使用组相联的BTA来提高分支预测的准确率&lt;/p>
&lt;p>如果已经被替换了,那该跳哪去 : 先跳再冲刷吗?&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 386px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711.png" data-size="856x532">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711.png"
width="856"
height="532"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711_hu7374757969364877266.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185417711_hu6804283647297828377.png 1024w"
loading="lazy"
alt="image-20241016185417711">
&lt;/a>
&lt;figcaption>image-20241016185417711&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="partial-tag-btb">partial-tag BTB&lt;/h5>
&lt;p>如果映射到BTB中的指令中只有一条,那可以简化tag的部分,只使用很小的一部分,&lt;/p>
&lt;p>这种方法实际上也是在赌,减少了tag的大小,万一出现了重合,那就会出现目标地址预测失败的情况,但实际上,如果出现了重合,即使不减少tag,仍然会导致预测失败.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 302;
flex-basis: 726px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818.png" data-size="778x257">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818.png"
width="778"
height="257"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818_hu17713719676223318284.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016185852818_hu2386597830981386302.png 1024w"
loading="lazy"
alt="image-20241016185852818">
&lt;/a>
&lt;figcaption>image-20241016185852818&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>和之前类似,仍然可以采取一定运算,来降低tag的位数,比方说异或&lt;/p>
&lt;p>&lt;del>我比较好奇,如果tag没有对上,对于直接相连来说,本身也无法得到正确地址,那为什么不直接把tag删除了&lt;/del>&lt;/p>
&lt;p>应该是组相联有用吧&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 235;
flex-basis: 565px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007.png" data-size="551x234">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007.png"
width="551"
height="234"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007_hu17591383904736463039.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016190929007_hu1099906551913900448.png 1024w"
loading="lazy"
alt="image-20241016190929007">
&lt;/a>
&lt;figcaption>image-20241016190929007&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="btb缺失的处理">BTB缺失的处理&lt;/h4>
&lt;h5 id="停止执行">停止执行&lt;/h5>
&lt;p>暂停取指,直到目标地址被计算出来&lt;/p>
&lt;p>对于直接跳转指令,在解码阶段就可以分离出偏移值&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 181;
flex-basis: 436px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026.png" data-size="491x270">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026.png"
width="491"
height="270"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026_hu6458134045906799705.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192302026_hu15515489183902377947.png 1024w"
loading="lazy"
alt="解码阶段分离指令">
&lt;/a>
&lt;figcaption>解码阶段分离指令&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>停止取指会造成气泡,其实就是导致流水线停滞&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 282;
flex-basis: 677px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520.png" data-size="725x257">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520.png"
width="725"
height="257"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520_hu17955641935330878257.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016192510520_hu10501807876583559370.png 1024w"
loading="lazy"
alt="image-20241016192510520">
&lt;/a>
&lt;figcaption>image-20241016192510520&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="继续执行">继续执行&lt;/h5>
&lt;p>使用顺序的PC值去指令&lt;/p>
&lt;p>计算出的地址和原来PC不一致,就冲刷流水线,重新开始取指&lt;/p>
&lt;p>这么做会浪费功耗&lt;/p>
&lt;h3 id="间接跳转类型的分支预测">间接跳转类型的分支预测&lt;/h3>
&lt;h4 id="callreturn-指令的分支预测">CALL/Return 指令的分支预测&lt;/h4>
&lt;p>CALL的地址一般也是固定的,所以也可以通过BTB进行预测&lt;/p>
&lt;p>Return的目标地址是不固定的,但是Return的目标地址总是等于最近一次执行的&lt;/p>
&lt;p>但是Return指令的目标地址,是按照CALL指令执行的相反顺序排列的&lt;/p>
&lt;p>所以可以做一个存储器,保存最近执行的CALL指令的下一条指令的地址,这个存储器是后进先出的(Last In First Out,LIFO),原理与堆栈类似,称为返回地址堆栈(Return Address Stack,RAS)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 249;
flex-basis: 599px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006.png" data-size="809x324">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006.png"
width="809"
height="324"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006_hu5781072421816679016.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202107006_hu16507365381751537198.png 1024w"
loading="lazy"
alt="CALL/Return 指令分支预测">
&lt;/a>
&lt;figcaption>CALL/Return 指令分支预测&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="ras工作条件">RAS工作条件&lt;/h5>
&lt;p>(1)需要及时保存PC + 4的值, 指令类型只有在解码阶段才能获知,因此可以在BTB中多加一项来保存分支指令的类型,这样在后续取到这一条指令就可以获知分支指令类型&lt;/p>
&lt;p>(2)在对Return指令进行目标地址预测是,能够选择RAS的数据,而非BTB的数据,按照上面的方法就可以做到&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 258;
flex-basis: 621px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233.png" data-size="492x190">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233.png"
width="492"
height="190"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233_hu508193164438520474.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016202620233_hu1108834045841803893.png 1024w"
loading="lazy"
alt="将指令类型存储到BTB中">
&lt;/a>
&lt;figcaption>将指令类型存储到BTB中&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="ras满了">RAS满了&lt;/h5>
&lt;p>如果函数层次过深,就会出现RAS无法继续存放的问题&lt;/p>
&lt;p>(1)不保存CALL了,这样下一次Return 就会出现分支预测失败,并且还要求RAS指针不发生改变&lt;/p>
&lt;p>(2)继续按照顺序向RAS写入,此时最旧的会被覆盖掉.最后一次return 可能会出现分支预测失败,但是也是可能性事件,比方说递归函数&lt;/p>
&lt;p>可以通过带计数器的RAS来扩展RAS的容量, 即对于相邻的CALL,如果是同一条指令,就存放在RAS的同一个地址,再用计数器进行标识&lt;/p>
&lt;h4 id="其他指令的预测">其他指令的预测&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 131;
flex-basis: 316px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224.png" data-size="227x172">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224.png"
width="227"
height="172"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224_hu6984012436561300078.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016203614224_hu9987043498051736602.png 1024w"
loading="lazy"
alt="case指令">
&lt;/a>
&lt;figcaption>case指令&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 291;
flex-basis: 699px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293.png" data-size="711x244">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293.png"
width="711"
height="244"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293_hu5286439124904148354.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210205293_hu16493922937992861016.png 1024w"
loading="lazy"
alt="image-20241016210205293">
&lt;/a>
&lt;figcaption>image-20241016210205293&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>使用基于局部历史的分支预测方法,把PHT换成了Target Cache,&lt;/p>
&lt;p>每当分支指令执行一次,就将目标地址写到Target Cache 中&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>分支预测使用 BHR , GHR和饱和计数器配合进行分支指令方向的预测&lt;/p>
&lt;p>使用 BTB, RAS和 Target Cache对分支指令的目标地址进行预测&lt;/p>
&lt;p>完整的分支预测方法 , decoupled BTB : 将分支指令的方向预测独立于BTB ,本身不会被记录到BTB的分支指令也会被记录(&lt;del>不跳转的分支也会记录到BTB&lt;/del>)&lt;/p>
&lt;p>预测为发生跳转,但是发生了BTB缺失,比发生分支预测失败的情况好,可以节省功耗&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 101;
flex-basis: 243px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326.png" data-size="525x517">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326.png"
width="525"
height="517"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326_hu15660941589493918871.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241016210627326_hu4393141796266973765.png 1024w"
loading="lazy"
alt="完整的分支预测方法">
&lt;/a>
&lt;figcaption>完整的分支预测方法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="分支预测失败的恢复">分支预测失败的恢复&lt;/h2>
&lt;p>处在错误路径上的指令有可能已经将处理器中某个部位的内容进行了更改,例如寄存器重命名阶段的重命名映射表(mapping table),需要对操作进行撤销,即分支预测失败时的恢复&lt;/p>
&lt;h3 id="分支预测检查">分支预测检查&lt;/h3>
&lt;p>(1) 解码阶段可以检查直接跳转的正确性,可以得到分支指令的方向和目标地址,&lt;/p>
&lt;p>对于间接跳转,即使得知预测错误,也无法得到正确的地址,但是可以通过流水线暂停来避免抹掉指令造成的功耗浪费&lt;/p>
&lt;p>(2)在读取物理物理寄存器的阶段,读取到寄存器的值,就可以得到目标地址是否错误,进行重新取指令,&lt;/p>
&lt;p>还是需要对不必要的指令进行抹去,对于进入发射队列的指令,可能比较困难,需要选择性的进行抹去&lt;/p>
&lt;p>(3)在执行阶段,任何分支指令的结果都可以被计算出结果,可以进行检查,但是造成的惩罚(penalty)是最大的.需要清除在这条分支指令之后进入流水线的所有数据&lt;/p>
&lt;h3 id="基于rob的恢复">基于ROB的恢复&lt;/h3>
&lt;p>在乱序执行中,在这条分支指令之前的数据也会在发射队列或者执行中,可以采取重排序缓存(ROB)对处理器进行状态恢复 (ROB是顺序存储指令的)&lt;/p>
&lt;p>当发生分支指令预测失败时,将信息记录在ROB对应的表项(entry)中,并且暂停流水线的取指令,但是让流水线继续执行,当这条指令变为最旧的指令后,冲刷掉流水线中的所有数据,重新取指令. 缺点就是停滞时间会比较长.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 168;
flex-basis: 404px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348.png" data-size="627x372">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348.png"
width="627"
height="372"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348_hu6633562508414504632.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017201150348_hu17435496857645374288.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="基于checkpoint的状态恢复">基于checkpoint的状态恢复&lt;/h3>
&lt;p>checkpoint, 发现分支指令,并且在分支指令之后的指令更改处理器的状态之前,将处理器的状态保存起来,包括寄存器重命名中使用的映射表(mapping table),预测跳转的分支指令对应的下一条指令的PC等.在寄存器重命名阶段进行.&lt;/p>
&lt;p>需要将流水线中所有处于分支预测失败路径上的指令抹去. 需要一种机制识别哪些指令处在错误的路径上,可以通过编号实现,(编号可以在顺序阶段就编号完成),编号之后就可以获知哪些指令位于分支指令后面&lt;/p>
&lt;p>分支指令的编号个数决定了最多可以在流水线中存在的分支指令个数:假设处理器中最多支持128条指令存在于流水线中,按照每五条指令存在一条分支,最多后128/5 = 26 条分支指令存在与流水线中,需要5位&lt;/p>
&lt;p>所有在流水线中的分支指令会被分配一个编号值,编号会被保存在FIFO中,称为编号列表(tag list)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 348;
flex-basis: 836px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101.png" data-size="680x195">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101.png"
width="680"
height="195"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101_hu1585711271151754337.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017203357101_hu6318652637317940402.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>
可以使用 (free tag list 和 tag list)来进行设计&lt;/p>
&lt;p>编号值不再被使用 : 分支指令成功retire , 分支预测失败 (分支预测失败之后就要根据编号来冲刷流水线了,所有编号可以回收了)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 152;
flex-basis: 365px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005.png" data-size="709x466">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005.png"
width="709"
height="466"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005_hu2549951271718018092.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017210139005_hu616055593929496326.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h4 id="流水线抹去">流水线抹去&lt;/h4>
&lt;p>(1)发射之前的所有指令需要全部被抹去&lt;/p>
&lt;p>(2)流水线的发射阶段以及之后的流水段中,使用比寻找分支指令之后的指令全部抹去&lt;/p>
&lt;p>tag list 是顺序保存对应标号的 , 所以 比方说监测到分支指令3 预测失败,所以 0 ,1, 4 都需要被直接清除 , 因此通过广播编号值及将ROB中对应的指令置为无效&lt;/p>
&lt;p>一个周期内使用所有编号去抹去ROB的指令是不现实的,可以采取一个周期广播一个编号的方式 , 因为从取指到发射还是需要经过几个周期的,只要在这之前重排序缓存和发射队列指令被抹去了就行了&lt;/p>
&lt;p>编号值在解码阶段分配最合适 ,因为此时已经知道属于分支指令了&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 211;
flex-basis: 508px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101.png" data-size="830x392">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101.png"
width="830"
height="392"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101_hu15410874502044149990.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017212325101_hu9376489831608965537.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>对于多条分支指令,通过控制第二条分支指令及其后面的所有指令在本周期不能进入解码阶段,可以避免使用多端口的FIFO来进行赋值&lt;/p>
&lt;h4 id="ptab-prediction-target-address--buffer">PTAB (Prediction Target Address Buffer)&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 284;
flex-basis: 683px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287.png" data-size="820x288">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287.png"
width="820"
height="288"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287_hu16483625173512044034.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241017214408287_hu641169617317350030.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>通过将分支指令的预测值保存到一个缓存中,使得其在执行阶段进行分支预测是否正确的检查时能够正确调用,并且可以只保存方向预测为跳转的分支指令 PTAB , (Prediction Target Address Buffer)&lt;/p>
&lt;p>&lt;del>它不是本身就在BTB中吗,为啥还要一个buffer&lt;/del>&lt;/p>
&lt;p>(1)valid , 表示PTAB中某个表项是否被占用, 当分支指令写入PATB时,置1,当完成检查之后,Reset&lt;/p>
&lt;p>(2)Predict Address,分支指令被预测的目标地址&lt;/p>
&lt;p>(3)Next PC, 分支指令的下一条PC , 如果预测错误,就直接使用其作为正确地址取指&lt;/p>
&lt;p>怎么去找PTAB对应的表项 ? 用 PC吗 ? 或者说用 Next PC吗&lt;/p>
&lt;p>写PTAB可以在取指阶段就完成&lt;/p>
&lt;p>自修改代码一般都会去清空分支预测器和I-Cache&lt;/p>
&lt;h2 id="超标量处理器的分支预测">超标量处理器的分支预测&lt;/h2>
&lt;p>由于超标量取一个地址,会取出多条指令,所以如果只使用取指令时的地址进行分支预测,相当于只是对指令你个组中的第一条指令进行分支预测&lt;/p>
&lt;p>可以使用公共地址寻址分支预测器 (对于4-way超标量处理器[31:4]),因为多数情况下,实际只有一条分支指令 .在BTB中需要记录下分支指令在四条指令中的位置,避免错误使用它的结果 (为什么指令会出现非对齐存储?)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 202;
flex-basis: 485px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971.png" data-size="457x226">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971.png"
width="457"
height="226"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971_hu9999926450411402190.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163144971_hu11458907609099289698.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 151;
flex-basis: 363px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518.png" data-size="824x544">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518.png"
width="824"
height="544"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518_hu6574895480496477885.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018163913518_hu7626835333107781858.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h3 id="目标地址的预测">目标地址的预测&lt;/h3>
&lt;p>要对指令组的所有指令进行分支预测,需要得到所有指令的PC值,需要使用3个加法器实现PC地址的获取,&lt;/p>
&lt;p>但是由于需要同时获取四个PC值对应的目标地址,需要BTB支持四个读端口,即使采用交疊避免真正的多端口,但是硬件利用率还是较低&lt;/p>
&lt;p>在分支指令的方向预测完毕之后,利用结果信息再进行目标地址的预测,可以避免对于BTB部件的多端口需求,,这种方法对于方向预测和目标地址预测是串行的&lt;/p>
&lt;p>对于RISC指令,大多数指令是直接跳转类型,目标地址无需预测,在取指之后实际就可以被计算出来.实现这样的功能需要进行预解码&lt;/p>
&lt;h3 id="目标方向的预测">目标方向的预测&lt;/h3>
&lt;p>对于基于局部历史的分支预测方法来说,需要PHT和BHT支持多个读端口,可以通过交疊(interleaving)模拟实现多端口&lt;/p>
&lt;p>对于全局历史的分支预测,由于一个周期内进行分支预测的多条指令对应的GHR是不同的,需要进行特殊的处理&lt;/p>
&lt;p>交疊 : 7位地址Addr[6:0],通过Addr [1:0]进行寻址bank ,通过Addr[6:2]寻址bank对应的内容 ,就是使用多个单端口的存储器去组成多端口的功能&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 180;
flex-basis: 432px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926.png" data-size="811x450">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926.png"
width="811"
height="450"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926_hu1473716903533949269.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/image-20241018191051926_hu1420717281721194343.png 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>分支预测(概述+方向预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</link><pubDate>Tue, 15 Oct 2024 14:08:47 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;h3 id="分支预测需要的内容">分支预测需要的内容&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>方向，决定跳转与否&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标地址 决定跳转的目的地，riscv中有两种体现形式&lt;/p>
&lt;p>PC + 立即数，跳转范围受限。&lt;/p>
&lt;p>寄存器跳转，预测风险难度高，但是除了RETURN/CALL,一般建议不使用间接跳转。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="分支预测的解码">分支预测的解码&lt;/h3>
&lt;p>快速分辨出哪条指令是分支指令&lt;/p>
&lt;p>I-cache得出结果可能需要多个周期，这些周期无法得到准确的预测结果&lt;/p>
&lt;p>解码+分支预测放在一个周期 ， 严重影响周期时间&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 205;
flex-basis: 494px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234.png" data-size="768x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234.png"
width="768"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234_hu5012368611020013998.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015143633234_hu8871877114348964777.png 1024w"
loading="lazy"
alt="快速解码">
&lt;/a>
&lt;figcaption>快速解码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;del>可以在指令从L2 cache 写入到I-cache时进行快速解码,(pre-decode),然后将指令否是分支的信息也写入I-cache.&lt;/del>&lt;/p>
&lt;p>分支预测的最好时机是在当前周期得到去指令地址的时候&lt;/p>
&lt;p>可以直接通过PC值来进行分支预测，那就不需要进行解码了，但是只能够知道它是分支指令&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 220;
flex-basis: 530px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072.png" data-size="773x350">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072.png"
width="773"
height="350"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072_hu10962105718784769920.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015153115072_hu3395612283536332007.png 1024w"
loading="lazy"
alt="pc分支预测">
&lt;/a>
&lt;figcaption>pc分支预测&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="分支预测的方向预测">分支预测的方向预测&lt;/h2>
&lt;p>跳转 （taken)和不发生跳转（not token）&lt;/p>
&lt;h3 id="一bit的跳转预测">一bit的跳转预测&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 290;
flex-basis: 697px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711.png" data-size="517x178">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711.png"
width="517"
height="178"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711_hu3772473742952120499.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182744711_hu6029973878094252562.png 1024w"
loading="lazy"
alt="image-20241015182744711">
&lt;/a>
&lt;figcaption>image-20241015182744711&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="基于两位饱和计数器2-bit-saturating-counter">基于两位饱和计数器（2-bit saturating counter)&lt;/h3>
&lt;p>根据分支前两次的结果预测下一次的结果&lt;/p>
&lt;h4 id="状态机">状态机&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 301;
flex-basis: 723px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601.png" data-size="654x217">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601.png"
width="654"
height="217"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601_hu6329958502138823409.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015182911601_hu5922628540263514478.png 1024w"
loading="lazy"
alt="基于两位饱和计数器">
&lt;/a>
&lt;figcaption>基于两位饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>（1）计数器处于饱和状态，分支指令本次被预测发生跳转&lt;/p>
&lt;p>（2） 计数器处于不饱和状态，分支指令预测发生跳转&lt;/p>
&lt;p>（3） 计数器处于不饱和状态，分支指令预测不发生跳转&lt;/p>
&lt;p>（4） 计数器处于饱和状态，分支指令被预测不发生跳转&lt;/p>
&lt;p>初始状态位于 strongly not taken 或者 weakly not taken&lt;/p>
&lt;p>状态机处于饱和状态，只有两次预测失败才会改变预测的结果&lt;/p>
&lt;p>对于以下的情况，该种方法能够有50%的成功预测率&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 328;
flex-basis: 787px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299.png" data-size="279x85">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299.png"
width="279"
height="85"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299_hu12330989491748176683.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015184801299_hu10712615227853934463.png 1024w"
loading="lazy"
alt="image-20241015184801299">
&lt;/a>
&lt;figcaption>image-20241015184801299&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>TTNTNTNTNT 对于这种情况，预测还是有问题，就是始终进入不了饱和，那还是相当于1bit&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431.png" data-size="632x397">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431.png"
width="632"
height="397"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431_hu1672855586108714933.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015190708431_hu15441497882329938705.png 1024w"
loading="lazy"
alt="另外两种预测方法">
&lt;/a>
&lt;figcaption>另外两种预测方法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>情况1是如果两次连续的跳转，就直接变成饱和的强跳转，那就需要两次不跳转才能预测为不跳转&lt;/p>
&lt;p>情况2是如果两次连续的不跳转，就直接变成饱和的不跳转，那就需要两次跳转才能预测为跳转&lt;/p>
&lt;p>利用格雷码降低功耗，减少出错的概率&lt;/p>
&lt;p>对于一般的for循环，TTTTTTTTTTTTTTN ,只会出现2次预测失败 ，开始时 weakly not taken , 当再次执行for循环，第一次就会预测成功&lt;/p>
&lt;h4 id="存储方式">存储方式&lt;/h4>
&lt;p>每一个PC需要一个两位的饱和计数器， 32 位 PC需要 2^30 * 2b 存储器 ， 使用如下方法存储（PHT（Pattern History Table））: 使用 PC的一部分进行存储&lt;/p>
&lt;h5 id="别名-aliasing">别名 （aliasing)&lt;/h5>
&lt;p>不同PC有相同的饱和计数器，导致相互之间的干扰&lt;/p>
&lt;p>中立别名 ： 分支指令的方向一致&lt;/p>
&lt;p>破坏性别名 ： 分支指令的方向不一致&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 225;
flex-basis: 540px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722.png" data-size="655x291">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722.png"
width="655"
height="291"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722_hu9221241697137903403.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015192528722_hu5725581828526846841.png 1024w"
loading="lazy"
alt="使用PC值的一部分来寻址饱和计数器">
&lt;/a>
&lt;figcaption>使用PC值的一部分来寻址饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 189;
flex-basis: 454px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012.png" data-size="563x297">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012.png"
width="563"
height="297"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012_hu2951182150190756820.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194600012_hu16224992082934435296.png 1024w"
loading="lazy"
alt="image-20241015194600012">
&lt;/a>
&lt;figcaption>image-20241015194600012&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="避免别名的方法--哈希表">避免别名的方法 —— 哈希表&lt;/h5>
&lt;p>哈希表能够压缩32位PC到一个比较小的值&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 196;
flex-basis: 472px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893.png" data-size="553x281">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893.png"
width="553"
height="281"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893_hu15927042566795541290.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241015194955893_hu8702642689007638371.png 1024w"
loading="lazy"
alt="image-20241015194955893">
&lt;/a>
&lt;figcaption>image-20241015194955893&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>更新时间点&lt;/p>
&lt;p>（1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新PHT 预测的结果更新PHT肯定不合理&lt;/p>
&lt;p>（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新PHT&lt;/p>
&lt;p>（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新PHT&lt;/p>
&lt;p>对于2,3，分支指令可能在PHT更新之前就被取过很多次了，会影响结果，但是影响的不多&lt;/p>
&lt;p>在乱序执行中，即使在执行阶段得到了一条分支指令的结果，也无法保证该结果是正确的，因为分支指令可能位于分支预测失败的路径上，所以（3）是最保险的&lt;/p>
&lt;p>顺序执行不会吗 ？ 不会 ，主要是乱序执行有可能前面的指令后于后面指令的执行 ，这样后面的指令不一定会执行&lt;/p>
&lt;h3 id="基于局部历史的分支预测">基于局部历史的分支预测&lt;/h3>
&lt;p>BHR(Branch History Register):分支历史寄存器&lt;/p>
&lt;p>通过一个寄存器记录一条分支指令在过去的历史状态&lt;/p>
&lt;p>n位BHR记录n次结果&lt;/p>
&lt;p>BHR和PHT一一对应，BHR有多少种取值，PHT有多少表项（entry)&lt;/p>
&lt;p>结果从BHR右侧移入，对应的BHR值改变对应的PHT&lt;/p>
&lt;p>那就相当于把一个PC对应的表项有进行了细分 -&amp;gt; 一个BHR和多个PHT&lt;/p>
&lt;p>如果一个序列，连续相同的数有p位，则虚了的循环周期为p,只要BHR不小于p,就可以做完美预测&lt;/p>
&lt;h4 id="寻址">寻址&lt;/h4>
&lt;p>将所有分支指令的BHR组合在一起称为分支历史寄存器表(Branch History Register Table,BHT)&lt;/p>
&lt;p>如果进行全寻址的话 ， 1个PC值 需要 N位BTR + 2^N * 2 位PHT , 2^n 就需要 2^n（ N + 2^N * 2）&lt;/p>
&lt;p>所以需要PC部分值来寻址&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 238;
flex-basis: 571px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253.png" data-size="629x264">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253.png"
width="629"
height="264"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253_hu9089512783516302460.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016102002253_hu16056882700841532627.png 1024w"
loading="lazy"
alt="image-20241016102002253">
&lt;/a>
&lt;figcaption>image-20241016102002253&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>1个PHT&lt;/strong>&lt;/p>
&lt;p>PC部分值寻址PHT,PC通过hash处理寻址BHT&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 159;
flex-basis: 382px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339.png" data-size="581x365">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339.png"
width="581"
height="365"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339_hu16419308451831036941.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104245339_hu17376103308489953844.png 1024w"
loading="lazy"
alt="image-20241016104245339">
&lt;/a>
&lt;figcaption>image-20241016104245339&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>异或（XOR)法&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 155;
flex-basis: 373px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111.png" data-size="727x467">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111.png"
width="727"
height="467"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111_hu15096252433589209338.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016104602111_hu925909729055331567.png 1024w"
loading="lazy"
alt="位拼接法和异或法">
&lt;/a>
&lt;figcaption>位拼接法和异或法&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="基于全局历史的分支预测">基于全局历史的分支预测&lt;/h3>
&lt;p>对一条分支指令进行分支预测，考虑前面分支指令的执行结果&lt;/p>
&lt;p>需要一个全局历史寄存器（GHR(global history register)),记录最近执行的所有分支指令的结果、&lt;/p>
&lt;p>最理想的情况是对每条分支指令都使用一个PHT&lt;/p>
&lt;p>一个全局寄存器 + 每一条分支指令对应的PHT&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 203;
flex-basis: 489px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117.png" data-size="650x319">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117.png"
width="650"
height="319"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117_hu9179660129570194615.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144951117_hu13364759526685380234.png 1024w"
loading="lazy"
alt="image-20241016144951117">
&lt;/a>
&lt;figcaption>image-20241016144951117&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>量变引起质变，当局部BHR少到只剩下一个的时候，就是全局GHR&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 176;
flex-basis: 423px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624.png" data-size="726x411">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624.png"
width="726"
height="411"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624_hu7324003174822261831.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016144931624_hu16689410873822793480.png 1024w"
loading="lazy"
alt="image-20241016144931624">
&lt;/a>
&lt;figcaption>image-20241016144931624&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>两种分支预测方法&lt;/p>
&lt;p>&lt;strong>局部历史分支预测&lt;/strong>：基于分支指令自身在过去的执行状况来进行分支预测，对每一条分支指令都使用分支历史寄存器（BHR),并使用了由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个BHR的规律，使用BHR和PHT配合进行分支预测&lt;/p>
&lt;p>&lt;strong>全局历史分支预测&lt;/strong>：基于一条分支指令之前的一些分支指令的执行状况来进行分支预测，使用全局历史寄存器（GHR)记录所有分支指令的执行情况，由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个GHR的规律,使用GHR和PHT配合进行分支预测&lt;/p>
&lt;h3 id="竞争的分支预测">竞争的分支预测&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 134;
flex-basis: 323px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720.png" data-size="417x309">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720.png"
width="417"
height="309"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720_hu13974060394538718885.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016145849720_hu8834002104162655463.png 1024w"
loading="lazy"
alt="竞争的分支预测原理图">
&lt;/a>
&lt;figcaption>竞争的分支预测原理图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 135;
flex-basis: 325px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271.png" data-size="506x373">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271.png"
width="506"
height="373"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271_hu7667022521208126150.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150054271_hu9814928122482868099.png 1024w"
loading="lazy"
alt="竞争的分支预测_更详细的原理图">
&lt;/a>
&lt;figcaption>竞争的分支预测_更详细的原理图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>理想情况下每一条分支指令都有一个CPHT(choice PHT)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 143;
flex-basis: 345px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840.png" data-size="391x272">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840.png"
width="391"
height="272"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840_hu3776547309985000606.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016150311840_hu13077989359135110784.png 1024w"
loading="lazy"
alt="CPHT中的两位饱和计数器">
&lt;/a>
&lt;figcaption>CPHT中的两位饱和计数器&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>当P1预测正确,P2预测错误时,计数器减1&lt;/li>
&lt;li>当P1预测错误,P2预测正确时,计数器加1&lt;/li>
&lt;li>当P1和P2预测结果一致时,不管预测正确与否,计数器保持不变&lt;/li>
&lt;/ol>
&lt;p>对于每一条指令,在GHR内容不同时,会导致使用不同的分支预测方法,所以将PC值与GHR进行相应运算再去寻址CPHT的地址.&lt;/p>
&lt;h3 id="分支预测的更新">分支预测的更新&lt;/h3>
&lt;h4 id="历史寄存器">历史寄存器&lt;/h4>
&lt;p>（1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新&lt;/p>
&lt;p>（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新,分支指令可能在错误预测的路径上,造成错误&lt;/p>
&lt;p>（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新 ,最保险的方法,但是浪费了性能&lt;/p>
&lt;p>一条分支指令b在时间t被分支预测,在时间 $t + \Delta t$ 从流水线退休, 任何在 $ \Delta t $内的时间被预测的分支指令都不会从分支指令的结果受益&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 479px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302.png" data-size="763x382">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302.png"
width="763"
height="382"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302_hu9275436089700128595.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016153738302_hu11989386203258249376.png 1024w"
loading="lazy"
alt="image-20241016153738302">
&lt;/a>
&lt;figcaption>image-20241016153738302&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>采取方法1更新 ,但是会出现分支预测失败的情况 ,即使后续的分支指令使用的错误的 GHR ,由于他们在预测失败的路径上,都会从流水线中被抹去&lt;/p>
&lt;h5 id="修复ghr错误值的方法">修复GHR错误值的方法&lt;/h5>
&lt;h6 id="提交commit阶段修复法">提交(commit)阶段修复法&lt;/h6>
&lt;p>前端阶段Speculative GHR, 提交阶段放置一个 Ritired GHR, 在前端推测失败之后,需要等待分支指令退休的时候,将后端的GHR写到前端的GHR中,然后根据这条分支指令所指定的目标地址,重新取指令执行.&lt;/p>
&lt;p>该方法的缺点是会造成分支预测失败时惩罚的增大,(why?)&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 231;
flex-basis: 556px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680.png" data-size="610x263">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680.png"
width="610"
height="263"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680_hu14721982168866039868.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016154227680_hu14789759748200599315.png 1024w"
loading="lazy"
alt="利用提交阶段的GHR修复分支预测器的GHR">
&lt;/a>
&lt;figcaption>利用提交阶段的GHR修复分支预测器的GHR&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h6 id="checkpoint修复法">checkpoint修复法&lt;/h6>
&lt;p>在取指令阶段更新GHR时,可以把旧的GHR值保存起来,保存的内容称为checkpoint GHR .一旦分支指令的结果在流水线中被计算出来,就可以对分支指令的分支预测是否正确进行检查.如果分支预测正确,说明GHR中的值是正确的,如果预测失败,将这条分支指令对于的checkpoint GHR恢复到前端的GHR中,并从这条分支指令正确的目标地址开始取指令执行&lt;/p>
&lt;p>我的理解是把原来的GHR和分支预测结果的反向结合然后放进fifo中,在预测失败时把这个值取出来&lt;/p>
&lt;p>如果是顺序执行,读取存储器的方式也可以用FIFO,&lt;/p>
&lt;p>方式二是对方式一的一种补充,使得能够在执行阶段也去实现恢复&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 125;
flex-basis: 300px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973.png" data-size="509x407">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973.png"
width="509"
height="407"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973_hu2640580469089932493.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016162236973_hu1193722294166550780.png 1024w"
loading="lazy"
alt="利用checkpoint的方法会GHR进行修复">
&lt;/a>
&lt;figcaption>利用checkpoint的方法会GHR进行修复&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h5 id="修复bhr错误值的方法">修复BHR错误值的方法&lt;/h5>
&lt;p>方式和修复GHR基本是类似的,并且BHR很少出现一条分支指令在流水线的提交阶段更新BHR,流水线中又出现了这条分支指令使用BHR进行分支预测的情况,除非循环体很短&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 302;
flex-basis: 725px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130.png" data-size="716x237">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130.png"
width="716"
height="237"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130_hu15264134084536464035.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/image-20241016181356130_hu13417008434328038782.png 1024w"
loading="lazy"
alt="image-20241016181356130">
&lt;/a>
&lt;figcaption>image-20241016181356130&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="两位饱和寄存器">两位饱和寄存器&lt;/h4>
&lt;p>由于饱和寄存器一般是处在饱和状态的,所以选择在分支指令退休的时候更新PHT的饱和计数器,也不会产生很大的负面影响&lt;/p>
&lt;h2 id="版权信息">版权信息&lt;/h2>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>超标量处理器概览</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link><pubDate>Mon, 14 Oct 2024 16:43:30 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid><description>&lt;h2 id="超标量处理器概览">超标量处理器概览&lt;/h2>
&lt;h3 id="超标量处理器的流水线">超标量处理器的流水线&lt;/h3>
&lt;h4 id="顺序执行">顺序执行&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 248;
flex-basis: 596px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png" data-size="1111x447">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png"
width="1111"
height="447"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu6270803957762553776.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu2445645561301413447.png 1024w"
loading="lazy"
alt="in-order pipline">
&lt;/a>
&lt;figcaption>in-order pipline&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>假设流水线每周期可以从 I-Cache 中取出两条指令来执行，则称为2-way 的超标量处理器，在指令经过解码之后，需要根据自身的类型，将两条指令送到对应的 FU 中执行，这个过程称为&lt;strong>发射(Issue)&lt;/strong>。在这个阶段，指令会读取寄存器而得到操作数，同时根据指令的类型，将指令送到对应的 FU 中进行执行。在执行阶段使用了三个 FU:第一个 FU 用来执行 ALU 类型的指令，第二个 FU 用来执行访问存储器类型的指令，第三个 FU 用来执行乘法操作，因为要保证流水线的写回(Write back)阶段是顺序执行的，因此所有 FU 都需要经历同样周期数的流水线，ScoreBoard 用来记录流水线中每条指令的执行情况，例如一条指令在哪个 FU 中执行，在什么时候这条指令可以将结果计算出来等， 一个典型的 ScoreBoard如下。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 156;
flex-basis: 375px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640.png" data-size="443x283">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640.png"
width="443"
height="283"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640_hu6690237057733442019.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014205855640_hu17698180965633417655.png 1024w"
loading="lazy"
alt="scoreboard">
&lt;/a>
&lt;figcaption>scoreboard&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>P: Pending,表示指令的结果还没有写回到逻辑寄存器中。&lt;/p>
&lt;p>F:一条指令在哪个 FU 中执行，在将指令结果进行旁路时会使用这个信息。&lt;/p>
&lt;p>Result Position:在这个部分记录了一条指令到达 FU 中流水段的哪个阶段，3 表示指令处于 FU 流水线的第一个流水段，1 表示指令到达 FU 流水段的最后一个阶段， 0 表示指令处于流水线的写回阶段，在流水线的&lt;strong>发射&lt;/strong>阶段，会将指令的信息写到ScoreBoard 中，同时，这条指令会查询 ScoreBoard 来获知自己的源操作数是否都准备好了，在这条指令被送到 FU 中执行之后的每个周期，都会将这个值右移一位，这样使用这个值就可以表达出指令在 FU 中执行到哪个阶段，对于执行 ALU 类型指令的第一个 FU 来说，当指令到达 3 时，就可以将它的结果进行旁路了；而对于执行乘法指令的第三个 FU 来说，只有当指令到达 1 时，才可以将它的结果进行旁路。本书采取的应该是第二种。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 293;
flex-basis: 703px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774.png" data-size="1179x402">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774.png"
width="1179"
height="402"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774_hu1954438157205633643.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210458774_hu1187424182315409720.png 1024w"
loading="lazy"
alt="image-20241014210458774">
&lt;/a>
&lt;figcaption>image-20241014210458774&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>阻塞发生在译码级&lt;/p>
&lt;p>指令能够跳转到发射级的条件是scoreboard 对应处在级为2&lt;/p>
&lt;p>&lt;del>？一发就发两条，两条必须要同步吗&lt;/del> 应该只是由于下条导致的等待&lt;/p>
&lt;p>指令D不能提前发射应该就是由于需要等待指令C发射&lt;/p>
&lt;p>&lt;del>指令C无法进入执行是由于前递的问题，需要等待指令A的前递&lt;/del>&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 695px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png" data-size="1002x346">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png"
width="1002"
height="346"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu1110554545418232987.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu2239682821483300699.png 1024w"
loading="lazy"
alt="image-20241014212008795">
&lt;/a>
&lt;figcaption>image-20241014212008795&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h4 id="乱序执行">乱序执行&lt;/h4>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 263;
flex-basis: 632px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599.png" data-size="1096x416">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599.png"
width="1096"
height="416"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599_hu3570244685790815188.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014211829599_hu18113048283906519492.png 1024w"
loading="lazy"
alt="乱序执行流水线">
&lt;/a>
&lt;figcaption>乱序执行流水线&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>解码(Decode)阶段&lt;/strong>：为了在乱序执行时解决 WAW 和 WAR 这两种相关性，需要对寄存器进行&lt;strong>重命名(register renaming),&lt;strong>这个过程可以在&lt;/strong>流水线的解码(Decode)&lt;strong>阶段完成，也可以单独使用一个流水段来完成，处理器中需要增加&lt;/strong>物理寄存器堆(Physical Register File, PRF)来配合对指令集中定义的寄存器( Architecture Register File,ARF)进行重命名&lt;/strong>，PRF 中寄存器的个数要多于 ARF。&lt;/p>
&lt;p>**Dispatch(分发):**在这个阶段，被重命名之后的指令会按照程序中规定的顺序，写到发射队列(Issue Queue)、重排序缓存(ROB)和 Store Buffer 等部件中，如果在这些部件中没有空闲的空间可以容纳当前的指令，那么这些指令就需要在流水线的重命名阶段进行等待，这就相当于暂停了寄存器重命名以及之前的所有流水线，直到这些部件中有空闲的空间为止。分发阶段可以和寄存器重命名阶段放在一起，在一些对周期时间要求比较紧的处理器中，也可以将这个部分单独使用一个流水段。&lt;/p>
&lt;p>&lt;strong>发射(Issue)阶段&lt;/strong>：一旦指令的操作数准备好了，就可以从发射队列中离开，送到对应的 FU 中执行，因此发射阶段是流水线从&lt;strong>顺序执行到乱序&lt;/strong>执行的分界点。每个 FU 都有自己的流水线级数，在这种流水线中，由于每个 FU 的执行周期数都不相同，所以指令在流水线的写回(Write Back)阶段是乱序的，在这个阶段，一条指令只要计算完毕， 就会将结果写到 PRF中，由于分支预测失败( mis-prediction)或者异常( exception)的存在，PRF 中的结果未必都会写到 ARF 中，因此也将 PRF 称为 Future File。&lt;/p>
&lt;p>&lt;strong>Register File Read(读取寄存器)&lt;/strong>:被仲裁电路选中的指令需要从物理寄存器堆(Physical Register File,PRF)中读取操作数，一般情况下，被仲裁电路选中的指令可以从PRF 中得到源操作数，当然还有“不一般”的情况，那就是指令不能从 PRF 中得到操作数， 但是却可以在送到 FU 中执行之前，从旁路网络(bypassing network)中得到操作数，事实上很大一部分指令都是通过旁路网络获得操作数的，这也为减少 PRF 的读端口提供了可能。由于超标量处理器每周期需要执行好几条指令，PRF 所需要的端口个数也是比较多的，多端口寄存器堆的访问速度一般都不会很快，因此在现实世界的处理器中，这个阶段都会单独使用一个流水段。&lt;/p>
&lt;p>&lt;strong>提交(Commit)阶段&lt;/strong>：为了保证程序的串行结果，指令需要按照程序中规定的顺序更新处理器的状态，这需要使用一个称为&lt;strong>重排序缓存(ROB)&lt;strong>的部件来配合，流水线中的所有指令都按照程序中规定的顺序存储在重排序缓存中，使用重排序缓存来实现程序对处理器状态的顺序更新，一条指令在这个阶段，会将它的结果从 PRF 搬移到 ARF 中，同时&lt;/strong>重排序缓存也会配合完成对异常(exception)的处理&lt;/strong>，如果不存在异常，那么这条指令就可以顺利地离开流水线， 并对处理器的状态进行更改，此时称这条&lt;strong>指令退休(retire)了&lt;/strong>，一条指令一旦退休，它就再也不可能回到之前的状态了。&lt;/p>
&lt;p>因为 store 指令需要写存储器，如果在流水线的写回阶段就将 store 指令的结果写到存储器中，那么一旦由于分支预测失败或者异常等原因，需要将这条 store 指令从流水线中抹掉时，就没有办法将存储器的状态进行恢复了，因为存储器中原来的值已经被覆盖， &lt;strong>Store Buffer(SB),来存储 store 指令没有退休之前的结果&lt;/strong>，s&lt;strong>tore 指令在流水线的写回阶段，会将它的结果写到 Store Buffer 中，只有一条 store 指令真的从流水线中退休的时候，才可以将它的值从 Store Buffer 写到存储器中&lt;/strong>。使用了这个部件之后，Load 指令此时除了从 D-Cache 中寻找数据，还需要从 Store Buffer 中进行查找，这样在一定程度上增加了设计的复杂度。&lt;/p>
&lt;p>在重排序这里也会处理异常 ， 如果没有异常就会写入ARF, 并成功退休，但是无论有没有异常都会写入SB。退休了才可以去修改相应状态。&lt;/p>
&lt;p>发射阶段选择相应的指令并且送到FU,被选择的指令才会去读取物理寄存器&lt;/p>
&lt;p>写回阶段进行统一旁路，为什么我写的RISCV有这么多的旁路网络 ?&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 267;
flex-basis: 643px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323.png" data-size="946x353">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323.png"
width="946"
height="353"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323_hu5637503064892761083.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241015131538323_hu14369550668972739287.png 1024w"
loading="lazy"
alt="image-20241015131538323">
&lt;/a>
&lt;figcaption>image-20241015131538323&lt;/figcaption>
&lt;/figure>
&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 695px"
>
&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png" data-size="1002x346">
&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795.png"
width="1002"
height="346"
srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu1110554545418232987.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014212008795_hu2239682821483300699.png 1024w"
loading="lazy"
alt="image-20241014212008795">
&lt;/a>
&lt;figcaption>image-20241014212008795&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>超标量处理器设计&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处&lt;/p></description></item><item><title>乱序执行CPU</title><link>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</link><pubDate>Sat, 12 Oct 2024 16:08:08 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</guid><description>&lt;h2 id="tomasulos-algorithm">Tomasulo&amp;rsquo;s algorithm&lt;/h2>
&lt;h3 id="tomasulos-algorithm创新">Tomasulo‘s algorithm创新&lt;/h3>
&lt;p>Tomasulo算法的主要创新包括硬件实现的寄存器重命名、为所有执行单元设计的保留站（reservation stations），以及一个公共数据总线（CDB），通过该总线计算出的值可以广播到所有可能需要它们的保留站。这些创新使得指令能够实现更好的并行执行，避免在使用记分板或其他早期算法时可能导致的停滞.&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 155;
flex-basis: 373px"
>
&lt;a href="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture.png" data-size="1280x822">
&lt;img src="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture.png"
width="1280"
height="822"
srcset="https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture_hu16291643218958583948.png 480w, https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/1280px-Tomasulo_Architecture_hu13189868510601512322.png 1024w"
loading="lazy"
alt="Tomasulo_Architechure">
&lt;/a>
&lt;figcaption>Tomasulo_Architechure&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="cdb总线">CDB总线&lt;/h3>
&lt;p>公共数据总线（CDB）将保留站直接连接到功能单元。根据Tomasulo的设计，它“在保持优先顺序的同时促进并发执行” 。这带来了两个重要影响：&lt;/p>
&lt;ol>
&lt;li>功能单元可以直接访问任何操作的结果，而无需通过浮点寄存器。这使得多个等待同一结果的单元可以继续执行，而不必等待解决对寄存器文件读端口的争用问题。&lt;/li>
&lt;li>危险检测和控制执行是分布式的。保留站负责控制指令何时可以执行，而不是依赖一个专门的危险单元来进行统一管理。&lt;/li>
&lt;/ol>
&lt;h3 id="指令顺序">指令顺序&lt;/h3>
&lt;p>指令是按顺序发出的，因此即使它们是乱序执行的（即非顺序执行），指令序列的效果（如指令引发的异常）仍然会按照顺序执行处理器中的顺序发生。这确保了乱序执行不会影响程序的正确性和预期行为&lt;/p>
&lt;h4 id="寄存器重命名">寄存器重命名&lt;/h4>
&lt;p>Tomasulo算法通过寄存器重命名来实现正确的乱序执行。所有的通用寄存器和保留站寄存器要么保存真实值，要么保存占位符值。如果在发射阶段某个目标寄存器的真实值不可用，则最初会使用占位符值。占位符值是一个标签，指示哪个保留站将生成真实值。当功能单元完成计算并在公共数据总线（CDB）上广播结果时，占位符将被真实值替换。&lt;/p>
&lt;p>每个功能单元都有一个保留站。保留站保存执行单条指令所需的信息，包括操作和操作数。当功能单元空闲且指令所需的所有源操作数均为真实值时，功能单元便开始处理指令。&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://jia.je/hardware/2021/09/14/brief-into-ooo/#%E7%BB%8F%E5%85%B8-tomasulo" target="_blank" rel="noopener"
>乱序执行CPU&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Tomasulo%27s_algorithm" target="_blank" rel="noopener"
>wikipedia Tomasulo&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</title><link>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</link><pubDate>Thu, 10 Oct 2024 14:23:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。&lt;/p>
&lt;h2 id="introduction">introduction&lt;/h2>
&lt;p>乱序执行处理器上的超前执行不会将长延迟操作“移开”（这需要在指令窗口中缓冲它及其后面的指令），而是将其扔出指令窗口。&lt;/p>
&lt;p>当指令窗口被一个长延迟操作阻塞时，架构寄存器文件(architectural register file)的状态会被checkpoint保存。然后处理器进入“&lt;strong>超前运行模式&lt;/strong>”。它为阻塞操作分配一个虚假结果并将其扔出指令窗口。阻塞操作后的指令被**获取、执行，并以伪退休（pseudo-retired）**的方式从指令窗口中移除。当阻塞操作完成时，处理器重新进入“&lt;strong>正常模式&lt;/strong>”。此时，它会恢复之前保存的检查点状态，并从阻塞操作开始重新获取和执行指令。
伪退出(pseudo-retire):指令按照传统意义上的方式执行和完成，只是它们不更新架构状态。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 150;
flex-basis: 361px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456.png" data-size="1193x793">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456.png"
width="1193"
height="793"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456_hu10562838702254261104.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241012153516456_hu2604305733844358238.png 1024w"
loading="lazy"
alt="image-20241012153516456">
&lt;/a>
&lt;figcaption>image-20241012153516456&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Runahead 的好处来自于将被长延迟操作阻塞的小指令窗口转换为非阻塞窗口，从而使其具有大得多的窗口的性能。&lt;/p>
&lt;p>在这篇论文中，仅评估了runahead mode对于在二级缓存失效的内存操作的表现，尽管它也可以在任何阻塞指令窗口的长延迟操作上启动。基于英特尔奔腾4处理器的机器模型，该处理器拥有&lt;strong>128个条目的指令窗口&lt;/strong>。
首先展示了当前的乱序执行引擎无法容忍长延迟的主存访问时间。接下来，展示了runahead mode如何更好地应对这些延迟，并且能够达到一个具有更大指令窗口的机器的性能。&lt;/p>
&lt;h2 id="relate-work">Relate work&lt;/h2>
&lt;p>暂无&lt;/p>
&lt;h2 id="out-of-order-execution-and-memory-latency-tolerance乱序执行和内存容忍度">Out-of-order execution and memory latency tolerance(乱序执行和内存容忍度)&lt;/h2>
&lt;h3 id="instruction-and-scheduling-windows">Instruction and scheduling windows&lt;/h3>
&lt;p>乱序执行比顺序执行更能容忍缓存缺失，因为它能够调度与缓存缺失无关的操作。乱序执行的机器通过两个窗口实现这一点：&lt;strong>指令窗口和调度窗口。&lt;/strong>
指令窗口保存所有已解码但尚未提交到架构状态的指令(ROB)，其主要目的是保证指令按顺序退休，以支持精确异常。
调度窗口包含指令窗口中的一部分指令，其主要目的是每个周期搜索那些准备好执行的指令，并对它们进行调度执行(类似于发射队列)。&lt;/p>
&lt;p>当一个长延迟操作发生时，它会阻塞指令窗口，直到操作完成。尽管后续的指令可能已经执行完成，但它们无法从指令窗口中退休(顺序)。如果操作的延迟时间足够长，并且指令窗口不够大，指令会在窗口中堆积，最终导致指令窗口被填满。此时，机器会停顿并停止向前执行。&lt;/p>
&lt;h3 id="memory-latency-tolerance">Memory latency tolerance&lt;/h3>
&lt;p>取指理想 变 调度窗口 L2理想程度 指令窗口&lt;/p>
&lt;p>图 1 显示了七台不同机器的指令窗口停滞的周期百分比。每个栏顶部的数字是机器的IPC。该数据是所有模拟基准的平均值。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 137;
flex-basis: 330px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124.png" data-size="407x296">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124.png"
width="407"
height="296"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124_hu10965257689849940883.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010154101124_hu1293429106633126320.png 1024w"
loading="lazy"
alt="具有完整指令窗口停顿的周期的百分比">
&lt;/a>
&lt;figcaption>具有完整指令窗口停顿的周期的百分比&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Runahead 的性能优势来自于将指令提取到提取引擎的缓存中，并执行未命中一级或二级缓存的独立加载和存储。&lt;/p>
&lt;h2 id="implementation-of-runahead-execution-in-an-out-of-order-processor">Implementation of runahead execution in an out-of-order processor&lt;/h2>
&lt;p>在本节中，我们描述了在乱序处理器上实现超前执行的情况，其中&lt;strong>指令在被调度后并在执行之前访问寄存器文件&lt;/strong>。Intel Pentium 4 处理器 [13]、MIPS R10000 微处理器 [30] 和 Compaq Alpha 21264 处理器 [18] 是这种微架构的例子。在其他一些微架构中，例如 Intel Pentium Pro 处理器 [12]，&lt;strong>指令在放入调度器之前访问寄存器文件&lt;/strong>。&lt;/p>
&lt;p>Frontend RAT(Register Alias Table)用于寄存器重命名，并包含架构寄存器到物理寄存器的推测映射。&lt;/p>
&lt;p>Retirement RAT 包含指向包含已提交架构值的物理寄存器的指针。它用于在分支错误预测和异常之后恢复状态。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 140;
flex-basis: 338px"
>
&lt;a href="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755.png" data-size="984x698">
&lt;img src="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755.png"
width="984"
height="698"
srcset="https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755_hu4585166472539683948.png 480w, https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/image-20241010195821755_hu9334271057527929535.png 1024w"
loading="lazy"
alt="image-20241010195821755">
&lt;/a>
&lt;figcaption>image-20241010195821755&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h3 id="entering-runahead-mode">Entering runahead mode&lt;/h3>
&lt;p>**当内存操作在二级缓存中未命中且该内存操作到达指令窗口的头部时，处理器进入超前执行模式。**导致进入超前执行模式的指令地址会被记录。为了在从超前运行模式退出时正确恢复架构状态，处理器对架构寄存器文件的状态进行checkpoint。出于性能原因，处理器还检查分支历史寄存器和返回地址堆栈的状态。&lt;/p>
&lt;p>架构寄存器文件的checkpoint可以通过复制提交寄存器别名表（Retirement RAT）指向的物理寄存器内容来完成，但这可能需要时间。&lt;strong>为了避免因复制导致的性能损失，处理器可以在正常模式下不断更新checkpoint的架构寄存器文件&lt;/strong>。当非超前指令从指令窗口中提交时，它会将其结果更新到检查点寄存器文件中的架构目标寄存器。这样检查点操作不会浪费任何时钟周期。&lt;/p>
&lt;p>尽管Retirement RAT 在正常模式下指向架构寄存器状态，但在超前运行模式下它指向伪架构寄存器状态并反映伪退休指令更新的状态&lt;/p>
&lt;h3 id="execution-in-runahead-mode">Execution in runahead mode&lt;/h3>
&lt;p>&lt;strong>无效位和指令&lt;/strong>:每个物理寄存器都有一个与其关联的无效（INV）位，&lt;strong>以指示它是否具有虚假值&lt;/strong>。任何源自设置了无效位的寄存器的指令都是无效指令。 INV 位用于防止使用虚假数据进行虚假预取和分支解析。
如果存储指令是无效的，它会在runahead期间将一个 INV 值引入内存映像。为了处理runahead mode下数据值(和 INV 值)通过内存的通信，我们使用一个小的“runahead cache”，它与一级数据缓存并行访问。&lt;/p>
&lt;p>&lt;strong>INV 值的传播&lt;/strong>:引入 INV 值的第一条指令是导致处理器进入runahead mode的指令,如果这条指令是加载指令，它会将其物理目的寄存器标记为 INV。如果它是存储指令，则会在runahead cache中分配一行，并将其目标字节标记为 INV。&lt;/p>
&lt;p>任何无效的指令在调度或执行后写入寄存器时，会将该寄存器标记为 INV。任何有效的操作在写入寄存器时，会重置其目的寄存器的 INV 位。&lt;/p>
&lt;p>其实意思就是因为此时存储是没有得到相应结果的,所以后续与目的寄存器相关的指令都是无效的,从第一条无效的指令衍射开&lt;/p>
&lt;h4 id="runahead-store-operations-and-runahead-cache">Runahead store operations and runahead cache&lt;/h4>
&lt;p>先行存储(store)指令不会将其结果写入任何地方??。因此，依赖于有效先行存储的先行加载被视为无效指令并被丢弃。由于寄存器数量有限，因此将&lt;strong>先行存储(store)&lt;strong>的结果&lt;/strong>转发&lt;/strong>到&lt;strong>先行加载(load)&lt;strong>对于高性能至关重要。
如果存储及其相关加载都在指令窗口中，则此转发是通过当前乱序处理器中已存在的&lt;/strong>store buffer&lt;/strong>来完成的(应该是cache那边的buffer)。
如果超前运行加载依赖于已经pseudo-retired的超前运行存储（这意味着该存储不再位于store buffer???前面是说的runahead store是不会将结果写入任何地方的），则它应该从某个其他位置获取存储的结果。1是写入data cache (提高复杂度,并且可能会占据其他有效指令的位置),2是弄一个大的fully-associative buffer。&lt;/p>
&lt;p>使用 &lt;strong>runahead cache&lt;/strong> 来保存伪退休先行存储的结果和 INV 状态 ，提供指令之间的数据和INV状态的通信,被逐出的缓存行不会写入其他地方。为了支持存储和加载之间 INV 位的正确通信，store buff中的每个条目和runahead cache 中的每个字节都有一个相应的 INV 位。&lt;strong>runahead cache 的每个字节还有另一个与其关联的位（STO 位），指示存储是否已写入该字节&lt;/strong>。仅当访问的字节由存储写入（设置了 STO 位）并且访问runahead cache 有效时，对超前运行高速缓存的访问才会导致命中。&lt;/p>
&lt;p>更新 INV 和 STO的规则:&lt;/p>
&lt;ol>
&lt;li>当有效的先行存储完成执行时，它将其数据写入其store buffer entry（就像在普通处理器中一样）并重置该条目的关联 INV 位。同时，它查询数据缓存，如果数据缓存未命中，则向内存层次结构发送预取请求。&lt;/li>
&lt;li>当一个无效的先行存储被scheduled时，它会set其相关store buff条目的 INV 位。&lt;/li>
&lt;li>当一个有效的先行存储离开指令窗口时，它会将其结果写入runahead cache，并重置已写入字节的 INV 位。同时，它还会设置已写入字节的 STO 位。&lt;/li>
&lt;li>当一个无效的先行存储离开指令窗口时，如果其地址有效，它会设置写入字节的 INV 位和 STO 位&lt;/li>
&lt;li>先行存储从不将结果写入数据缓存??????。&lt;/li>
&lt;/ol>
&lt;p>当存储操作的地址无效时，存储操作会被简单地视为一个空操作（NOP）。由于加载操作无法识别与这些无效存储操作的依赖关系，它们可能会错误地从内存中加载一个陈旧的值。这个问题可以通过使用&lt;strong>内存依赖预测器&lt;/strong>来缓解，**预测器可以识别无效地址存储操作与其依赖的加载操作之间的依赖关系。**一旦依赖关系被识别，如果存储操作的数据值是无效的，则加载操作会被标记为无效（INV）；如果存储操作的数据值是有效的，则可以将其forward给加载操作。&lt;/p>
&lt;h4 id="runahead-load-operations">Runahead load operations&lt;/h4>
&lt;p>runahead load invalid :&lt;/p>
&lt;ol>
&lt;li>
&lt;p>源自无效的物理寄存器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>依赖于store buffer中标记为无效（INV）的存储操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>依赖于一个已经伪退休且是无效（INV）的存储操作(runahead cache)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有效load会并行访问3个结构 ： data cache , runahead cache , store buffer .&lt;/p>
&lt;p>加载操作命中store buffer ，并且命中的条目被标记为有效，那么加载操作会从store buffer获取数据。
加载操作命中store buffer ，并且命中的条目被标记为无效（INV），那么加载操作会将其物理目标寄存器标记为无效（INV）。&lt;/p>
&lt;p>只有当加载指令访问的cache line有效且其访问的任何字节的 STO 位被set时，该加载才被视为在&lt;strong>runahead cache 中命中&lt;/strong>。
&lt;strong>如果load在store buffer未命中但在runahead cache 命中&lt;/strong>，则它会检查在runahead cache 访问的字节的 INV 位。如果没有INV 位set ，将使用runahead cache 中的数据。如果任意一个源数据字节被标记为 INV，则将其目标寄存器标记为INV。
&lt;strong>如果load在store buffer和runahead cache 都未命中，但在data cache中命中&lt;/strong>，则它将使用data cache中的值，并被视为valid(data cache 应该是不涉及runahead的)。然而，由于以下两个原因，它实际上可能是无效的????：1）它可能依赖于具有 INV 地址的store，(依赖于无效的store 就不应该被判定为有效啊)或者 2）它可能依赖于一个 INV store，该store在runahead cache中将其目标字节标记为 INV，但由于冲突，相应的runahead cache被释放(意思就是,实际上load是无效的,但是由于load所访问的runahead cache被别的指令释放了,比方说另一个store把cache 给挤掉了)。然而，这两种情况都是罕见的，不会显著影响性能。&lt;/p>
&lt;p>&lt;strong>如果加载在所有三个结构中都未命中&lt;/strong>，它会向L2 cache 发送请求以获取其数据。如果该请求在L2 cache 中命中，则数据将从L2 cache 传输到L1 cache ，加载完成其执行。如果请求在L2 cache 中未命中，加载会将其&lt;strong>目标寄存器&lt;/strong>标记为 INV，并像导致进入runahead mode的加载那样(未命中L1 cache)从调度器中移除。该请求会发送到内存像一个未命中 L2 缓存的&lt;strong>正常加载请求&lt;/strong>一样。&lt;/p>
&lt;p>store buffer &amp;gt; runahead cache &amp;gt; data cache &amp;gt; L2 cache&lt;/p>
&lt;h4 id="execution-and-prediction-of-branches">Execution and prediction of branches&lt;/h4>
&lt;p>在runahead mode中，分支的预测和解决方式与正常模式完全相同，唯一的区别是：具有 INV 源(寄存器标记为INV)的分支（与所有分支一样）被预测并以推测的方式更新全局分支历史寄存器，但与其他分支不同，它永远无法被解决。???如果分支预测错误，处理器在获取到该分支后将始终处于错误路径，直到遇到一个与控制流无关的点。我们将获取到错误预测的 INV 分支的程序中的点称为“分歧点”。分歧点的存在不一定对性能有害分歧点在runahead mode中出现得越晚，性能提升就越好。&lt;/p>
&lt;p>前置模式下分支预测器表的训练策略:&lt;/p>
&lt;p>(1)始终训练分支预测器表。如果一个分支首先在前置模式下执行，然后在正常模式下执行，这种策略将导致同一个分支对分支预测器进行两次训练。因此，预测器表的性能得到了增强，计数器可能会失去滞后效应。&lt;/p>
&lt;p>(2)不在前置模式下训练分支预测器。这会导致前置模式下的分支预测准确率降低，从而降低性能，并使分歧点更接近前置入口点。&lt;/p>
&lt;p>(3)第三种选择是始终在前置模式下训练分支预测器，但同时使用一个队列将前置模式下分支的结果传递给正常模式。在正常模式下，如果存在预测，则使用该队列中的预测来进行分支预测。如果一个分支使用来自队列的预测进行预测，则不会再次训练预测器表。&lt;/p>
&lt;p>(4)前置模式和正常模式使用两个独立的预测器表，并在进入前置模式时将正常模式的表信息复制到前置模式。这一选项在硬件实现上成本较高，但我们进行了模拟以确定第一种选项的双重训练策略有多重要。&lt;/p>
&lt;p>我们的结果显示，与第四种选择相比，二次训练分支预测器表条目并没有显著降低性能(方法1)。&lt;/p>
&lt;h4 id="instruction-pseudo-retirement-during-runahead-mode">Instruction pseudo-retirement during runahead mode.&lt;/h4>
&lt;p>在runahead mode下，指令按照程序顺序离开指令窗口。&lt;strong>如果某条指令到达指令窗口的队头，它将被考虑进行pseudo-retire。&lt;/strong>
如果被考虑pseudo-retire的指令是无效的（INV），它会立即从窗口中移除。
如果指令是有效的，它需要等待执行完毕（此时它可能变为无效的），并将结果写入&lt;strong>物理寄存器文件&lt;/strong>。在pseudo-retire时，一条指令会释放为其执行分配的所有资源。&lt;/p>
&lt;p>无论是有效还是无效的指令，在它们离开指令窗口时都会更新退休重命名表（Retirement RAT）。退休重命名表不需要存储与每个寄存器关联的无效（INV）位，因为物理寄存器已经各自关联了无效位。&lt;/p>
&lt;h4 id="exiting-runahead-mode">Exiting runahead mode&lt;/h4>
&lt;p>可以随时启动退出预运行模式的过程。为了简化处理，我们将退出预运行模式的操作与处理分支预测错误的方式相同。处理器中的所有指令都会被flush，相关的缓冲区会被释放。&lt;strong>检查点保存的架构寄存器文件会复制到物理寄存器文件的预定区域&lt;/strong>。前端和退休阶段的寄存器重命名表（RATs）也会修复，以指向保存架构寄存器值的物理寄存器。这种恢复通过重新加载相同的硬编码映射到两个别名表来实现。预运行缓存中的所有行都将失效（并且 STO 位被清零），在退出预运行模式时，检查点保存的分支历史寄存器和返回地址栈将被恢复。处理器会从导致进入预运行模式的指令地址开始获取指令。&lt;/p>
&lt;p>&lt;strong>我们的策略是在阻塞的加载指令从内存中取回数据时退出runahead mode&lt;/strong>。另一种策略是通过使用定时器提前退出，这样可以消除部分流水线填充或窗口填充的开销。我们发现，对于某些基准测试，这种替代策略表现良好，而在其他基准测试中表现不佳。总体上，提前退出的效果略差。提前退出对于某些基准测试表现较差的原因是，如果处理器不尽早退出预运行模式，可能会生成更多的二级缓存丢失预取请求。&lt;/p>
&lt;h3 id="知识点补充">知识点补充&lt;/h3>
&lt;h4 id="store-buffer">store buffer&lt;/h4>
&lt;h4 id="分支预测">分支预测&lt;/h4>
&lt;h4 id="architectural-register">Architectural Register&lt;/h4>
&lt;p>架构寄存器是指每个CPU独有的一组全局寄存器，这些寄存器不与其他CPU共享。它们可以存储任意类型的数据，并且能够在CPU内部的线程之间实现快速通信。&lt;/p>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/lshpku/hwd-prefetch-study/blob/master/Paper_Reading.md" target="_blank" rel="noopener"
>paper-reading&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.sciencedirect.com/topics/computer-science/architectural-register" target="_blank" rel="noopener"
>architectural register&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://jia.je/hardware/2021/09/14/brief-into-ooo/#%E8%83%8C%E6%99%AF" target="_blank" rel="noopener"
>浅谈乱序执行CPU&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Chipyard Learning</title><link>https://VastCircle.github.io/2024/chipyard-learning/</link><pubDate>Mon, 07 Oct 2024 16:15:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard-learning/</guid><description>&lt;h2 id="chipyard-从下载到构建">chipyard 从下载到构建&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone https://github.com/ucb-bar/chipyard.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> chipyard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout 1.10.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 为了使得clone顺利，把http都换成ssh ，使用命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find . -name &lt;span style="color:#98c379">&amp;#34;.gitmodules&amp;#34;&lt;/span> -type f -exec sed -i &lt;span style="color:#98c379">&amp;#39;s/https:\/\/github.com\//git@github.com:/g&amp;#39;&lt;/span> &lt;span style="color:#56b6c2">{}&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule sync
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 运行初始化脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./build-setup.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 导入conda环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">source&lt;/span> ./env.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">## 初始化software ，例如coremark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ./scripts/init-software.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置一个2核心soc">配置一个2核心soc&lt;/h2>
&lt;h3 id="chipyard-配置文件">chipyard 配置文件&lt;/h3>
&lt;p>chipyard的配置文件是在&lt;code>chipyard/generators/chipyard/src/main/scala/config&lt;/code>中，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">MyCoreConfigs&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e5c07b">Config&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">freechips&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">rocketchip&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">subsystem&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e5c07b">WithNBigCores&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#d19a66">2&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span> &lt;span style="color:#7f848e">// single rocket-core
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">chipyard&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e06c75">config&lt;/span>&lt;span style="color:#56b6c2">.&lt;/span>&lt;span style="color:#e5c07b">AbstractConfig&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在sim/verilator界面去执行命令,可以生成文件 simulator-chipyard-MyCoreConfig&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>make &lt;span style="color:#e06c75">CONFIG&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>MyCoreConfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="裸机编译riscv">裸机编译riscv&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#include&lt;/span> &lt;span style="color:#7f848e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#7f848e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#61afef;font-weight:bold">main&lt;/span>(&lt;span style="color:#e5c07b">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#61afef;font-weight:bold">printf&lt;/span>(&lt;span style="color:#98c379">&amp;#34;Hello, World!&lt;/span>&lt;span style="color:#98c379">\n&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">return&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ riscv64-unknown-elf-gcc -fno-common -fno-builtin-printf -specs&lt;span style="color:#56b6c2">=&lt;/span>htif_nano.specs -c hello.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ riscv64-unknown-elf-gcc -static -specs&lt;span style="color:#56b6c2">=&lt;/span>htif_nano.specs hello.o -o hello.riscv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ spike hello.riscv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-fno-common&lt;/li>
&lt;/ul>
&lt;p>​ 默认情况下，C语言会将未初始化的全局变量放在一个“common”区域，可以被多个文件共享。&lt;code>-fno-common&lt;/code> 禁止这种行为，要求每个未初始化的全局变量必须在一个文件中定义。&lt;/p>
&lt;ul>
&lt;li>-fno-builtin-printf&lt;/li>
&lt;/ul>
&lt;p>​ 禁用编译器内置的 &lt;code>printf&lt;/code> 函数，强制使用标准库中的 &lt;code>printf&lt;/code> 函数&lt;/p>
&lt;ul>
&lt;li>-specs=htif_nano.specs&lt;/li>
&lt;/ul>
&lt;p>​ &lt;code>htif_nano.specs&lt;/code> 可能是为特定硬件平台（例如 RISC-V）的模拟环境或硬件接口（HTIF）准备的编译和链接配置，确保生成的代码可以在特定环境中运行&lt;/p>
&lt;ul>
&lt;li>
&lt;p>-static&lt;/p>
&lt;p>强制使用静态链接库，而不是动态链接库。所有需要的库代码都会在编译时直接链接到生成的可执行文件中，而不是在运行时动态加载。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="生成波形">生成波形&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>make run-binary-debug &lt;span style="color:#e06c75">BINARY&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>test.riscv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应该是要重新编译前文生成的bin文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 方法1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make run-binary-debug &lt;span style="color:#e06c75">BINARY&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>test.riscv &lt;span style="color:#e06c75">CONFIG&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>MyCoreConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 方法2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./simulator-chipyard-RocketConfig &lt;span style="color:#e06c75">$RISCV&lt;/span>/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-simple
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在output/chipyard.harness.TestHarness.MyCoreConfig 可以看到hello.vcd&lt;/p>
&lt;p>使用 gtkwave可以打开hello.vcd 查看&lt;/p>
&lt;h3 id="rocket-chip">rocket chip&lt;/h3>
&lt;div align=center>&lt;img src="rocket-chip 图表.png" alt="123" style="zoom:50%;" />&lt;/div>
&lt;h4 id="tiles">tiles&lt;/h4>
&lt;p>每个&lt;code>Rocket&lt;/code>核心都与一个页表遍历器、L1 指令缓存和 L1 数据缓存组合成一个&lt;code>RocketTile&lt;/code>&lt;/p>
&lt;p>每个 CPU 块都有一个 L1 指令缓存和 L1 数据缓存。这些缓存的大小和关联性可以配置。默认&lt;code>RocketConfig&lt;/code> 使用 16 KiB、4 路组关联指令和数据缓存&lt;/p>
&lt;h4 id="memory-system">Memory System&lt;/h4>
&lt;p>这些图块(Tiles)连接到&lt;code>SystemBus&lt;/code>，后者将其连接到 L2 缓存组。然后，L2 缓存组连接到&lt;code>MemoryBus&lt;/code>，后者通过 TileLink 到 AXI 转换器连接到 DRAM 控制器&lt;/p>
&lt;div align=center>&lt;img src="image-20241009152035016.png" alt="Momory System" style="zoom:50%;" /> &lt;/div>
&lt;h4 id="mmio">MMIO&lt;/h4>
&lt;p>对于 MMIO 外围设备，&lt;code>SystemBus&lt;/code>连接到&lt;code>ControlBus&lt;/code>和&lt;code>PeripheryBus&lt;/code>&lt;/p>
&lt;p>&lt;code>ControlBus&lt;/code>连接标准外围设备，如 BootROM、平台级中断控制器 (PLIC)、核心本地中断 (CLINT) 和调试单元&lt;/p>
&lt;h5 id="bootrom">BootROM&lt;/h5>
&lt;p>BootROM 包含第一阶段引导加载程序，即系统复位后运行的第一条指令。它还包含设备树，Linux 会使用它来确定连接了哪些其他外设，具体在 /generators/rocket-chip/bootrom&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">#define DRAM_BASE 0x80000000
.section .text.start, &amp;#34;ax&amp;#34;, @progbits
.globl _start
_start:
csrwi 0x7c1, 0 // disable chicken bits
li s0, DRAM_BASE
csrr a0, mhartid
la a1, _dtb
jr s0
.section .text.hang, &amp;#34;ax&amp;#34;, @progbits
.globl _hang
_hang:
csrwi 0x7c1, 0 // disable chicken bits
csrr a0, mhartid
la a1, _dtb
csrwi mie, 0
1:
wfi
j 1b
.section .rodata.dtb, &amp;#34;a&amp;#34;, @progbits
.globl _dtb
.align 5, 0
_dtb:
.ascii &amp;#34;DTB goes here&amp;#34;
&lt;/code>&lt;/pre>&lt;p>linker.ld&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>SECTIONS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ROM_BASE&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> 0x10000; /* ... but actually position independent */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text.start : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.text.start&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE + 0x40;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text.hang : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.text.hang&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> . &lt;span style="color:#56b6c2">=&lt;/span> ROM_BASE + 0x80;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .rodata.dtb : &lt;span style="color:#56b6c2">{&lt;/span> *&lt;span style="color:#56b6c2">(&lt;/span>.rodata.dtb&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一条指令应该是从0x10000开始&lt;/p>
&lt;h2 id="源码解读">源码解读&lt;/h2>
&lt;h3 id="variablesmk">variables.mk&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>ifeq (&lt;span style="color:#c678dd">$(&lt;/span>&lt;span style="color:#e06c75">SUB_PROJECT&lt;/span>&lt;span style="color:#c678dd">)&lt;/span>,chipyard)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">SBT_PROJECT&lt;/span> &lt;span style="color:#56b6c2">?=&lt;/span> chipyard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MODEL ?&lt;span style="color:#56b6c2">=&lt;/span> TestHarness
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VLOG_MODEL ?&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#c678dd">$(&lt;/span>MODEL&lt;span style="color:#c678dd">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MODEL_PACKAGE ?&lt;span style="color:#56b6c2">=&lt;/span> chipyard.harness
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONFIG ?&lt;span style="color:#56b6c2">=&lt;/span> RocketConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONFIG_PACKAGE ?&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#c678dd">$(&lt;/span>SBT_PROJECT&lt;span style="color:#c678dd">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GENERATOR_PACKAGE ?&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#c678dd">$(&lt;/span>SBT_PROJECT&lt;span style="color:#c678dd">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TB ?&lt;span style="color:#56b6c2">=&lt;/span> TestDriver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TOP ?&lt;span style="color:#56b6c2">=&lt;/span> ChipTop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>endif
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sub_project">SUB_PROJECT&lt;/h4>
&lt;p>这对应于chipyard/generators 目录中的项目之一。更正式地说，它是由相应生成器目录中的 build.sbt 文件中的条目之一以及 Chipyard 根目录中的主 build.sbt 文件定义的&lt;/p>
&lt;p>constellation icenet rocketchip testchipip hwacha &amp;hellip;&lt;/p>
&lt;h4 id="sbt_project">SBT_PROJECT&lt;/h4>
&lt;p>这对应于要构建的芯片的顶级存储库。这是定义许多更高级别的构造的地方，例如测试工具和测试平台。&lt;/p>
&lt;h4 id="model">MODEL&lt;/h4>
&lt;p>该模型是 Chisel 应该使用的项目的顶级模块。通常，这应该定义为与测试工具相同，但不一定必须如此。&lt;/p>
&lt;h4 id="vlog_model">VLOG_MODEL&lt;/h4>
&lt;p>这是 FIRRTL/Verilog 应该使用的项目的顶层模块。与 MODEL 一样，这通常与测试工具相同，但不一定需要如此。&lt;/p>
&lt;h4 id="model_package">MODEL_PACKAGE&lt;/h4>
&lt;p>这是用于查找 CPU 整体模型的 Scala 包。这应该对应于 Scala CPU 配置文件中的包 &lt;packageName>。&lt;/p>
&lt;h4 id="config">CONFIG&lt;/h4>
&lt;p>这定义了项目应使用的参数。通常，这用于选择 SBT_PROJECT 中定义的 CPU 配置之一。&lt;/p>
&lt;h4 id="config_package">CONFIG_PACKAGE&lt;/h4>
&lt;p>这是定义 Config 类的 Scala 包。该文件必须包含 Config 的类定义，这意味着对象 Config 必须存在。&lt;/p>
&lt;h4 id="generator_package">GENERATOR_PACKAGE&lt;/h4>
&lt;p>这是定义 Generator 类的 Scala 包。该文件必须包含 Generator 的类定义，这意味着 Generator 对象必须存在。&lt;/p>
&lt;h4 id="tb">TB&lt;/h4>
&lt;p>这定义了测试台包装器，该包装器延伸到测试工具上，以允许在 Verilog 模拟器中进行模拟。默认是TestDriver&lt;/p>
&lt;p>路径位于generators/rocket-chip/src/main/resources/vsrc/TestDriver.v&lt;/p>
&lt;p>里面包含着这个&lt;/p>
&lt;pre tabindex="0">&lt;code> `MODEL testHarness(
.clock(clock),
.reset(reset),
.io_success(success)
&lt;/code>&lt;/pre>&lt;h4 id="top">TOP&lt;/h4>
&lt;p>这是该项目的顶层模块。通常，这是由测试工具实例化的模块。 例如chiptop&lt;/p>
&lt;h2 id="在sim文件里make-发生了什么">在sim文件里make 发生了什么&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 拷贝镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp -f /chipyard/resources/testchipip/bootrom/bootrom.rv64.img chipyard/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/bootrom.rv64.img
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Chipyard环境中生成基于MyCoreConfig配置的模拟代码，同时输出生成过程的日志以便后续调试和查看。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#e5c07b">set&lt;/span> -o pipefail &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e5c07b">cd&lt;/span> CHIPYARD_HOME &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> java -cp CHIPYARD_HOME/.classpath_cache/chipyard.jar chipyard.Generator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--target-dir CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig &lt;span style="color:#7f848e">## 指定生成代码的输出目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--name chipyard.harness.TestHarness.MyCoreConfig &lt;span style="color:#7f848e">## 指定生成文件的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--top-module chipyard.harness.TestHarness &lt;span style="color:#7f848e">## 指定生成代码的顶层文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--legacy-configs chipyard:MyCoreConfig &lt;span style="color:#7f848e">## 指定代码的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| tee CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.chisel.log&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 执行了一个 Chipyard 项目模型生成过程。它读取设计的 FIRRTL 文件和相关注解，生成指定的 SFC 模型和注解文件，以便后续仿真或综合使用。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> CHIPYARD_HOME &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> java -cp CHIPYARD_HOME/.classpath_cache/tapeout.jar barstools.tapeout.transforms.GenerateModelStageMain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--no-dedup &lt;span style="color:#7f848e">## 禁用模块去重 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--output-file CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.sfc &lt;span style="color:#7f848e">## 指定生成SFC文件的路径,用于存储生成的模型数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--output-annotation-file CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.sfc.anno.json &lt;span style="color:#7f848e">## 生成模型的注解文件,将附加信息保存为json文件 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--target-dir CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral &lt;span style="color:#7f848e">## 指定生成的附加文件的目标目录.gen-collateral 用于存放存放其他的生成数据和文件。 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--input-file CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.fir &lt;span style="color:#7f848e">## 输入的 FIRRTL 文件，用于描述整个设计的结构和逻辑。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--annotation-file CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.appended.anno.json &lt;span style="color:#7f848e">## 输入注解文件，包含了与 FIRRTL 文件相关的额外信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--log-level error &lt;span style="color:#7f848e">## 设置日志等级为 error，只输出错误信息，以减少不必要的日志信息。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--allow-unrecognized-annotations &lt;span style="color:#7f848e">##允许工具跳过无法识别的注解，保证生成过程顺利进行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-X
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firtool &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> --format&lt;span style="color:#56b6c2">=&lt;/span>fir &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定输入文件为 FIRRTL 格式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dedup &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 启用模块去重，减少重复模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --export-module-hierarchy &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 导出模块的层次结构，便于理解模块关系&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --emit-metadata &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 生成包含设计元数据的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --verify-each&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#e5c07b">true&lt;/span> &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 每次转换后验证 FIRRTL，确保转换正确性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --warn-on-unprocessed-annotations &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 对无法识别的注解给出警告，便于调试&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --disable-annotation-classless &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 禁用无明确类型的注解，避免生成不确定信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --disable-annotation-unknown &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 禁用未知类型的注解，确保生成过程可控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --mlir-timing &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 记录 MLIR 的执行时间，便于性能分析&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --lowering-options&lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 控制降低选项（留空使用默认设置）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --repl-seq-mem &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 启用序列内存替换，将高层内存结构转换为可综合内存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --repl-seq-mem-file&lt;span style="color:#56b6c2">=&lt;/span>CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.mems.conf &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定内存替换配置文件，描述生成的内存模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --repl-seq-mem-circuit&lt;span style="color:#56b6c2">=&lt;/span>TestHarness &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定内存替换的电路名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --annotation-file&lt;span style="color:#56b6c2">=&lt;/span>CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.sfc.anno.json &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入注解文件，提供生成过程所需的额外信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --split-verilog &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 将生成的 Verilog 拆分为多个文件，便于管理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -o CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定输出目录，存放生成的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.sfc.fir &lt;span style="color:#7f848e"># 输入 FIRRTL 文件，包含电路的高层次描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 这条命令运行 uniquify-module-names.py 脚本，用于对模块名称进行唯一化。其目的在于解决模块名重复问题，确保在文件列表和层次结构中，每个模块的名称都是唯一的，便于 Verilog 生成和仿真流程的管理。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CHIPYARD_HOME/scripts/uniquify-module-names.py &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> --model-hier-json CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/model_module_hierarchy.json &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：模型模块的层次结构 JSON 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --top-hier-json CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/top_module_hierarchy.json &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：顶层模块的层次结构 JSON 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --in-all-filelist CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral/filelist.f &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：包含所有模块的文件列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dut ChipTop &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定待验证的顶层模块为 ChipTop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --model TestHarness &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定模型的顶层模块为 TestHarness&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --target-dir CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定目标目录，用于存放输出文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --out-dut-filelist CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.top.f &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出：顶层模块的文件列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --out-model-filelist CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.model.f &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出：模型模块的文件列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --out-model-hier-json CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/model_module_hierarchy.uniquified.json &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出：唯一化后的模型模块层次结构 JSON 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --gcpath CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral &lt;span style="color:#7f848e"># 指定生成文件的路径（用于在唯一化过程中查找生成文件）\&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 复制TestDriver.v到gen-collateral文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp -f CHIPYARD_HOME/generators/rocket-chip/src/main/resources/vsrc/TestDriver.v CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 运行 split-mems-conf.py 脚本，将包含所有内存配置的文件分离为顶层模块和模型模块各自独立的内存配置文件。使顶层模块 ChipTop 和模型模块 TestHarness 各自拥有独立的内存配置文件，便于后续的综合和仿真过程。 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CHIPYARD_HOME/scripts/split-mems-conf.py &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> --in-smems-conf CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.mems.conf &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：包含所有内存的配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --in-model-hrchy-json CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/model_module_hierarchy.uniquified.json &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：唯一化的模型模块层次结构 JSON 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --dut-module-name ChipTop &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定顶层模块名称为 ChipTop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --model-module-name TestHarness &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定模型模块名称为 TestHarness&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --out-dut-smems-conf CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.top.mems.conf &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出：用于顶层模块 ChipTop 的内存配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --out-model-smems-conf CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.model.mems.conf &lt;span style="color:#7f848e"># 输出：用于模型模块 TestHarness 的内存配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 这条命令使用 MacroCompiler 工具，根据内存配置生成顶层模块的内存宏单元。通过指定 synflops 模式，可以确保生成的内存结构符合同步触发器的合成要求，并生成对应的 Verilog 文件，用于后续的仿真或综合步骤。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> CHIPYARD_HOME &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> java -cp CHIPYARD_HOME/.classpath_cache/tapeout.jar barstools.macros.MacroCompiler &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> -n CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.top.mems.conf &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入内存配置文件，为顶层模块生成内存宏单元&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -v CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral/chipyard.harness.TestHarness.MyCoreConfig.top.mems.v &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出 Verilog 文件，生成的内存宏单元描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -f CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.top.mems.fir &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入 FIRRTL 文件，用于描述内存结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --mode synflops &lt;span style="color:#7f848e"># 指定生成模式为 synflops，用于同步触发器合成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 这条命令与之前的命令类似，但这是针对模型模块 TestHarness 的内存配置。它使用 MacroCompiler 工具生成该模块的内存宏单元，确保生成的内存结构符合同步触发器的合成要求。生成的 Verilog 文件将用于后续的仿真或综合过程。 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">cd&lt;/span> CHIPYARD_HOME &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> java -cp CHIPYARD_HOME/.classpath_cache/tapeout.jar barstools.macros.MacroCompiler &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> -n CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.model.mems.conf &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：模型模块的内存配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -v CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral/chipyard.harness.TestHarness.MyCoreConfig.model.mems.v &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出：生成的 Verilog 文件，描述模型模块的内存宏单元&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -f CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.model.mems.fir &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入：用于描述模型模块内存结构的 FIRRTL 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --mode synflops &lt;span style="color:#7f848e"># 指定生成模式为 synflops，以支持同步触发器的合成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 这条命令使用 Verilator 工具生成一个基于 TestDriver 顶层模块的 C++ 模拟器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>verilator --main --timing --cc --exe &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> -CFLAGS &lt;span style="color:#98c379">&amp;#34; -O3 -std=c++17 -ICHIPYARD_HOME/.conda-env/riscv-tools/include -ICHIPYARD_HOME/tools/DRAMSim2 -ICHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/gen-collateral -DVERILATOR -include CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig.plusArgs&amp;#34;&lt;/span> &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 编译标志，包含优化选项、标准和包含路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -LDFLAGS &lt;span style="color:#98c379">&amp;#34; -LCHIPYARD_HOME/.conda-env/riscv-tools/lib -Wl,-rpath,CHIPYARD_HOME/.conda-env/riscv-tools/lib -LCHIPYARD_HOME/sims/verilator -LCHIPYARD_HOME/tools/DRAMSim2 -lriscv -lfesvr -ldramsim &amp;#34;&lt;/span> &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 链接标志，指定库路径和链接的库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --threads &lt;span style="color:#d19a66">1&lt;/span> --threads-dpi all -O3 --x-assign fast --x-initial fast &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 设置线程数，优化和快速初始化选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --output-split &lt;span style="color:#d19a66">10000&lt;/span> --output-split-cfuncs &lt;span style="color:#d19a66">100&lt;/span> --assert -Wno-fatal &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输出分割设置、启用断言，禁止致命警告&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --timescale 1ns/1ps --max-num-width &lt;span style="color:#d19a66">1048576&lt;/span> &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 设置时间尺度和宽度限制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +define+CLOCK_PERIOD&lt;span style="color:#56b6c2">=&lt;/span>1.0 +define+RESET_DELAY&lt;span style="color:#56b6c2">=&lt;/span>777.7 +define+PRINTF_COND&lt;span style="color:#56b6c2">=&lt;/span>TestDriver.printf_cond &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 定义宏，包括时钟周期和重置延迟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +define+STOP_COND&lt;span style="color:#56b6c2">=&lt;/span>!TestDriver.reset +define+MODEL&lt;span style="color:#56b6c2">=&lt;/span>TestHarness &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 进一步定义条件和模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +define+RANDOMIZE_MEM_INIT +define+RANDOMIZE_REG_INIT +define+RANDOMIZE_GARBAGE_ASSIGN +define+RANDOMIZE_INVALID_ASSIGN +define+VERILATOR &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 启用随机化选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --top-module TestDriver --vpi &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定顶层模块为 TestDriver，启用 VPI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -f CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/sim_files.common.f &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 输入文件列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -o CHIPYARD_HOME/sims/verilator/simulator-chipyard.harness-MyCoreConfig &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定输出的模拟器文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Mdir CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig &lt;span style="color:#98c379">\ &lt;/span> &lt;span style="color:#7f848e"># 指定模型目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -CFLAGS &lt;span style="color:#98c379">&amp;#34;-include CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig/VTestDriver.h&amp;#34;&lt;/span> &lt;span style="color:#7f848e"># 额外的编译标志，包含 VTestDriver 头文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 建立VtestDriver.mk &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig/VTestDriver.mk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 编译DRAMSim2的源文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make -C CHIPYARD_HOME/tools/DRAMSim2 libdramsim.a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 使用VTestDriver.mk来生成可执行文件simulator-chipyard.harness-MyCoreConfig &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make &lt;span style="color:#e06c75">VM_PARALLEL_BUILDS&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">1&lt;/span> -C CHIPYARD_HOME/sims/verilator/generated-src/chipyard.harness.TestHarness.MyCoreConfig/chipyard.harness.TestHarness.MyCoreConfig -f VTestDriver.mk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;p>&lt;a class="link" href="https://alukens.com/project/spring-2021-independent-research-results/research_final_paper.pdf" target="_blank" rel="noopener"
>An Introduction to Declarative CPU Design and FPGA Development using the Chipyard SoC Design Framework&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://chipyard.readthedocs.io/en/1.10.0/" target="_blank" rel="noopener"
>chipyard手册&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/hwzhao/p/17363380.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/hwzhao/p/17363380.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/ucb-bar/chipyard/blob/main/docs/Advanced-Concepts/Top-Testharness.rst" target="_blank" rel="noopener"
>Tops,Test-Harnesses,and the Test-Driver&lt;/a>&lt;/p>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
>vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>博客搭建</title><link>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 06 Oct 2024 21:57:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h2 id="安装hugo">安装Hugo&lt;/h2>
&lt;p>ubuntu 系统使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令进行验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-hugo-网站">创建 Hugo 网站&lt;/h2>
&lt;p>通过上述命令安装 hugo 程序后，就可以通过 &lt;code>hugo new site&lt;/code> 命令进行网站创建、配置与本地调试了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new site robin-site
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置主题">配置主题&lt;/h2>
&lt;p>当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>Themes&lt;/a> 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。&lt;/p>
&lt;p>官方主题网站: &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>https://themes.gohugo.io/&lt;/a>&lt;/p>
&lt;p>主题推荐:&lt;/p>
&lt;ul>
&lt;li>Pure: &lt;a class="link" href="https://themes.gohugo.io/hugo-theme-pure/" target="_blank" rel="noopener"
>https://themes.gohugo.io/hugo-theme-pure/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="关联主题仓库">关联主题仓库&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/reuixiy/hugo-theme-meme/blob/main/README.zh-cn.md" target="_blank" rel="noopener"
>https://github.com/reuixiy/hugo-theme-meme/blob/main/README.zh-cn.md&lt;/a>&lt;/p>
&lt;p>我们可以将主题仓库直接 &lt;code>git clone&lt;/code> 下来进行使用，例如在根目录robin-site下运行以下代码，即可下载pure主题.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。官方更推荐使用的是将原主题仓库 &lt;code>fork&lt;/code> 到自己的账户，并使用 &lt;code>git submodule&lt;/code> 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> robin-site/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/pseudoyu/pure themes/pure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在根目录下的 &lt;code>config.toml&lt;/code>文件中添加新的一行:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">theme&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">&amp;#34;pure&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="更新主题">更新主题&lt;/h3>
&lt;p>如果是 clone 了其他人的博客项目进行修改，则需要用以下命令进行初始化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule update --init --recursive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果需要同步主题仓库的最新修改，需要运行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git submodule update --remote
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="hugo-theme-meme主题配置">hugo-theme-meme主题配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 安装meme&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add --depth &lt;span style="color:#d19a66">1&lt;/span> https://github.com/reuixiy/hugo-theme-meme.git themes/meme
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 替换配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm config.toml &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> cp themes/meme/config-examples/zh-cn/config.toml config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="zozo-主题配置">zozo 主题配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/varkai/hugo-theme-zozo themes/zozo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm config.toml &lt;span style="color:#56b6c2">&amp;amp;&amp;amp;&lt;/span> cp themes/zozo/config.toml config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://gojun.me/posts/hello-hugo-blog/" target="_blank" rel="noopener"
>https://gojun.me/posts/hello-hugo-blog/&lt;/a>&lt;/p>
&lt;h3 id="hugo-theme-stack主题配置">Hugo-theme-stack主题配置&lt;/h3>
&lt;p>&lt;a class="link" href="https://stack.jimmycai.com/guide/getting-started" target="_blank" rel="noopener"
>https://stack.jimmycai.com/guide/getting-started&lt;/a>&lt;/p>
&lt;h2 id="新建博文">新建博文&lt;/h2>
&lt;p>完成后，可以通过 &lt;code>hugo new&lt;/code> 命令发布新文章。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hugo new posts/test.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &lt;span style="color:#98c379">&amp;#34;Test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: 2022-10-21T19:00:43+08:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令会在 &lt;code>content&lt;/code> 目录下建立 &lt;code>post&lt;/code> 目录，并在 &lt;code>post&lt;/code> 下生成 &lt;code>test.md&lt;/code> 文件，博文书写就在这个文件里使用 Markdown 语法完成。博文的 front matter 里&lt;code>draft&lt;/code> 选项默认为 &lt;code>true&lt;/code>，需要改为 &lt;code>false&lt;/code> 才能发表博文，建议直接更改上面说的&lt;code>archetypes&lt;/code> 目录下的 &lt;code>default&lt;/code> 文件，把 &lt;code>draft: true&lt;/code> 改为 &lt;code>draft: false&lt;/code>，这样生成的博文就是默认可以发表的。&lt;/p>
&lt;h2 id="生成网页">生成网页&lt;/h2>
&lt;p>为了查看生成的博客的效果，我们在本地编辑调试时可以通过 &lt;code>hugo server&lt;/code> 命令进行本地实时调试预览，无须每次都重新生成。在cmd中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-fallback" data-lang="fallback">hugo server -D
&lt;/code>&lt;/pre>&lt;p>但此时只能在本地访问，如果想发布到 &lt;code>Github Pages&lt;/code> ， 还需要借助 GithubPages 工具。&lt;/p>
&lt;h2 id="配置文件">&lt;strong>配置文件&lt;/strong>&lt;/h2>
&lt;p>打开配置config.toml可以看到很多的参数可以配置，这里只描述最基本的内容，不同的主题可能会支持不同的参数配置，具体请看对应主题的说明文档。baseURL是站点的域名。title是站点的名称。theme是站点的主题。还有关于评论和打赏的相关配置，这些配置都可以参考官网主题的说明。&lt;/p>
&lt;p>每次发布的时候，都需要先执行hugo，把新写的文档按照主题进行渲染，所有生成的文件默认都在当前pulic的子目录下，可以在config里面配置到其他目录。然后把所有新的文件提交到github。提交代码之后，要等一段时间才生效。&lt;/p>
&lt;h2 id="github-actions-部署">github actions 部署&lt;/h2>
&lt;h3 id="两个仓库">两个仓库&lt;/h3>
&lt;p>如果想使用 Github Actions 自动部署 hugo 博客，则最起码需要创建两个 Github 的仓库。&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>第一个，便是存储博客 .md 源文件的地方，其实就是 hugo 系统；&lt;/li>
&lt;li>第二个，则是部署 Github Pages 的仓库，仓库名必须是 &lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>，这是 github 官方要求的。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="最终版">最终版&lt;/h2>
&lt;h3 id="主题">主题&lt;/h3>
&lt;p>使用的是大佬美化后的版本 &lt;a class="link" href="https://github.com/Mantyke/Hugo-stack-theme-mod" target="_blank" rel="noopener"
>Mantyke/Hugo-stack-theme-mod&lt;/a>。&lt;/p>
&lt;p>因为还是想用github工作流，不使用vercel,所以接下来结合前面的多篇文章操作,第一步是clone fork 之后的仓库，然后修改remote为一个创建好的私人仓库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone git@github.com:VastCircle/Hugo-stack.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote set-url origin git@github.com:VastCircle/hugostack.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后通过一系列的git操作将网页部署到gh-pages分支上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>rm -rf public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#39;hugo project init&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## create a new orphand branch (no commit history) named gh-pages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout --orphan gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Unstage all files&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rm -rf --cached &lt;span style="color:#c678dd">$(&lt;/span>git ls-files&lt;span style="color:#c678dd">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Add and commit that file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;INIT: initial commit on gh-pages branch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Push to remote gh-pages branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Return to master branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Add the gh-pages branch of the repository. It will look like a folder named public&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree add --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages --squash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Pull down the file we just committed. This helps avoid merge conflicts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree pull --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## Push the public subtree to the gh-pages branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git subtree push --prefix&lt;span style="color:#56b6c2">=&lt;/span>public git@github.com:VastCircle/hugostack.git gh-pages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>貌似失败了&lt;/p>
&lt;h3 id="再来一次">再来一次&lt;/h3>
&lt;p>这次把public作为一个独立的仓库，通过.gitignore去屏蔽public ,使得 主仓库不包括 public ,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>rm -rf public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 主仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#39;hugo project init&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 推送仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote add origin https://github.com/VastCircle/VastCircle.github.io.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;INIT: initial commit on public&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>shell 脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#deploy.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">echo&lt;/span> -e &lt;span style="color:#98c379">&amp;#34;\033[0;32mDeploying updates to GitHub...\033[0m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Build the project.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo &lt;span style="color:#7f848e"># if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Go To Public folder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Add changes to git.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add -A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Commit changes.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">msg&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#98c379">&amp;#34;rebuilding site `date`&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">if&lt;/span> &lt;span style="color:#56b6c2">[&lt;/span> &lt;span style="color:#e06c75">$#&lt;/span> -eq &lt;span style="color:#d19a66">1&lt;/span> &lt;span style="color:#56b6c2">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">then&lt;/span> &lt;span style="color:#e06c75">msg&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>&lt;span style="color:#e06c75">$1&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#98c379">&amp;#34;&lt;/span>&lt;span style="color:#e06c75">$msg&lt;/span>&lt;span style="color:#98c379">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Push source and build repos.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Come Back&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加-github-action">添加 github action&lt;/h3>
&lt;p>.github/workflows/deploy-site.yaml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>name: deploy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>on:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> push:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> branches: &lt;span style="color:#56b6c2">[&lt;/span>&lt;span style="color:#98c379">&amp;#34;master&amp;#34;&lt;/span>&lt;span style="color:#56b6c2">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workflow_dispatch:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># schedule:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># # Runs everyday at 8:00 AM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># - cron: &amp;#34;0 0 * * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>permissions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contents: &lt;span style="color:#e5c07b">read&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages: write
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id-token: write
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Allow one concurrent deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>concurrency:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group: &lt;span style="color:#98c379">&amp;#34;pages&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cancel-in-progress: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e"># Default to bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaults:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shell: bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jobs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># BUild job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runs-on: ubuntu-latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_VERSION: 0.134.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TZ: America/Los_Angeles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Checkout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: actions/checkout@v3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submodules: &lt;span style="color:#e5c07b">true&lt;/span> &lt;span style="color:#7f848e"># Fetch Hugo themes (true OR recursive)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fetch-depth: &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#7f848e"># Fetch all history for .GitInfo and .Lastmod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Setup Hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: pages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: peaceiris/actions-hugo@v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hugo-version: &lt;span style="color:#98c379">&amp;#39;0.134.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extended: &lt;span style="color:#e5c07b">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Build Hugo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e"># For maximum backward compatibility with Hugo modules&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_ENVIRONMENT: production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HUGO_ENV: production
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run: hugo --minify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Deploy Web
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: peaceiris/actions-gh-pages@v3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PERSONAL_TOKEN: &lt;span style="color:#98c379">${&lt;/span>{ secrets.PERSONAL_TOKEN &lt;span style="color:#98c379">}&lt;/span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXTERNAL_REPOSITORY: VastCircle/VastCircle.github.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUBLISH_BRANCH: master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUBLISH_DIR: ./public
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> commit_message: &lt;span style="color:#98c379">${&lt;/span>{ github.event.head_commit.message &lt;span style="color:#98c379">}&lt;/span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何编写博客">如何编写博客&lt;/h2>
&lt;p>正如同其他的博客，使用 &lt;strong>Markdown 语言&lt;/strong>来编写博客。Markdown 流行且极易上手，因此这里就不多介绍语法，如果不会的可以自己搜索了解。&lt;/p>
&lt;h3 id="使用-hugo-创建文章">使用 Hugo 创建文章&lt;/h3>
&lt;p>在博客根目录下运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>hugo new post/untitled.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么要用 hugo 来新建而不是创建一个 &lt;code>.md&lt;/code> 文件呢？这是因为使用 hugo 创建会自动使用已填入 &lt;code>Front Matter&lt;/code>的模板。&lt;/p>
&lt;p>&lt;code>Front Matter&lt;/code> 用于标识文章的标题、时间等信息，hugo 就是据此来生成静态页面。关于属性的含义和用法可以参考 &lt;a class="link" href="https://www.gohugo.org/doc/content/front-matter/" target="_blank" rel="noopener"
>Hugo 中文文档&lt;/a>。&lt;/p>
&lt;p>模板可以在 &lt;code>\archetypes\default.md&lt;/code> 下找到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; # 标题，创建时自动填充
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description: # 文章简介
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: {{ .Date }} # 日期，创建时自动填充，格式同 2023-01-15T12:00:00+08:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: # 文章的封面，留空就是没有，填文章所在位置的相对地址，通常放在同目录下，
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>math: # 是否启用 KaTex，填 true 启用
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license: # 文章尾部显示的协议，false 为隐藏，其他作为内容，留空就是使用 config.yaml 里默认的
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hidden: false # 是否隐藏，一般用不到
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>comments: true # 因为 bug 所以这个属性只要存在，不管是 true 还是 false 都会导致回复无法显示，需要删掉
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: true # 是否为草稿，建议改为 false 或者删掉这个属性以防止忘记修改，毕竟我们一般都是写好了才部署到服务器上
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了方便，我参考网络以及 stack-mod 的功能对模板进行了一些改造：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slug: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: &amp;#34;{{ .Date }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lastmod: &amp;#34;{{ .Date }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: cover.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>math:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>license:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hidden: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>categories: [&amp;#34;&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tags: [&amp;#34;&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>## 附录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>### 参考文献
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>### 版权信息
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>本文原载于 [&lt;span style="color:#e06c75">reincarnatey.net&lt;/span>](&lt;span style="color:#e06c75">https://blog.reincarnatey.net&lt;/span>)，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此我们可以编写一个批处理程序来快速帮我们生成文章：&lt;/p>
&lt;p>&lt;code>create_post.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>#!/bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 输出提示信息
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> &lt;span style="color:#98c379">&amp;#34;【创建文章】&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 读取用户输入的 Slug
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read -p &lt;span style="color:#98c379">&amp;#34;请输入Slug: &amp;#34;&lt;/span> input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 获取当前日期
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>current_date=$(date +&lt;span style="color:#e06c75">%Y%&lt;/span>m%d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 使用 Hugo 创建新文章
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new post/$current_date-$input/index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 暂停，提示用户操作完成
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read -p &lt;span style="color:#98c379">&amp;#34;按任意键继续...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用此批处理程序生成的文章会创建在 &lt;code>\content\post\2023\0115-test\index.md&lt;/code>，便于我们整理文章资料，同时后续在同目录下存放文章的封面也不会导致内容很乱。&lt;/p>
&lt;h3 id="使用-hugo-创建类别标签">使用 Hugo 创建类别、标签&lt;/h3>
&lt;p>创建 Categories 和 Tag 也同理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>hugo new categories/testcat.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new tags/testtag.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hugo 会自动应用 &lt;code>\archetypes\categories.md&lt;/code> 和 &lt;code>\archetypes\tags.md&lt;/code> 的模板，但是这两个模板都不太好，建议都改为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slug: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>image: cover.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>style:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> background: &amp;#34;#2a9d8f&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color: &amp;#34;#fff&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>create_Categories.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#c678dd">echo&lt;/span> off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> 【创建类别】
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">set&lt;/span> &lt;span style="color:#c678dd">/p&lt;/span> &lt;span style="color:#e06c75">input&lt;/span>= 请输入类别名:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new categories/&lt;span style="color:#e06c75">%input%&lt;/span>/_index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">pause&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>生成的categories就是在改变如下图所示的界面&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 632;
flex-basis: 1518px"
>
&lt;a href="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1.png" data-size="1050x166">
&lt;img src="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1.png"
width="1050"
height="166"
srcset="https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1_hu14227645176143580784.png 480w, https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image1_hu14426535897027265073.png 1024w"
loading="lazy"
alt="image1">
&lt;/a>
&lt;figcaption>image1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;code>create_tag.sh&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-batch" data-lang="batch">&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#c678dd">echo&lt;/span> off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">echo&lt;/span> 【创建标签】
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">set&lt;/span> &lt;span style="color:#c678dd">/p&lt;/span> &lt;span style="color:#e06c75">input&lt;/span>= 请输入标签名:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo new tags/&lt;span style="color:#e06c75">%input%&lt;/span>/_index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">pause&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：如果创建多级文件夹时文章文件名不是 &lt;code>index.md&lt;/code> 或者类别、标签文件名不是 &lt;code>_index.md&lt;/code> 的话，设置封面图片会出现问题。&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>&lt;a class="link" href="https://hk.v2ex.com/t/1009591" target="_blank" rel="noopener"
>https://hk.v2ex.com/t/1009591&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://jianzhnie.github.io/post/hugo_site/" target="_blank" rel="noopener"
>https://jianzhnie.github.io/post/hugo_site/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://hyrtee.github.io/2023/start-blog/" target="_blank" rel="noopener"
>https://hyrtee.github.io/2023/start-blog/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://smc.im/post/deploy-hugo-blog-with-github-actions/" target="_blank" rel="noopener"
>https://smc.im/post/deploy-hugo-blog-with-github-actions/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/" target="_blank" rel="noopener"
>建站技术 | 使用 Hugo + Stack 简单搭建一个博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://kaichu.io/posts/my-first-post/" target="_blank" rel="noopener"
>https://kaichu.io/posts/my-first-post/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://stack.jimmycai.com/" target="_blank" rel="noopener"
>stack 手册&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.oddyti.com/post/hugo-problems/#github%E4%BB%93%E5%BA%93%E5%8F%8C%E5%88%86%E6%94%AF%E5%88%86%E5%88%AB%E5%AD%98%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E9%83%A8%E7%BD%B2%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"
>部署hugo 踩过的坑&lt;/a>_&lt;/p>
&lt;p>&lt;a class="link" href="https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener"
>https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/&lt;/a>&lt;/p></description></item></channel></rss>