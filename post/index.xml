<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on VastCircle's blog</title><link>https://VastCircle.github.io/post/</link><description>Recent content in Posts on VastCircle's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 17 Feb 2025 22:54:00 +0800</lastBuildDate><atom:link href="https://VastCircle.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Boom Lsu</title><link>https://VastCircle.github.io/2025/boom-lsu/</link><pubDate>Mon, 17 Feb 2025 22:54:00 +0800</pubDate><guid>https://VastCircle.github.io/2025/boom-lsu/</guid><description>&lt;h2 id="lsu">lsu&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 69; 
			flex-basis: 167px"
	>
	&lt;a href="https://VastCircle.github.io/2025/boom-lsu/lsu.png" data-size="989x1421">
		&lt;img src="https://VastCircle.github.io/2025/boom-lsu/lsu.png"
			width="989"
			height="1421"
			srcset="https://VastCircle.github.io/2025/boom-lsu/lsu_hu5444454031070159626.png 480w, https://VastCircle.github.io/2025/boom-lsu/lsu_hu9221769314690333098.png 1024w"
			loading="lazy"
			alt="Load Store Unit">
	&lt;/a>
	
	&lt;figcaption>Load Store Unit&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>Constable_improving_performance_and_power__execution</title><link>https://VastCircle.github.io/2025/constable_improving_performance_and_power__execution/</link><pubDate>Sun, 16 Feb 2025 23:45:47 +0800</pubDate><guid>https://VastCircle.github.io/2025/constable_improving_performance_and_power__execution/</guid><description>&lt;p>我们在这项工作中的目标是通过减轻负载数据依赖性和资源依赖性来改善ILP。为此，我们提出了一种称为Constable的纯粹微体系技术，可以安全地消除执行负载指令。 Constable动态标识了从同一负载地址反复获取相同数据的负载指令。我们称这种负载可能稳定。对于每个可能稳定的负载，Constable（1）通过轻巧的硬件结构跟踪对其源体系结构寄存器和内存位置进行修改，并且（2）消除执行加载指令的后续实例，直到将其写入其源寄存器或其源寄存器或商店或Snoop请求到其加载地址。&lt;/p></description></item><item><title>Memory_renaming_fast_early_and_accurate_processing_of_memory_communication</title><link>https://VastCircle.github.io/2025/memory_renaming_fast_early_and_accurate_processing_of_memory_communication/</link><pubDate>Thu, 13 Feb 2025 22:44:11 +0800</pubDate><guid>https://VastCircle.github.io/2025/memory_renaming_fast_early_and_accurate_processing_of_memory_communication/</guid><description>&lt;p>内存重命名应用寄存器访问技术来加载和存储指令，以加快内存流量的处理速度。该方法的工作原理是在 pipeline 的早期准确预测 memory communication ，然后将 communication 重新映射到 fast physical registers 。&lt;/p></description></item><item><title>Memory_dependence_prediction_using_store_sets</title><link>https://VastCircle.github.io/2025/memory_dependence_prediction_using_store_sets/</link><pubDate>Wed, 12 Feb 2025 16:24:37 +0800</pubDate><guid>https://VastCircle.github.io/2025/memory_dependence_prediction_using_store_sets/</guid><description>&lt;h2 id="3-motivation">3. motivation&lt;/h2>
&lt;h3 id="31-no-speculation">3.1 no speculation&lt;/h3>
&lt;p>所有load 指令等到所有先前的store 指令都发出后才能被允许发出&lt;/p>
&lt;h3 id="32-naive-speculation">3.2 naive speculation&lt;/h3>
&lt;p>在寄存器依赖项准备就绪时就执行load,而与内存依赖项无关 。&lt;/p></description></item><item><title>乱序访存单元</title><link>https://VastCircle.github.io/2025/%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/</link><pubDate>Tue, 11 Feb 2025 21:45:42 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/</guid><description>&lt;h2 id="内存访问">内存访问&lt;/h2>
&lt;p>一般来说可以认为，Load 是没有副作用的（实际上，Load 会导致 Cache 加载数据，这也引发了以 Meltdown 为首的一系列漏洞），因此可以很激进地预测执行 Load。但是，Store 是有副作用的，写出去的数据就没法还原了。因此，Store 指令只有在 ROB Head 被 Commit 的时候，才会写入到 Cache 中。&lt;/p></description></item><item><title>分支预测</title><link>https://VastCircle.github.io/2025/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</link><pubDate>Mon, 10 Feb 2025 20:34:57 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</guid><description>&lt;p>还是想好好理解一下分支预测&lt;/p>
&lt;p>可以先看一下&lt;a class="link" href="https://blog.eastonman.com/blog/2023/12/modern-branch-prediction-from-academy-to-industry/" target="_blank" rel="noopener"
 >现代分支预测——从学术界到工业界&lt;/a>&lt;/p>
&lt;h2 id="分支预测的历史">分支预测的历史&lt;/h2>
&lt;h3 id="gshare预测器">gShare预测器&lt;/h3>
&lt;p>全局分支预测器&lt;/p></description></item><item><title>Bingo_Spatial_Data_Prefetcher</title><link>https://VastCircle.github.io/2025/bingo_spatial_data_prefetcher/</link><pubDate>Thu, 06 Feb 2025 21:30:21 +0800</pubDate><guid>https://VastCircle.github.io/2025/bingo_spatial_data_prefetcher/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>应用程序广泛使用具有规则且固定布局的数据对象，这导致内存区域访问模式的重复出现。空间数据预取技术利用这一现象来预取未来的内存引用，并隐藏DRAM访问的长延迟。尽管当前最先进的空间数据预取器在减少数据未命中的数量上是有效的，但我们观察到仍有显著的改进空间。为了选择预取的访问模式，现有的空间预取器将观察到的访问模式与高重复概率的短事件或低重复概率的长事件关联。因此，预取器要么提供低准确性，要么错失重要的预测机会。我们发现，将观察到的空间模式仅与单一事件关联会显著限制空间数据预取器的有效性。本文主张将观察到的空间模式同时与短事件和长事件关联，从而在不失去预测机会的同时实现高准确性。我们提出了Bingo空间数据预取器，在其中短事件和长事件用于选择最佳的预取访问模式。我们提出了一种高效的Bingo设计，仅需一个历史表来维护访问模式与长短事件之间的关联。通过对一组大数据应用程序的详细评估，我们展示了Bingo比没有数据预取器的基线系统提高了60%的性能，并比最好的现有空间数据预取器提高了11%的性能。&lt;/p></description></item><item><title>Spatial_Memory_Streaming</title><link>https://VastCircle.github.io/2025/spatial_memory_streaming/</link><pubDate>Thu, 06 Feb 2025 20:42:37 +0800</pubDate><guid>https://VastCircle.github.io/2025/spatial_memory_streaming/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>先前的研究表明，应用程序的内存访问模式存在较大的空间变化。然而，现代内存系统使用小的固定大小的缓存块，因此无法利用这些变化。增加缓存块大小不仅会极大地增加引脚和互连带宽的需求，还会增加在共享内存多处理器中发生虚假共享的可能性。本文表明，商业工作负载中的内存访问通常表现出跨越大内存区域（例如，几kB）的重复布局，并且这些访问以可以通过基于代码的关联来预测的模式重复出现。我们提出了一种称为空间内存流的实用片上硬件技术，该技术识别代码相关的空间访问模式，并在需求缺失之前将预测的块流式传输到主缓存中。通过对商业和科学应用进行周期精确的全系统多处理器仿真，我们展示了空间内存流平均可以预测58%的L1缓存缺失和65%的芯片外缓存缺失，平均性能提高37%，最佳性能提升可达到307%。&lt;/p></description></item><item><title>General Purpose_graphics_processor_architecture SIMT核心</title><link>https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/</link><pubDate>Tue, 04 Feb 2025 23:43:57 +0800</pubDate><guid>https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-simt%E6%A0%B8%E5%BF%83/</guid><description>&lt;p>在其传统的图形渲染角色中，GPU 访问数据集，例如详细的纹理图，这些数据集太大而无法完全缓存在芯片上。实现在图形中所期望的高性能可编程性，既可以随着图形模式数量的增加而降低验证成本，也可以使游戏开发人员更容易区分他们的产品 [Lindholm et al., 2001]，为此我们有必要采用能够维持大的片外 (&lt;a class="link" href="https://zhida.zhihu.com/search?content_id=201679542&amp;amp;content_type=Article&amp;amp;match_order=1&amp;amp;q=off-chip&amp;amp;zhida_source=entity" target="_blank" rel="noopener"
 >off-chip&lt;/a>) 带宽的架构。因此，今天的 GPU 会同时执行数万个线程。虽然每个线程的片上内存存储量很小，但缓存仍然可以有效地减少大量的片外内存访问。例如，在图形工作负载中，可以由片上缓存捕获的相邻像素操作之间存在显著的空间局部性。&lt;/p></description></item><item><title>General Purpose_graphics_processor_architecture 编程模型</title><link>https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Tue, 04 Feb 2025 21:43:57 +0800</pubDate><guid>https://VastCircle.github.io/2025/general-purpose_graphics_processor_architecture-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>现代 GPU 采用广泛的 SIMD (单指令多数据)硬件来利用 GPU 应用程序中的数据级并行。 CUDA 和 OpenCL 等 GPU 计算 API 不是直接将 SIMD 硬件暴露给程序员，而是具有类似 MIMD（多指令多数据） 的编程模型，允许程序员在 GPU 上启动大量标量线程。这些标量线程中的每一个都可以遵循其独特的执行路径，并且可以访问任意内存位置。在运行时，GPU 硬件在 SIMD 硬件上执行称为 warp（或 AMD 术语中的 wavefront）的标量线程组，以利用它们的规律性和空间局部性。这种执行模型称为单指令、多线程 (SIMT) [Lindholm et al., 2008a, Nickolls and Reusch, 1993]。&lt;/p></description></item><item><title>Boom前端</title><link>https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/</link><pubDate>Mon, 03 Feb 2025 16:37:52 +0800</pubDate><guid>https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/</guid><description>&lt;h2 id="前端流水线">前端流水线&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 168; 
			flex-basis: 403px"
	>
	&lt;a href="https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/image-20250203164015945.png" data-size="1067x635">
		&lt;img src="https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/image-20250203164015945.png"
			width="1067"
			height="635"
			srcset="https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/image-20250203164015945_hu1337519490750167755.png 480w, https://VastCircle.github.io/2025/boom%E5%89%8D%E7%AB%AF/image-20250203164015945_hu3164920159113101758.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>TAGE预测器</title><link>https://VastCircle.github.io/2025/tage%E9%A2%84%E6%B5%8B%E5%99%A8/</link><pubDate>Mon, 03 Feb 2025 15:19:09 +0800</pubDate><guid>https://VastCircle.github.io/2025/tage%E9%A2%84%E6%B5%8B%E5%99%A8/</guid><description>&lt;h2 id="tage设计原理">&lt;strong>TAGE设计原理&lt;/strong>&lt;/h2>
&lt;h3 id="tage设计思路与优势">&lt;strong>TAGE设计思路与优势&lt;/strong>&lt;/h3>
&lt;p>TAGE全名为Tagged Geometric History Branch Predictor，在2006年&lt;em>Journal of Instruction Level Parallelism&lt;/em>上发表的一篇工作中被提出，并且连续赢下了两年的Competition Branch Predictor比赛。TAGE作为一种混合式预测器，其优势在于可以同时根据不同长度的分支历史序列，对某一个分支指令分别进行分支预测，并且对在该分支指令在各个历史序列下的准确率进行评估，并且选择历史准确率最高者作为最终分支预测的判断标准。然而，相较于传统的混合式预测器，TAGE兼具下两个新的设计特性，使得其预测准确率得到可观的提升：&lt;/p></description></item><item><title>Gaze_into_the_Pattern__for_Hardware_Prefetching</title><link>https://VastCircle.github.io/2025/gaze_into_the_pattern__for_hardware_prefetching/</link><pubDate>Sun, 02 Feb 2025 22:53:52 +0800</pubDate><guid>https://VastCircle.github.io/2025/gaze_into_the_pattern__for_hardware_prefetching/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>硬件预取（Hardware prefetching）是隐藏长数据访问延迟最常用的技术之一。为了解决硬件预取面临的挑战，架构师提出在空间区域（spatial region）的粒度上检测并利用空间局部性。当一个新的区域被激活时，他们尝试基于系统级环境特征（如触发指令或数据地址）查找类似的先前访问区域，以进行足迹预测。然而，我们发现这种基于上下文的预测无法捕捉访问模式的本质特征，导致灵活性和实用性受限，并使预取性能次优。在本文中，我们受到存储访问的时间特性的启发，注意到空间足迹内部的时间相关性是空间模式的关键特征。为此，我们提出了一种简单高效的硬件空间预取器——Gaze，它巧妙地利用足迹内部的时间相关性来高效表征空间模式。同时，我们发现利用由空间流（spatial streaming）生成的空间足迹时，存在一个独特但未解决的挑战，即这些足迹表现出极高的访问密度。因此，我们进一步为 Gaze 设计了一个专门的两阶段方法，以缓解传统方案中常见的过度预取（over-prefetching）问题。我们进行了全面且多样化的实验，结果表明 Gaze 能够在更广泛的场景中有效提升性能。具体而言，与最新的低成本方案 PMP 和 vBerti 相比，Gaze 在单核环境下分别提升 5.7% 和 5.4%，在八核环境下分别提升 11.4% 和 8.8%。&lt;/p></description></item><item><title>香山邀请报告——乱序访存单元</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/</link><pubDate>Sun, 02 Feb 2025 16:33:38 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/</guid><description>&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 176; 
			flex-basis: 423px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163412083.png" data-size="1493x847">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163412083.png"
			width="1493"
			height="847"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163412083_hu16096562521547637820.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163412083_hu15276950146423262980.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 178; 
			flex-basis: 427px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163458441.png" data-size="1512x848">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163458441.png"
			width="1512"
			height="848"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163458441_hu13947805208678613789.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E4%B9%B1%E5%BA%8F%E8%AE%BF%E5%AD%98%E5%8D%95%E5%85%83/image-20250202163458441_hu17233388361454517806.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Scala_var</title><link>https://VastCircle.github.io/2025/scala_var/</link><pubDate>Thu, 30 Jan 2025 23:55:06 +0800</pubDate><guid>https://VastCircle.github.io/2025/scala_var/</guid><description>&lt;p>在boom的代码中看到挺多var的使用，来记录一下&lt;/p>
&lt;p>var类型:在处理过程中可以多次重写&lt;/p>
&lt;p>val类型:在处理过程中只能分配一次&lt;/p>
&lt;p>例如，在表搜索中，考虑存储为 ID 和值对的类似散列的结构，并搜索与&lt;a class="link" href="http://d.hatena.ne.jp/keyword/%A5%CF%A5%C3%A5%B7%A5%E5%C3%CD" target="_blank" rel="noopener"
 >散列值&lt;/a>匹配的地址值。 如果同一个ID在表中多次存在，则表中地址较大的值优先。&lt;/p></description></item><item><title>A_Primer_on_Hardware_prefetching读书笔记1</title><link>https://VastCircle.github.io/2025/a_primer_on_hardware_prefetching%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</link><pubDate>Sat, 25 Jan 2025 23:47:50 +0800</pubDate><guid>https://VastCircle.github.io/2025/a_primer_on_hardware_prefetching%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>香山邀请昆前端设计</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/</link><pubDate>Sat, 25 Jan 2025 20:04:28 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/</guid><description>&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 175; 
			flex-basis: 420px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201649546.png" data-size="1289x735">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201649546.png"
			width="1289"
			height="735"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201649546_hu5313535549544468500.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201649546_hu12494660225624797019.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 178; 
			flex-basis: 427px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201806026.png" data-size="1288x723">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201806026.png"
			width="1288"
			height="723"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201806026_hu3282352754963242587.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%98%86%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/image-20250125201806026_hu7052386201774002155.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Big Small Runahead</title><link>https://VastCircle.github.io/2025/big-small-runahead/</link><pubDate>Sat, 25 Jan 2025 18:38:54 +0800</pubDate><guid>https://VastCircle.github.io/2025/big-small-runahead/</guid><description>&lt;p>在大核里&lt;/p>
&lt;hr>
&lt;p>stride load&lt;/p>
&lt;p>RPT : ( pc : 40 addr : 40 stride : 16 state : 2 最内层检测位 : 1)&lt;/p>
&lt;p>当发现检测位为1，可以去清空VTT和FLR ，重新开始&lt;/p>
&lt;p>每当重新遇到启动discoder mode 的pc时， 会清空所有的检测位&lt;/p></description></item><item><title>香山源代码剖析——分支预测单元</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/</link><pubDate>Sat, 25 Jan 2025 15:13:03 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/</guid><description>&lt;h2 id="b站学习">b站学习&lt;/h2>
&lt;p>分支预测块&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 193; 
			flex-basis: 465px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/image-20250125181359394.png" data-size="1020x526">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/image-20250125181359394.png"
			width="1020"
			height="526"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/image-20250125181359394_hu13373882800903922538.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83/image-20250125181359394_hu2780647712471053194.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Scalar_vector_runahead</title><link>https://VastCircle.github.io/2025/scalar_vector_runahead/</link><pubDate>Thu, 23 Jan 2025 22:05:34 +0800</pubDate><guid>https://VastCircle.github.io/2025/scalar_vector_runahead/</guid><description>&lt;p>标量向量运行前 （SVR） 通过搭载处理器上执行的现有指令，在简单的有序内核上提取高内存级并行性，从而导致将来的不规则内存访问。SVR 执行多个瞬态、独立、并行的内存访问实例及其链，这些实例从预测的归纳变量的不同值启动，以将相互独立的内存访问彼此相邻移动，以隐藏依赖的停顿。SVR 的硬件开销仅为 2 KiB，性能比基准 3 宽的有序内核高 3.2× 比完全无序内核高 1.3× 倍，同时能耗减半。将开销增加到 9 KiB 以应对更大的寄存器文件，SVR 可以将相对于乱序内核的加速比扩展到 1.7×。&lt;/p></description></item><item><title>Prefetch的一些小思考</title><link>https://VastCircle.github.io/2025/prefetch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/</link><pubDate>Wed, 22 Jan 2025 16:44:10 +0800</pubDate><guid>https://VastCircle.github.io/2025/prefetch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/</guid><description>&lt;h2 id="dvr的思路">DVR的思路&lt;/h2>
&lt;p>1.discover mode&lt;/p>
&lt;p>RPT : ( pc : 40 addr : 40 stride : 16 state : 2 最内层检测位 : 1)&lt;/p>
&lt;p>DVR是引入了一个子线程，线程是跑在同一个内核里的， 所以它多搞了一组寄存器 ，用来实现SIMT , 单指令多线程&lt;/p></description></item><item><title>Boom代码阅读——exu</title><link>https://VastCircle.github.io/2025/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BBexu/</link><pubDate>Wed, 22 Jan 2025 15:46:47 +0800</pubDate><guid>https://VastCircle.github.io/2025/boom%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BBexu/</guid><description>&lt;h2 id="dispatch">dispatch&lt;/h2>
&lt;p>两种dispatch , BasicDispatch必须按照特定的标号来dispatch , CompactingDispather coreWidth的标号和dispatchWidth不需要完全对应&lt;/p></description></item><item><title>香山邀请报告——缓存基础和香山缓存</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/</link><pubDate>Sat, 18 Jan 2025 22:20:27 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/</guid><description>&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 188; 
			flex-basis: 452px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118225744967.png" data-size="1294x687">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118225744967.png"
			width="1294"
			height="687"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118225744967_hu17796226399376657198.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118225744967_hu8348936626104533362.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 176; 
			flex-basis: 424px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118230002923.png" data-size="1309x740">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118230002923.png"
			width="1309"
			height="740"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118230002923_hu9798892846660929321.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E5%92%8C%E9%A6%99%E5%B1%B1%E7%BC%93%E5%AD%98/image-20250118230002923_hu6109206764932188994.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>香山邀请报告——处理器的性能测算基础</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 18 Jan 2025 20:40:58 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/</guid><description>&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 190; 
			flex-basis: 456px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204201260.png" data-size="1448x762">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204201260.png"
			width="1448"
			height="762"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204201260_hu7806315297422038694.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204201260_hu15255998948895200954.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 224; 
			flex-basis: 539px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204919400.png" data-size="1388x618">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204919400.png"
			width="1388"
			height="618"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204919400_hu13040004070214174965.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%9F%BA%E7%A1%80/image-20250118204919400_hu9682467326500832916.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>香山邀请报告——向量扩展的设计和实现</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 18 Jan 2025 17:07:03 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="香山ppt">香山ppt&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 175; 
			flex-basis: 420px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/image-20250118170720617.png" data-size="1069x610">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/image-20250118170720617.png"
			width="1069"
			height="610"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/image-20250118170720617_hu12962601924616772917.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E9%82%80%E8%AF%B7%E6%8A%A5%E5%91%8A%E5%90%91%E9%87%8F%E6%89%A9%E5%B1%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/image-20250118170720617_hu8514861846678028089.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>香山源代码剖析——指令的执行</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/</link><pubDate>Sat, 18 Jan 2025 12:22:33 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/</guid><description>&lt;h2 id="来自b站">来自b站&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 190; 
			flex-basis: 457px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/image-20250118125745389.png" data-size="1248x654">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/image-20250118125745389.png"
			width="1248"
			height="654"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/image-20250118125745389_hu6455103444142149985.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C/image-20250118125745389_hu13408301655024333974.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>香山源代码剖析——执行结果的回写和commit</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/</link><pubDate>Thu, 16 Jan 2025 00:17:27 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/</guid><description>&lt;h2 id="rob">ROB&lt;/h2>
&lt;h3 id="来自香山视频">来自香山视频&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 183; 
			flex-basis: 440px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/image-20250121232917749.png" data-size="1600x872">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/image-20250121232917749.png"
			width="1600"
			height="872"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/image-20250121232917749_hu16240116585783215136.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9B%9E%E5%86%99%E5%92%8Ccommit/image-20250121232917749_hu2374164839472895496.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>香山源代码剖析——指令的译码和派发</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/</link><pubDate>Tue, 14 Jan 2025 17:19:27 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/</guid><description>&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 375; 
			flex-basis: 900px"
	>
	&lt;a href="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/image-20250114181936853.png" data-size="1028x274">
		&lt;img src="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/image-20250114181936853.png"
			width="1028"
			height="274"
			srcset="https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/image-20250114181936853_hu6670905778379539498.png 480w, https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%91%E7%A0%81%E5%92%8C%E6%B4%BE%E5%8F%91/image-20250114181936853_hu6764138659097728431.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;p>译码阶段是香山CPU流水线后端的第一站，第一个阶段。它的输入来自于前端的指令缓冲器ibuffer ,从Ibuffer读出时由其将来自IFU的指令加预译码信息一起组装在一个CtrlFlow对象中，又由于流水线后端的宽度是6,所有译码阶段的输入就是6个CtrlFlow对象，译码阶段的输出即译码结果去往Rename中，是一排CfCtrl对象，CfCtrl就是CtrlFlow + CtrlSignals, 译码产生的结果就在CtrlSignals中，连同CtrlFlow一起往下游送。&lt;/p></description></item><item><title>香山源代码剖析——PMA和PMP</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90pma%E5%92%8Cpmp/</link><pubDate>Sun, 12 Jan 2025 23:49:47 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90pma%E5%92%8Cpmp/</guid><description>&lt;p>PMP : 物理存储保护（Physical Memory Protection) module ,它将所有的访问权限都集中起来&lt;/p>
&lt;p>PMA:物理存储属性（Physical Memory Attributes),PMP实施存储空间保护的依据&lt;/p></description></item><item><title>香山源代码剖析——香山SOC的顶层</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E9%A6%99%E5%B1%B1soc%E7%9A%84%E9%A1%B6%E5%B1%82/</link><pubDate>Sun, 12 Jan 2025 23:26:10 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E9%A6%99%E5%B1%B1soc%E7%9A%84%E9%A1%B6%E5%B1%82/</guid><description>&lt;p>// top.scala里包含香山的头文件&lt;/p>
&lt;p>// 有一个XSCore.scala文件&lt;/p>
&lt;h2 id="xstop和xscore">XSTop和XSCore&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">XSCore&lt;/span>&lt;span style="color:#56b6c2">()(&lt;/span>&lt;span style="color:#c678dd">implicit&lt;/span> &lt;span style="color:#e06c75">p&lt;/span>&lt;span style="color:#c678dd">:&lt;/span> &lt;span style="color:#e5c07b">config.Parameters&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span> &lt;span style="color:#c678dd">extends&lt;/span> &lt;span style="color:#e5c07b">XSCoreBase&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">with&lt;/span> &lt;span style="color:#e5c07b">HasXSDts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">lazy&lt;/span> &lt;span style="color:#c678dd">val&lt;/span> &lt;span style="color:#e06c75">module&lt;/span> &lt;span style="color:#c678dd">=&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e5c07b">XSCoreImp&lt;/span>&lt;span style="color:#56b6c2">(&lt;/span>&lt;span style="color:#c678dd">this&lt;/span>&lt;span style="color:#56b6c2">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>Chisel_diplomacy框架</title><link>https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/</link><pubDate>Fri, 10 Jan 2025 14:14:12 +0800</pubDate><guid>https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/</guid><description>&lt;p>Diplomacy将模块的Port抽象为节点(Node),然后进行协商，自动找到最优的线宽，以减少复用模块时需要修改的线宽代码&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 206; 
			flex-basis: 496px"
	>
	&lt;a href="https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/image-20250110144009550.png" data-size="858x415">
		&lt;img src="https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/image-20250110144009550.png"
			width="858"
			height="415"
			srcset="https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/image-20250110144009550_hu13342639607822788397.png 480w, https://VastCircle.github.io/2025/chisel_diplomacy%E6%A1%86%E6%9E%B6/image-20250110144009550_hu10756195594024898727.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>笔记</title><link>https://VastCircle.github.io/2025/%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 08 Jan 2025 15:51:40 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>大语言模型加速器&lt;/p>
&lt;p>llm for chip design&lt;/p>
&lt;p>全加操作&lt;/p>
&lt;p>内存利用率&lt;/p>
&lt;p>稀疏&lt;/p>
&lt;p>稀疏度要很高才可以打平这个帐&lt;/p>
&lt;p>a55&lt;/p>
&lt;p>协处理器&lt;/p>
&lt;p>共享share的l1&lt;/p>
&lt;p>smt提供一个核&lt;/p>
&lt;p>希望某一些数据不要被踢走&lt;/p></description></item><item><title>香山源代码剖析——存储子系统与Tilelink</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%98%E5%82%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8Etilelink/</link><pubDate>Tue, 07 Jan 2025 23:02:49 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%98%E5%82%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8Etilelink/</guid><description>&lt;h2 id="简介">简介&lt;/h2>
&lt;p>根据操作的目的和作用，可以把 Link 上的操作分成三大类：&lt;/p>
&lt;p>A 类， A 表示 Access 。凡用来从存储器读写数据的操作都属于 A 类，具体有 Get 、 Put 、 Atomic 等。&lt;/p></description></item><item><title>香山源代码剖析-参数协调与Diplomacy</title><link>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-%E5%8F%82%E6%95%B0%E5%8D%8F%E8%B0%83%E4%B8%8Ediplomacy/</link><pubDate>Tue, 07 Jan 2025 20:20:37 +0800</pubDate><guid>https://VastCircle.github.io/2025/%E9%A6%99%E5%B1%B1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-%E5%8F%82%E6%95%B0%E5%8D%8F%E8%B0%83%E4%B8%8Ediplomacy/</guid><description>&lt;h2 id="简述">简述&lt;/h2>
&lt;p>在Diplomacy的术语中，模块称为“节点”。Diplomacy还把不同模块的按其输入输出抽象成不同类型的节点。 输入端和输出端数量相等的模块抽象成MixedAdapterNode或者AdapterNode,只有输入没有输出的节点抽象为SinkNode.只有输出没有输入的节点抽象为SouceNode&lt;/p></description></item><item><title>Neovim配置</title><link>https://VastCircle.github.io/2025/neovim%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 04 Jan 2025 14:11:15 +0800</pubDate><guid>https://VastCircle.github.io/2025/neovim%E9%85%8D%E7%BD%AE/</guid><description>&lt;h2 id="安装nvim">安装nvim&lt;/h2>
&lt;h2 id="安装kitty-终端">安装kitty 终端&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl -L https://sw.kovidgoyal.net/kitty/installer.sh | sh /dev/stdin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装wezterm-终端">安装wezterm 终端&lt;/h2>
&lt;p>&lt;a class="link" href="https://wezfurlong.org/wezterm/install/linux.html#pre-built-deb-packages" target="_blank" rel="noopener"
 >https://wezfurlong.org/wezterm/install/linux.html#pre-built-deb-packages&lt;/a>&lt;/p></description></item><item><title>Rocketl1l2的交互</title><link>https://VastCircle.github.io/2024/rocketl1l2%E7%9A%84%E4%BA%A4%E4%BA%92/</link><pubDate>Sat, 28 Dec 2024 00:38:28 +0800</pubDate><guid>https://VastCircle.github.io/2024/rocketl1l2%E7%9A%84%E4%BA%A4%E4%BA%92/</guid><description>&lt;h2 id="测试程序">测试程序&lt;/h2>
&lt;p>以下程序基本能使得在后续的store中能够造成cache miss&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> ; &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">128&lt;/span> ; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>) { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#7f848e">// 填8个字节 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#e06c75">j&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> ; &lt;span style="color:#e06c75">j&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">8&lt;/span> ; &lt;span style="color:#e06c75">j&lt;/span> &lt;span style="color:#56b6c2">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">Table&lt;/span>[(&lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">11&lt;/span>) &lt;span style="color:#56b6c2">+&lt;/span> &lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">+&lt;/span> &lt;span style="color:#e06c75">j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// 再读一次,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> ; &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">128&lt;/span> ; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">Table&lt;/span>[&lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">11&lt;/span>] &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>Spik_cache的交互</title><link>https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/</link><pubDate>Fri, 27 Dec 2024 17:34:48 +0800</pubDate><guid>https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/</guid><description>&lt;p>spike 的cache 为什么会出现 l2 miss的次数高于l1 ,按理来说只有l1 miss才有机会去读l2&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 376; 
			flex-basis: 904px"
	>
	&lt;a href="https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/image-20241227174225683.png" data-size="671x178">
		&lt;img src="https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/image-20241227174225683.png"
			width="671"
			height="178"
			srcset="https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/image-20241227174225683_hu6466349755934550054.png 480w, https://VastCircle.github.io/2024/spik_cache%E7%9A%84%E4%BA%A4%E4%BA%92/image-20241227174225683_hu14082263635862480712.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>服务器配置</title><link>https://VastCircle.github.io/2024/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 25 Dec 2024 01:25:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</guid><description>&lt;h2 id="vim">vim&lt;/h2>
&lt;p>安装插件 vim-plug&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener"
 >https://github.com/junegunn/vim-plug&lt;/a>&lt;/p>
&lt;p>安装主题&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/kabbamine/yowish.vim?tab=readme-ov-file" target="_blank" rel="noopener"
 >https://github.com/kabbamine/yowish.vim?tab=readme-ov-file&lt;/a>&lt;/p>
&lt;h2 id="zsh安装">zsh安装&lt;/h2>
&lt;p>&lt;a class="link" href="https://patzer0.com/archives/ubuntu-install-font-for-user-or-system" target="_blank" rel="noopener"
 >安装字体&lt;/a>&lt;/p></description></item><item><title>chipyard and Firesim</title><link>https://VastCircle.github.io/2024/firesim/</link><pubDate>Tue, 24 Dec 2024 21:35:28 +0800</pubDate><guid>https://VastCircle.github.io/2024/firesim/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;h3 id="1运行firesim-runworkload-时报错">1.运行firesim runworkload 时报错&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 352; 
			flex-basis: 845px"
	>
	&lt;a href="https://VastCircle.github.io/2024/firesim/image-20241224213818951.png" data-size="1420x403">
		&lt;img src="https://VastCircle.github.io/2024/firesim/image-20241224213818951.png"
			width="1420"
			height="403"
			srcset="https://VastCircle.github.io/2024/firesim/image-20241224213818951_hu16838008880615851633.png 480w, https://VastCircle.github.io/2024/firesim/image-20241224213818951_hu15872417008841820697.png 1024w"
			loading="lazy"
			alt="image-20241224213818951">
	&lt;/a>
	
	&lt;figcaption>image-20241224213818951&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>Rocket_chip_hardware_performance_monitor</title><link>https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/</link><pubDate>Sun, 22 Dec 2024 15:05:57 +0800</pubDate><guid>https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/</guid><description>&lt;h2 id="hardware-performance-monitor">Hardware Performance Monitor&lt;/h2>
&lt;p>the hardware performance monitor includes 29 additional 64-bit event counters,mhpmcounter3-mhpmcounter . The event selector CSRs , mhpmevent3-mhpmevent31, are MXLEN-bit WARL register tghat control which event causes the corresponding counter to increment&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 320; 
			flex-basis: 769px"
	>
	&lt;a href="https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/image-20241222151014944.png" data-size="798x249">
		&lt;img src="https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/image-20241222151014944.png"
			width="798"
			height="249"
			srcset="https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/image-20241222151014944_hu189879034609081359.png 480w, https://VastCircle.github.io/2024/rocket_chip_hardware_performance_monitor/image-20241222151014944_hu17809269090014267676.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>工作负载分析</title><link>https://VastCircle.github.io/2024/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E5%88%86%E6%9E%90/</link><pubDate>Thu, 19 Dec 2024 16:52:19 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E5%88%86%E6%9E%90/</guid><description>&lt;h2 id="nas-sys">nas-sys&lt;/h2>
&lt;h2 id="randacc-no">randacc-no&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">static&lt;/span> &lt;span style="color:#e5c07b">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#61afef;font-weight:bold">RandomAccessUpdate&lt;/span>(&lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#e06c75">TableSize&lt;/span>, &lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#56b6c2">*&lt;/span>&lt;span style="color:#e06c75">Table&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#e06c75">i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#d19a66">128&lt;/span>]; &lt;span style="color:#7f848e">/* Current random numbers */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#e06c75">j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">// ran[j]保存生成的一些伪随机数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">&amp;lt;&lt;/span>&lt;span style="color:#d19a66">128&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">HPCC_starts&lt;/span> ((&lt;span style="color:#e06c75">NUPDATE&lt;/span>&lt;span style="color:#56b6c2">/&lt;/span>&lt;span style="color:#d19a66">128&lt;/span>) &lt;span style="color:#56b6c2">*&lt;/span> &lt;span style="color:#e06c75">j&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">&amp;lt;&lt;/span>&lt;span style="color:#e06c75">NUPDATE&lt;/span>&lt;span style="color:#56b6c2">/&lt;/span>&lt;span style="color:#d19a66">128&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">&amp;lt;&lt;/span>&lt;span style="color:#d19a66">128&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">=&lt;/span> (&lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>) &lt;span style="color:#56b6c2">^&lt;/span> ((&lt;span style="color:#e06c75">s64Int&lt;/span>) &lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#56b6c2">?&lt;/span> &lt;span style="color:#e06c75">POLY&lt;/span> : &lt;span style="color:#d19a66">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">Table&lt;/span>[&lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>] &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> (&lt;span style="color:#e06c75">TableSize&lt;/span>&lt;span style="color:#56b6c2">-&lt;/span>&lt;span style="color:#d19a66">1&lt;/span>)] &lt;span style="color:#56b6c2">^=&lt;/span> &lt;span style="color:#e06c75">ran&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 伪随机数生成 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#61afef;font-weight:bold">HPCC_starts&lt;/span>(&lt;span style="color:#e06c75">s64Int&lt;/span> &lt;span style="color:#e06c75">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#e06c75">i&lt;/span>, &lt;span style="color:#e06c75">j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#e06c75">m2&lt;/span>[&lt;span style="color:#d19a66">64&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">u64Int&lt;/span> &lt;span style="color:#e06c75">temp&lt;/span>, &lt;span style="color:#e06c75">ran&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">while&lt;/span> (&lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>) &lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">+=&lt;/span> &lt;span style="color:#e06c75">PERIOD&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">while&lt;/span> (&lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&lt;/span> &lt;span style="color:#e06c75">PERIOD&lt;/span>) &lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">-=&lt;/span> &lt;span style="color:#e06c75">PERIOD&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">if&lt;/span> (&lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">==&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>) &lt;span style="color:#c678dd">return&lt;/span> &lt;span style="color:#d19a66">0x1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0x1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">&amp;lt;&lt;/span>&lt;span style="color:#d19a66">64&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">m2&lt;/span>[&lt;span style="color:#e06c75">i&lt;/span>] &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> (&lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>) &lt;span style="color:#56b6c2">^&lt;/span> ((&lt;span style="color:#e06c75">s64Int&lt;/span>) &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#56b6c2">?&lt;/span> &lt;span style="color:#e06c75">POLY&lt;/span> : &lt;span style="color:#d19a66">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> (&lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>) &lt;span style="color:#56b6c2">^&lt;/span> ((&lt;span style="color:#e06c75">s64Int&lt;/span>) &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#56b6c2">?&lt;/span> &lt;span style="color:#e06c75">POLY&lt;/span> : &lt;span style="color:#d19a66">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">62&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">&amp;gt;=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">i&lt;/span>&lt;span style="color:#56b6c2">--&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">if&lt;/span> ((&lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">i&lt;/span>) &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0x2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">while&lt;/span> (&lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">for&lt;/span> (&lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">=&lt;/span>&lt;span style="color:#d19a66">0&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">&amp;lt;&lt;/span>&lt;span style="color:#d19a66">64&lt;/span>; &lt;span style="color:#e06c75">j&lt;/span>&lt;span style="color:#56b6c2">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">if&lt;/span> ((&lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">j&lt;/span>) &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">temp&lt;/span> &lt;span style="color:#56b6c2">^=&lt;/span> &lt;span style="color:#e06c75">m2&lt;/span>[&lt;span style="color:#e06c75">j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#e06c75">temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">i&lt;/span> &lt;span style="color:#56b6c2">-=&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">if&lt;/span> ((&lt;span style="color:#e06c75">n&lt;/span> &lt;span style="color:#56b6c2">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#e06c75">i&lt;/span>) &lt;span style="color:#56b6c2">&amp;amp;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> (&lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>) &lt;span style="color:#56b6c2">^&lt;/span> ((&lt;span style="color:#e06c75">s64Int&lt;/span>) &lt;span style="color:#e06c75">ran&lt;/span> &lt;span style="color:#56b6c2">&amp;lt;&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#56b6c2">?&lt;/span> &lt;span style="color:#e06c75">POLY&lt;/span> : &lt;span style="color:#d19a66">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">return&lt;/span> &lt;span style="color:#e06c75">ran&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>SIMD和Vector</title><link>https://VastCircle.github.io/2024/simd/</link><pubDate>Wed, 18 Dec 2024 17:03:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/simd/</guid><description>&lt;h2 id="simd技术简介">SIMD技术简介&lt;/h2>
&lt;p>&lt;strong>传统的通用处理器都是标量处理器，一条指令执行只得到一个数据结果&lt;/strong>。但对于图像、信号处理等应用，存在大量的数据并行性计算操作，这个时候，提高数据的并行性从而提高运算的性能就显得尤为重要。因此，SIMD技术应运而生。&lt;/p></description></item><item><title>Vector_runahead</title><link>https://VastCircle.github.io/2024/vector_runahead/</link><pubDate>Tue, 17 Dec 2024 14:50:55 +0800</pubDate><guid>https://VastCircle.github.io/2024/vector_runahead/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>内存墙对许多现代工作负载的性能造成了重大限制。这些应用程序具有复杂的依赖间接内存访问链，即使是最先进的微架构预取器也无法获取。结果是，当前无序超标量处理器的大部分时间都处于停滞状态。但是，为了实现高内存级别的并行性，标准的提前执行会在缓存未命中之前跳过。在现代工作负载中，这意味着它只预取每个依赖链中的第一个缺少缓存的load 。我们认为，这不是一个根本的限制。如果 runahead 是在 cache 未命中时停止以生成依赖链load ，那么如果它可以同时在多个 cache 上停止，则可以重新获得性能。&lt;/p></description></item><item><title>Decoupled_Vector_Runahead</title><link>https://VastCircle.github.io/2024/decoupled_vector_runahead/</link><pubDate>Tue, 17 Dec 2024 12:28:27 +0800</pubDate><guid>https://VastCircle.github.io/2024/decoupled_vector_runahead/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>我们提出了解耦矢量预取 （DVR），这是一种内核内预取技术，与主应用程序线程分开执行，它利用大量内存级并行性来提高具有间接内存访问功能的应用程序的性能。DVR 在运行时动态推断循环边界，识别跨步负载，并矢量化作为间接链一部分的后续指令。它会主动为将来的负载发出内存访问，即使无序内核尚未停止，也会将其数据带入 L1 缓存，从而为主线程提供及时的预取。DVR 可以在运行时调整矢量化程度，在内部循环的多次调用中对同一间接内存访问链进行矢量化，并有效地处理沿矢量化链的分支发散。DVR 作为按需、推测性、按顺序、轻量级硬件子线程与内核内的主线程一起运行，并且产生的最小硬件开销仅为 1139 字节。相对于大型超标量 5 宽无序基线和 Vector Runahead（一种用于加速乱序处理器上的间接内存访问的最新微架构技术），DVR 为一组图形分析、数据库和 HPC 工作负载提供了 2.4× 和 2× 的性能。&lt;/p></description></item><item><title>Secure_prefetching_for_secure_cache_systems</title><link>https://VastCircle.github.io/2024/secure_prefetching_for_secure_cache_systems/</link><pubDate>Sat, 14 Dec 2024 13:17:45 +0800</pubDate><guid>https://VastCircle.github.io/2024/secure_prefetching_for_secure_cache_systems/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>像Spectre及其变种这样的瞬态执行攻击可能通过缓存层次结构导致信息泄漏。缓解推测执行攻击的技术分为两类：基于延迟的技术和不可见推测技术。像GhostMinion这样的基于不可见推测的技术是高性能且安全的技术，可以缓解所有类型的推测执行攻击。与缓存系统类似，硬件预取器也可能导致推测性信息泄漏。为了解决这个问题，GhostMinion提倡在缓存系统中基于严格排序的提交时预取。我们的实验表明，GhostMinion缓存系统与硬件预取器之间的互动产生了负面影响，导致不同缓存层次之间的冗余流量。这些流量会引起争用，并增加丢失延迟，从而导致性能下降。接下来，我们观察到，由GhostMinion强制执行的提交时预取导致性能损失，因为它影响了预取器的及时性。我们首次对先进的预取技术和安全缓存系统之间的互动进行了彻底分析。在此基础上，我们提出了两种微架构解决方案，确保在设计安全预取器时能够提供高性能，同时保证安全的缓存系统。第一种解决方案通过非推测性更新缓存层次结构时检测和过滤冗余流量。第二种解决方案确保预取器的及时性，以弥补在提交时触发预取请求的延迟，从而实现既安全又高效的预取器。总体而言，我们的改进是安全的，并且在硬件预取器和安全缓存系统之间提供了协同作用。我们的实验表明，在使用先进的预取器的情况下，我们的过滤器始终能提高像GhostMinion这样的安全缓存系统的性能（对于单核系统提高1.9%，对于多核系统提高19.0%，使用的是性能最好的预取器）。我们还观察到过滤器与我们提出的安全预取器之间的协同效应，进一步提高了性能，单核和多核系统分别提高了6.3%和23.0%（相比于最好的预取器）。我们的改进极为轻量，每个核心的存储开销为0.59 KB。&lt;/p></description></item><item><title>Failed_to_connetct_socket</title><link>https://VastCircle.github.io/2024/failed_to_connetct_socket/</link><pubDate>Wed, 11 Dec 2024 21:00:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/failed_to_connetct_socket/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Ssh版本不匹配</title><link>https://VastCircle.github.io/2024/ssh%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D/</link><pubDate>Wed, 11 Dec 2024 20:58:55 +0800</pubDate><guid>https://VastCircle.github.io/2024/ssh%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Gem5_修改扩展</title><link>https://VastCircle.github.io/2024/gem5_%E4%BF%AE%E6%94%B9%E6%89%A9%E5%B1%95/</link><pubDate>Wed, 11 Dec 2024 20:52:34 +0800</pubDate><guid>https://VastCircle.github.io/2024/gem5_%E4%BF%AE%E6%94%B9%E6%89%A9%E5%B1%95/</guid><description>&lt;h2 id="create-a-simple-simobject">create a simple simobject&lt;/h2>
&lt;h3 id="create-a-python-class">create a python class&lt;/h3>
&lt;p>每个 SimObject 都有一个与之关联的 Python 类。此 Python 类描述了 SimObject 的参数，这些参数可以通过 Python 配置文件进行控制.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">from&lt;/span> &lt;span style="color:#e06c75">m5.params&lt;/span> &lt;span style="color:#c678dd">import&lt;/span> &lt;span style="color:#56b6c2">*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">from&lt;/span> &lt;span style="color:#e06c75">m5.SimObject&lt;/span> &lt;span style="color:#c678dd">import&lt;/span> &lt;span style="color:#e06c75">SimObject&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">class&lt;/span> &lt;span style="color:#e5c07b">HelloObject&lt;/span>(&lt;span style="color:#e06c75">SimObject&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">type&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">&amp;#39;HelloObject&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">cxx_header&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">&amp;#34;learning_gem5/part2/hello_object.hh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e06c75">cxx_class&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#98c379">&amp;#34;gem5::HelloObject&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>Gem5_learning</title><link>https://VastCircle.github.io/2024/gem5_learning/</link><pubDate>Mon, 09 Dec 2024 15:11:13 +0800</pubDate><guid>https://VastCircle.github.io/2024/gem5_learning/</guid><description>&lt;h2 id="配置">配置&lt;/h2>
&lt;p>使用如下命令去安装gem5&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/gem5/gem5
&lt;/code>&lt;/pre>&lt;p>安装依赖 &lt;a class="link" href="https://www.gem5.org/documentation/general_docs/building" target="_blank" rel="noopener"
 >https://www.gem5.org/documentation/general_docs/building&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt install build-essential git m4 scons zlib1g zlib1g-dev &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev &lt;span style="color:#98c379">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#98c379">&lt;/span> python3-dev libboost-all-dev pkg-config python3-tk
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers</title><link>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</link><pubDate>Sat, 07 Dec 2024 20:28:43 +0800</pubDate><guid>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</guid><description>&lt;h1 id="paraverser利用异构并行性实现数据中心中经济实惠的故障检测">ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。&lt;/p></description></item><item><title>Filemonitor</title><link>https://VastCircle.github.io/2024/filemonitor/</link><pubDate>Fri, 06 Dec 2024 13:29:58 +0800</pubDate><guid>https://VastCircle.github.io/2024/filemonitor/</guid><description>&lt;p>&lt;a class="link" href="https://github.com/TheKingOfDuck/FileMonitor?tab=readme-ov-file" target="_blank" rel="noopener"
 >https://github.com/TheKingOfDuck/FileMonitor?tab=readme-ov-file&lt;/a>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Chipyard_boot_linux</title><link>https://VastCircle.github.io/2024/chipyard_boot_linux/</link><pubDate>Wed, 04 Dec 2024 21:26:52 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard_boot_linux/</guid><description>&lt;h2 id="firemershal-生成linux-执行文件">firemershal 生成linux 执行文件&lt;/h2>
&lt;p>以下的命令可以构建工作负载 , 在构建完成之后可以在images 可以看到 br-base-bin 和 br-base.img 分别是 boot-binary (linux + boot loader) and root filesystem&lt;/p></description></item><item><title>Chipyard串口疑问</title><link>https://VastCircle.github.io/2024/chipyard%E4%B8%B2%E5%8F%A3%E7%96%91%E9%97%AE/</link><pubDate>Tue, 03 Dec 2024 19:43:44 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard%E4%B8%B2%E5%8F%A3%E7%96%91%E9%97%AE/</guid><description>&lt;h2 id="问题简述">问题简述&lt;/h2>
&lt;p>对于chipyard的串口,猜测是通过log去打印的,但是即使是通过dpic-log打印,也应该传输到串口的地址,但是从波形图来看是没有的&lt;/p></description></item><item><title>Zotero_tag</title><link>https://VastCircle.github.io/2024/zotero_tag/</link><pubDate>Mon, 02 Dec 2024 16:37:43 +0800</pubDate><guid>https://VastCircle.github.io/2024/zotero_tag/</guid><description>&lt;h2 id="zotero7-安装">zotero7 安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 创建zotero目录,这里选择的是/opt/这个目录下创建的，因为这个目录通常放下Google Chrome和火狐浏览器和pycharm。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mkdir /opt/zotero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 复制解压文件到/opt/zotero目录下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mv Zotero_linux-x86_64/* /opt/zotero/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">##更新zotero的桌面位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> /opt/zotero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ./set_launcher_icon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">##创造软连接到应用程序桌面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ln -s /opt/zotero/zotero.desktop ~/.local/share/applications/zotero.desktop
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>An_Event_Triggered_Programmable_Prefetcher_for_Irregular_Workloads</title><link>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</link><pubDate>Fri, 29 Nov 2024 23:39:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</guid><description>&lt;h1 id="针对不规则工作负载的事件触发可编程预取器">针对不规则工作负载的事件触发可编程预取器&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>许多现代工作负载需要处理大量数据，通常伴随不规则的内存访问。现有架构在处理这些工作负载时表现不佳，因为现有的预取技术无法捕捉内存访问模式，导致这些应用程序严重依赖内存。尽管已经有一些技术可以通过显式配置预取器的遍历模式来显著提高性能，这些方法的适用性通常局限于特定的数据结构。&lt;/p></description></item><item><title>Linux移植</title><link>https://VastCircle.github.io/2024/linux%E7%A7%BB%E6%A4%8D/</link><pubDate>Mon, 25 Nov 2024 10:53:14 +0800</pubDate><guid>https://VastCircle.github.io/2024/linux%E7%A7%BB%E6%A4%8D/</guid><description>&lt;h2 id="linux环境搭建的要求">linux环境搭建的要求&lt;/h2>
&lt;p>&lt;strong>1.搭建交叉开发环境&lt;/strong>
需要搭建交叉开发环境在pc机上编译出符合相应嵌入式系统体系结构和指令集的机器码，同时确定目标机和主机的连接方式，搭建数据传输通道。&lt;/p></description></item><item><title>使用conda创建一个隔离的环境</title><link>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8conda%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 24 Nov 2024 21:58:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8conda%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8E%AF%E5%A2%83/</guid><description>&lt;p>在chipyard的build-setup.sh里可以看到它是如何创建一个conda环境的&lt;/p>
&lt;p>具体来说就是通过conda-lock去将一个锁文件里的配置加载到一个conda环境了去，锁文件也是通过脚本generate-conda-lockfiles.sh生成的，所以根本文件是chipyard.yaml的配置文件&lt;/p></description></item><item><title>使用Tilelink实现缓存一致性（cache conherence）</title><link>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8tilelink%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Fri, 22 Nov 2024 16:29:39 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8tilelink%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>TileLink Cached (TL-C) 协议通过为主设备提供缓存共享数据块副本的能力，完善了 TileLink 协议。这些本地缓存副本必须根据实现定义的一致性策略保持一致性。本章节定义的 TL-C 标准一致性协议规定了哪些内存访问操作可以对缓存数据的副本执行，以及哪些消息可用于传输数据块的副本。实现中叠加的一致性策略则规定了在接收到内存访问操作后，如何在特定的 TileLink 代理网络中传播副本和权限。具体一致性策略的描述超出了本文档的范围。&lt;/p></description></item><item><title>Cache缓存一致性</title><link>https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Tue, 19 Nov 2024 20:03:48 +0800</pubDate><guid>https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>&lt;h2 id="多核心的一致性问题">多核心的一致性问题&lt;/h2>
&lt;p>在一个核心修改Cache数据后，如何同步给其他核心Cache&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 86; 
			flex-basis: 208px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138.png" data-size="479x552">
		&lt;img src="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138.png"
			width="479"
			height="552"
			srcset="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138_hu8859657908439870834.png 480w, https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138_hu16115704290875044832.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Cache</title><link>https://VastCircle.github.io/2024/cache/</link><pubDate>Sat, 16 Nov 2024 16:00:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/cache/</guid><description>&lt;h2 id="cache的一般设计">Cache的一般设计&lt;/h2>
&lt;p>Cache line = Cache data block + Cache Tag ,如果一个数据可以存储在Cache中的多个地方,能够被同一个地址找到的多个Cache Line 称为Cache Set&lt;/p></description></item><item><title>虚拟存储器</title><link>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</link><pubDate>Tue, 12 Nov 2024 20:12:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中&lt;/p></description></item><item><title>NBDcache</title><link>https://VastCircle.github.io/2024/nbdcache/</link><pubDate>Mon, 11 Nov 2024 16:33:27 +0800</pubDate><guid>https://VastCircle.github.io/2024/nbdcache/</guid><description>&lt;h2 id="dcache结构图">Dcache结构图&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 141; 
			flex-basis: 339px"
	>
	&lt;a href="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png" data-size="996x705">
		&lt;img src="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png"
			width="996"
			height="705"
			srcset="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu11066709581250157466.png 480w, https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu15637605824835427283.png 1024w"
			loading="lazy"
			alt="image-20241111163907552">
	&lt;/a>
	
	&lt;figcaption>image-20241111163907552&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>CPU路径查找</title><link>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Thu, 07 Nov 2024 20:15:39 +0800</pubDate><guid>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="rocket-chip">Rocket chip&lt;/h2>
&lt;h3 id="fronted-frontend-tileprcidomain_3sv">Fronted frontend TilePRCIDomain_3.sv&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 229; 
			flex-basis: 550px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png" data-size="1084x473">
		&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png"
			width="1084"
			height="473"
			srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu14349559803779590629.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu3287867411019239527.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;h4 id="icache_3-icache-frontendsv">ICache_3 icache frontend.sv&lt;/h4>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 173; 
			flex-basis: 416px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png" data-size="1040x599">
		&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png"
			width="1040"
			height="599"
			srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu3808893905549217750.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu1492137510679196975.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Scalar_runahead_execution</title><link>https://VastCircle.github.io/2024/scalar_runahead_execution/</link><pubDate>Thu, 31 Oct 2024 20:13:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/scalar_runahead_execution/</guid><description>&lt;h3 id="introduction">introduction&lt;/h3>
&lt;p>(i) 一种适用于顺序执行核心的高性能、低开销的硬件预取技术，称为标量前推执行（𝑆𝑅𝐸）。𝑆𝑅𝐸在寄存器传输级有效预取复杂的内存访问模式，并实现了硬件优化策略，以尽量减少能量和面积的开销（如图1所示）。&lt;/p></description></item><item><title>处理器成功运行的标志</title><link>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</link><pubDate>Thu, 31 Oct 2024 13:11:58 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</guid><description>&lt;h2 id="处理器运行">处理器运行&lt;/h2>
&lt;p>总共的过程应该是在exit之后,处理器(core0)会循环执行下面的代码,主要是要向0x80001ec0写入数据1,会写入到dcache那边&lt;/p></description></item><item><title>Big_soc_路径查找</title><link>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 30 Oct 2024 16:25:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="路径查找">路径查找&lt;/h2>
&lt;h3 id="bootrom-clocksinkdomain_1sv">Bootrom ClockSinkDomain_1.sv&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 158; 
			flex-basis: 381px"
	>
	&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png" data-size="567x357">
		&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png"
			width="567"
			height="357"
			srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu13999121753685267221.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu10622608143385405980.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Chipyard的三个highest_level</title><link>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</link><pubDate>Tue, 29 Oct 2024 21:56:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</guid><description>&lt;p>Chipyard SoC 中三个最高层次是&lt;code>ChipTop&lt;/code>(DUT)、&lt;code>TestHarness&lt;/code>和&lt;code>TestDriver&lt;/code>。&lt;code>ChipTop&lt;/code>和&lt;code>TestHarness&lt;/code>均由 Chisel 生成器发出。&lt;code>TestDriver&lt;/code>用作我们的测试平台，是 Rocket Chip 中的 Verilog 文件。&lt;/p></description></item><item><title>Rocket Chip学习</title><link>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 29 Oct 2024 17:12:22 +0800</pubDate><guid>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h2 id="rocket-chip-框图">rocket-chip 框图&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 93; 
			flex-basis: 224px"
	>
	&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png" data-size="685x733">
		&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png"
			width="685"
			height="733"
			srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu14119112562339422234.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu6804879921133493359.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>rocket-src微架构代码解读</title><link>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</link><pubDate>Sun, 27 Oct 2024 21:23:02 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid><description>&lt;h2 id="差异文件">差异文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 新加入的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RCU.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RH_Cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_data.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_tag.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Runahead_cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 修改过的 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/BTB.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Frontend.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCacheArbiter.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/NBDcache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RocketCore.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/Configs.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/SystemBus.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tile/Core.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Bundles.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Edges.scala 
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</link><pubDate>Sat, 26 Oct 2024 15:23:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</link><pubDate>Sat, 26 Oct 2024 15:06:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="重排序缓存">重排序缓存&lt;/h2>
&lt;h3 id="一般结构">一般结构&lt;/h3>
&lt;p>ROB是一个FIFO&lt;/p>
&lt;p>(1)Complete:表示一条指令是否执行完毕&lt;/p></description></item><item><title>执行</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</link><pubDate>Tue, 22 Oct 2024 13:17:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 135; 
			flex-basis: 326px"
	>
	&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png" data-size="560x412">
		&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png"
			width="560"
			height="412"
			srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu15249404520933549812.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu12474515009045795584.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>发射</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</link><pubDate>Sat, 19 Oct 2024 20:25:19 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令&lt;/p></description></item><item><title>寄存器重命名(超标量+过程恢复)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</link><pubDate>Sat, 19 Oct 2024 11:46:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</guid><description>&lt;h2 id="超标量处理器的寄存器重命名">超标量处理器的寄存器重命名&lt;/h2>
&lt;p>对于 Dest = Src1 op ASrc2&lt;/p>
&lt;p>(1)从RAT中找到Src1和Src2对应的物理寄存器Psrc1和Psrc2&lt;/p></description></item><item><title>寄存器重命名(方式+映射表)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</link><pubDate>Fri, 18 Oct 2024 19:25:31 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>WAW 和 WAR (写后写 和读后写) 可以通过更换寄存器的名字来解决相应冲突&lt;/p>
&lt;h3 id="存在原因">存在原因&lt;/h3>
&lt;p>(1)有限个数的寄存器&lt;/p></description></item><item><title>分支预测(目标地址预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</link><pubDate>Wed, 16 Oct 2024 18:26:42 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</guid><description>&lt;h2 id="分支预测的目标地址预测">分支预测的目标地址预测&lt;/h2>
&lt;p>对于直接跳转的分支指令,由于它的偏移值(offset)是以立即数的形式固定在指令中,目标地址是固定的,只需要记录分支指令的目标地址即可.&lt;/p></description></item><item><title>分支预测(概述+方向预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</link><pubDate>Tue, 15 Oct 2024 14:08:47 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;h3 id="分支预测需要的内容">分支预测需要的内容&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>方向，决定跳转与否&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标地址 决定跳转的目的地，riscv中有两种体现形式&lt;/p></description></item><item><title>超标量处理器概览</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link><pubDate>Mon, 14 Oct 2024 16:43:30 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid><description>&lt;h2 id="超标量处理器概览">超标量处理器概览&lt;/h2>
&lt;h3 id="超标量处理器的流水线">超标量处理器的流水线&lt;/h3>
&lt;h4 id="顺序执行">顺序执行&lt;/h4>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 248; 
			flex-basis: 596px"
	>
	&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png" data-size="1111x447">
		&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png"
			width="1111"
			height="447"
			srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu6270803957762553776.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu2445645561301413447.png 1024w"
			loading="lazy"
			alt="in-order pipline">
	&lt;/a>
	
	&lt;figcaption>in-order pipline&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>乱序执行CPU</title><link>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</link><pubDate>Sat, 12 Oct 2024 16:08:08 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</guid><description>&lt;h2 id="tomasulos-algorithm">Tomasulo&amp;rsquo;s algorithm&lt;/h2>
&lt;h3 id="tomasulos-algorithm创新">Tomasulo‘s algorithm创新&lt;/h3>
&lt;p>Tomasulo算法的主要创新包括硬件实现的寄存器重命名、为所有执行单元设计的保留站（reservation stations），以及一个公共数据总线（CDB），通过该总线计算出的值可以广播到所有可能需要它们的保留站。这些创新使得指令能够实现更好的并行执行，避免在使用记分板或其他早期算法时可能导致的停滞.&lt;/p></description></item><item><title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</title><link>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</link><pubDate>Thu, 10 Oct 2024 14:23:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。&lt;/p></description></item><item><title>Chipyard Learning</title><link>https://VastCircle.github.io/2024/chipyard-learning/</link><pubDate>Mon, 07 Oct 2024 16:15:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard-learning/</guid><description>&lt;h2 id="chipyard-从下载到构建">chipyard 从下载到构建&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone https://github.com/ucb-bar/chipyard.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> chipyard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout 1.10.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 为了使得clone顺利，把http都换成ssh ，使用命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find . -name &lt;span style="color:#98c379">&amp;#34;.gitmodules&amp;#34;&lt;/span> -type f -exec sed -i &lt;span style="color:#98c379">&amp;#39;s/https:\/\/github.com\//git@github.com:/g&amp;#39;&lt;/span> &lt;span style="color:#56b6c2">{}&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule sync
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 运行初始化脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./build-setup.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 导入conda环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">source&lt;/span> ./env.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">## 初始化software ，例如coremark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ./scripts/init-software.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>博客搭建</title><link>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 06 Oct 2024 21:57:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h2 id="安装hugo">安装Hugo&lt;/h2>
&lt;p>ubuntu 系统使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt install hugo 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令进行验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-hugo-网站">创建 Hugo 网站&lt;/h2>
&lt;p>通过上述命令安装 hugo 程序后，就可以通过 &lt;code>hugo new site&lt;/code> 命令进行网站创建、配置与本地调试了。&lt;/p></description></item></channel></rss>