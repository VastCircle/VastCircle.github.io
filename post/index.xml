<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on VastCircle's blog</title><link>https://VastCircle.github.io/post/</link><description>Recent content in Posts on VastCircle's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 07 Dec 2024 20:28:43 +0800</lastBuildDate><atom:link href="https://VastCircle.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers</title><link>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</link><pubDate>Sat, 07 Dec 2024 20:28:43 +0800</pubDate><guid>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</guid><description>&lt;h1 id="paraverser利用异构并行性实现数据中心中经济实惠的故障检测">ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。&lt;/p></description></item><item><title>Filemonitor</title><link>https://VastCircle.github.io/2024/filemonitor/</link><pubDate>Fri, 06 Dec 2024 13:29:58 +0800</pubDate><guid>https://VastCircle.github.io/2024/filemonitor/</guid><description>&lt;p>&lt;a class="link" href="https://github.com/TheKingOfDuck/FileMonitor?tab=readme-ov-file" target="_blank" rel="noopener"
 >https://github.com/TheKingOfDuck/FileMonitor?tab=readme-ov-file&lt;/a>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>Chipyard_boot_linux</title><link>https://VastCircle.github.io/2024/chipyard_boot_linux/</link><pubDate>Wed, 04 Dec 2024 21:26:52 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard_boot_linux/</guid><description>&lt;h2 id="firemershal-生成linux-执行文件">firemershal 生成linux 执行文件&lt;/h2>
&lt;p>以下的命令可以构建工作负载 , 在构建完成之后可以在images 可以看到 br-base-bin 和 br-base.img 分别是 boot-binary (linux + boot loader) and root filesystem&lt;/p></description></item><item><title>Chipyard串口疑问</title><link>https://VastCircle.github.io/2024/chipyard%E4%B8%B2%E5%8F%A3%E7%96%91%E9%97%AE/</link><pubDate>Tue, 03 Dec 2024 19:43:44 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard%E4%B8%B2%E5%8F%A3%E7%96%91%E9%97%AE/</guid><description>&lt;h2 id="问题简述">问题简述&lt;/h2>
&lt;p>对于chipyard的串口,猜测是通过log去打印的,但是即使是通过dpic-log打印,也应该传输到串口的地址,但是从波形图来看是没有的&lt;/p></description></item><item><title>Zotero_tag</title><link>https://VastCircle.github.io/2024/zotero_tag/</link><pubDate>Mon, 02 Dec 2024 16:37:43 +0800</pubDate><guid>https://VastCircle.github.io/2024/zotero_tag/</guid><description>&lt;h2 id="zotero7-安装">zotero7 安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 创建zotero目录,这里选择的是/opt/这个目录下创建的，因为这个目录通常放下Google Chrome和火狐浏览器和pycharm。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mkdir /opt/zotero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 复制解压文件到/opt/zotero目录下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mv Zotero_linux-x86_64/* /opt/zotero/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">##更新zotero的桌面位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> /opt/zotero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ./set_launcher_icon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">##创造软连接到应用程序桌面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ln -s /opt/zotero/zotero.desktop ~/.local/share/applications/zotero.desktop
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>An_Event_Triggered_Programmable_Prefetcher_for_Irregular_Workloads</title><link>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</link><pubDate>Fri, 29 Nov 2024 23:39:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</guid><description>&lt;h1 id="针对不规则工作负载的事件触发可编程预取器">针对不规则工作负载的事件触发可编程预取器&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>许多现代工作负载需要处理大量数据，通常伴随不规则的内存访问。现有架构在处理这些工作负载时表现不佳，因为现有的预取技术无法捕捉内存访问模式，导致这些应用程序严重依赖内存。尽管已经有一些技术可以通过显式配置预取器的遍历模式来显著提高性能，这些方法的适用性通常局限于特定的数据结构。&lt;/p></description></item><item><title>Linux移植</title><link>https://VastCircle.github.io/2024/linux%E7%A7%BB%E6%A4%8D/</link><pubDate>Mon, 25 Nov 2024 10:53:14 +0800</pubDate><guid>https://VastCircle.github.io/2024/linux%E7%A7%BB%E6%A4%8D/</guid><description>&lt;h2 id="linux环境搭建的要求">linux环境搭建的要求&lt;/h2>
&lt;p>&lt;strong>1.搭建交叉开发环境&lt;/strong>
需要搭建交叉开发环境在pc机上编译出符合相应嵌入式系统体系结构和指令集的机器码，同时确定目标机和主机的连接方式，搭建数据传输通道。&lt;/p></description></item><item><title>使用conda创建一个隔离的环境</title><link>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8conda%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 24 Nov 2024 21:58:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8conda%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8E%AF%E5%A2%83/</guid><description>&lt;p>在chipyard的build-setup.sh里可以看到它是如何创建一个conda环境的&lt;/p>
&lt;p>具体来说就是通过conda-lock去将一个锁文件里的配置加载到一个conda环境了去，锁文件也是通过脚本generate-conda-lockfiles.sh生成的，所以根本文件是chipyard.yaml的配置文件&lt;/p></description></item><item><title>使用Tilelink实现缓存一致性（cache conherence）</title><link>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8tilelink%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Fri, 22 Nov 2024 16:29:39 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%BD%BF%E7%94%A8tilelink%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>TileLink Cached (TL-C) 协议通过为主设备提供缓存共享数据块副本的能力，完善了 TileLink 协议。这些本地缓存副本必须根据实现定义的一致性策略保持一致性。本章节定义的 TL-C 标准一致性协议规定了哪些内存访问操作可以对缓存数据的副本执行，以及哪些消息可用于传输数据块的副本。实现中叠加的一致性策略则规定了在接收到内存访问操作后，如何在特定的 TileLink 代理网络中传播副本和权限。具体一致性策略的描述超出了本文档的范围。&lt;/p></description></item><item><title>Cache缓存一致性</title><link>https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Tue, 19 Nov 2024 20:03:48 +0800</pubDate><guid>https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>&lt;h2 id="多核心的一致性问题">多核心的一致性问题&lt;/h2>
&lt;p>在一个核心修改Cache数据后，如何同步给其他核心Cache&lt;/p>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 86; 
			flex-basis: 208px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138.png" data-size="479x552">
		&lt;img src="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138.png"
			width="479"
			height="552"
			srcset="https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138_hu8859657908439870834.png 480w, https://VastCircle.github.io/2024/cache%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image-20241119200747138_hu16115704290875044832.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Cache</title><link>https://VastCircle.github.io/2024/cache/</link><pubDate>Sat, 16 Nov 2024 16:00:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/cache/</guid><description>&lt;h2 id="cache的一般设计">Cache的一般设计&lt;/h2>
&lt;p>Cache line = Cache data block + Cache Tag ,如果一个数据可以存储在Cache中的多个地方,能够被同一个地址找到的多个Cache Line 称为Cache Set&lt;/p></description></item><item><title>虚拟存储器</title><link>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</link><pubDate>Tue, 12 Nov 2024 20:12:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>虚拟存储器的思想是对于一个程序来说,它的程序(code),数据(data)和堆栈(stack)的总大小可以超过实际物理内存的大小,操作系统把当前使用的部分内容放在物理内存中,而把其他未使用的内容放在更下一级的存储器中&lt;/p></description></item><item><title>NBDcache</title><link>https://VastCircle.github.io/2024/nbdcache/</link><pubDate>Mon, 11 Nov 2024 16:33:27 +0800</pubDate><guid>https://VastCircle.github.io/2024/nbdcache/</guid><description>&lt;h2 id="dcache结构图">Dcache结构图&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 141; 
			flex-basis: 339px"
	>
	&lt;a href="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png" data-size="996x705">
		&lt;img src="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552.png"
			width="996"
			height="705"
			srcset="https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu11066709581250157466.png 480w, https://VastCircle.github.io/2024/nbdcache/image-20241111163907552_hu15637605824835427283.png 1024w"
			loading="lazy"
			alt="image-20241111163907552">
	&lt;/a>
	
	&lt;figcaption>image-20241111163907552&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>CPU路径查找</title><link>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Thu, 07 Nov 2024 20:15:39 +0800</pubDate><guid>https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="rocket-chip">Rocket chip&lt;/h2>
&lt;h3 id="fronted-frontend-tileprcidomain_3sv">Fronted frontend TilePRCIDomain_3.sv&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 229; 
			flex-basis: 550px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png" data-size="1084x473">
		&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843.png"
			width="1084"
			height="473"
			srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu14349559803779590629.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108104913843_hu3287867411019239527.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p>
&lt;h4 id="icache_3-icache-frontendsv">ICache_3 icache frontend.sv&lt;/h4>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 173; 
			flex-basis: 416px"
	>
	&lt;a href="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png" data-size="1040x599">
		&lt;img src="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751.png"
			width="1040"
			height="599"
			srcset="https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu3808893905549217750.png 480w, https://VastCircle.github.io/2024/cpu%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241108105132751_hu1492137510679196975.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Scalar_runahead_execution</title><link>https://VastCircle.github.io/2024/scalar_runahead_execution/</link><pubDate>Thu, 31 Oct 2024 20:13:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/scalar_runahead_execution/</guid><description>&lt;h3 id="introduction">introduction&lt;/h3>
&lt;p>(i) 一种适用于顺序执行核心的高性能、低开销的硬件预取技术，称为标量前推执行（𝑆𝑅𝐸）。𝑆𝑅𝐸在寄存器传输级有效预取复杂的内存访问模式，并实现了硬件优化策略，以尽量减少能量和面积的开销（如图1所示）。&lt;/p></description></item><item><title>处理器成功运行的标志</title><link>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</link><pubDate>Thu, 31 Oct 2024 13:11:58 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%A4%84%E7%90%86%E5%99%A8%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%A0%87%E5%BF%97/</guid><description>&lt;h2 id="处理器运行">处理器运行&lt;/h2>
&lt;p>总共的过程应该是在exit之后,处理器(core0)会循环执行下面的代码,主要是要向0x80001ec0写入数据1,会写入到dcache那边&lt;/p></description></item><item><title>Big_soc_路径查找</title><link>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 30 Oct 2024 16:25:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/</guid><description>&lt;h2 id="路径查找">路径查找&lt;/h2>
&lt;h3 id="bootrom-clocksinkdomain_1sv">Bootrom ClockSinkDomain_1.sv&lt;/h3>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 158; 
			flex-basis: 381px"
	>
	&lt;a href="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png" data-size="567x357">
		&lt;img src="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345.png"
			width="567"
			height="357"
			srcset="https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu13999121753685267221.png 480w, https://VastCircle.github.io/2024/big_soc_%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE/image-20241030164859345_hu10622608143385405980.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>Chipyard的三个highest_level</title><link>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</link><pubDate>Tue, 29 Oct 2024 21:56:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard%E7%9A%84%E4%B8%89%E4%B8%AAhighest_level/</guid><description>&lt;p>Chipyard SoC 中三个最高层次是&lt;code>ChipTop&lt;/code>(DUT)、&lt;code>TestHarness&lt;/code>和&lt;code>TestDriver&lt;/code>。&lt;code>ChipTop&lt;/code>和&lt;code>TestHarness&lt;/code>均由 Chisel 生成器发出。&lt;code>TestDriver&lt;/code>用作我们的测试平台，是 Rocket Chip 中的 Verilog 文件。&lt;/p></description></item><item><title>Rocket Chip学习</title><link>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 29 Oct 2024 17:12:22 +0800</pubDate><guid>https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h2 id="rocket-chip-框图">rocket-chip 框图&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 93; 
			flex-basis: 224px"
	>
	&lt;a href="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png" data-size="685x733">
		&lt;img src="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013.png"
			width="685"
			height="733"
			srcset="https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu14119112562339422234.png 480w, https://VastCircle.github.io/2024/rocket-chip%E5%AD%A6%E4%B9%A0/image-20241029185840013_hu6804879921133493359.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>rocket-src微架构代码解读</title><link>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</link><pubDate>Sun, 27 Oct 2024 21:23:02 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%BE%AE%E6%9E%B6%E6%9E%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid><description>&lt;h2 id="差异文件">差异文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 新加入的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RCU.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RH_Cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_data.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/rh_tag.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Runahead_cache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">### 修改过的 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/BTB.scala
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/Frontend.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCacheArbiter.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/HellaCache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/NBDcache.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rocket/RocketCore.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/Configs.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subsystem/SystemBus.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tile/Core.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Bundles.scala 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tilelink/Edges.scala 
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</link><pubDate>Sat, 26 Oct 2024 15:23:09 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B09/</guid><description>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="参考文献">参考文献&lt;/h3>
&lt;h3 id="版权信息">版权信息&lt;/h3>
&lt;p>本文原载于 &lt;a class="link" href="https://vastcircle.github.io" target="_blank" rel="noopener"
 >vastcircle.github.io&lt;/a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p></description></item><item><title>提交</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</link><pubDate>Sat, 26 Oct 2024 15:06:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B05/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="重排序缓存">重排序缓存&lt;/h2>
&lt;h3 id="一般结构">一般结构&lt;/h3>
&lt;p>ROB是一个FIFO&lt;/p>
&lt;p>(1)Complete:表示一条指令是否执行完毕&lt;/p></description></item><item><title>执行</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</link><pubDate>Tue, 22 Oct 2024 13:17:32 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 135; 
			flex-basis: 326px"
	>
	&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png" data-size="560x412">
		&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468.png"
			width="560"
			height="412"
			srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu15249404520933549812.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B08/image-20241023143017468_hu12474515009045795584.png 1024w"
			loading="lazy"
			>
	&lt;/a>
	
&lt;/figure>&lt;/p></description></item><item><title>发射</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</link><pubDate>Sat, 19 Oct 2024 20:25:19 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B07/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>只要发射队列中的一条指令的草做书都准备好了,且满足了发射的条件,就可以送到相应的FU中执行.发射队列的作用就是使用硬件保存一定数量的指令,然后从指令中找出可以执行的指令&lt;/p></description></item><item><title>寄存器重命名(超标量+过程恢复)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</link><pubDate>Sat, 19 Oct 2024 11:46:41 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B06/</guid><description>&lt;h2 id="超标量处理器的寄存器重命名">超标量处理器的寄存器重命名&lt;/h2>
&lt;p>对于 Dest = Src1 op ASrc2&lt;/p>
&lt;p>(1)从RAT中找到Src1和Src2对应的物理寄存器Psrc1和Psrc2&lt;/p></description></item><item><title>寄存器重命名(方式+映射表)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</link><pubDate>Fri, 18 Oct 2024 19:25:31 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B04/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>WAW 和 WAR (写后写 和读后写) 可以通过更换寄存器的名字来解决相应冲突&lt;/p>
&lt;h3 id="存在原因">存在原因&lt;/h3>
&lt;p>(1)有限个数的寄存器&lt;/p></description></item><item><title>分支预测(目标地址预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</link><pubDate>Wed, 16 Oct 2024 18:26:42 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/</guid><description>&lt;h2 id="分支预测的目标地址预测">分支预测的目标地址预测&lt;/h2>
&lt;p>对于直接跳转的分支指令,由于它的偏移值(offset)是以立即数的形式固定在指令中,目标地址是固定的,只需要记录分支指令的目标地址即可.&lt;/p></description></item><item><title>分支预测(概述+方向预测)</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</link><pubDate>Tue, 15 Oct 2024 14:08:47 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;h3 id="分支预测需要的内容">分支预测需要的内容&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>方向，决定跳转与否&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标地址 决定跳转的目的地，riscv中有两种体现形式&lt;/p></description></item><item><title>超标量处理器概览</title><link>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link><pubDate>Mon, 14 Oct 2024 16:43:30 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid><description>&lt;h2 id="超标量处理器概览">超标量处理器概览&lt;/h2>
&lt;h3 id="超标量处理器的流水线">超标量处理器的流水线&lt;/h3>
&lt;h4 id="顺序执行">顺序执行&lt;/h4>
&lt;p>&lt;figure 
	
		class="gallery-image" 
		style="
			flex-grow: 248; 
			flex-basis: 596px"
	>
	&lt;a href="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png" data-size="1111x447">
		&lt;img src="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017.png"
			width="1111"
			height="447"
			srcset="https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu6270803957762553776.png 480w, https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20241014210154017_hu2445645561301413447.png 1024w"
			loading="lazy"
			alt="in-order pipline">
	&lt;/a>
	
	&lt;figcaption>in-order pipline&lt;/figcaption>
	
&lt;/figure>&lt;/p></description></item><item><title>乱序执行CPU</title><link>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</link><pubDate>Sat, 12 Oct 2024 16:08:08 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/</guid><description>&lt;h2 id="tomasulos-algorithm">Tomasulo&amp;rsquo;s algorithm&lt;/h2>
&lt;h3 id="tomasulos-algorithm创新">Tomasulo‘s algorithm创新&lt;/h3>
&lt;p>Tomasulo算法的主要创新包括硬件实现的寄存器重命名、为所有执行单元设计的保留站（reservation stations），以及一个公共数据总线（CDB），通过该总线计算出的值可以广播到所有可能需要它们的保留站。这些创新使得指令能够实现更好的并行执行，避免在使用记分板或其他早期算法时可能导致的停滞.&lt;/p></description></item><item><title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</title><link>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</link><pubDate>Thu, 10 Oct 2024 14:23:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。&lt;/p></description></item><item><title>Chipyard Learning</title><link>https://VastCircle.github.io/2024/chipyard-learning/</link><pubDate>Mon, 07 Oct 2024 16:15:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/chipyard-learning/</guid><description>&lt;h2 id="chipyard-从下载到构建">chipyard 从下载到构建&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone https://github.com/ucb-bar/chipyard.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e5c07b">cd&lt;/span> chipyard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout 1.10.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 为了使得clone顺利，把http都换成ssh ，使用命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find . -name &lt;span style="color:#98c379">&amp;#34;.gitmodules&amp;#34;&lt;/span> -type f -exec sed -i &lt;span style="color:#98c379">&amp;#39;s/https:\/\/github.com\//git@github.com:/g&amp;#39;&lt;/span> &lt;span style="color:#56b6c2">{}&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule sync
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 运行初始化脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./build-setup.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">## 导入conda环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e5c07b">source&lt;/span> ./env.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f848e">## 初始化software ，例如coremark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ./scripts/init-software.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>博客搭建</title><link>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 06 Oct 2024 21:57:38 +0800</pubDate><guid>https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h2 id="安装hugo">安装Hugo&lt;/h2>
&lt;p>ubuntu 系统使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt install hugo 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令进行验证&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建-hugo-网站">创建 Hugo 网站&lt;/h2>
&lt;p>通过上述命令安装 hugo 程序后，就可以通过 &lt;code>hugo new site&lt;/code> 命令进行网站创建、配置与本地调试了。&lt;/p></description></item></channel></rss>