[{"content":"分支预测的目标地址预测 对于直接跳转的分支指令,由于它的偏移值(offset)是以立即数的形式固定在指令中,目标地址是固定的,只需要记录分支指令的目标地址即可.\n对于间接分支跳转,大部分是CALL和Return ,所以可以进行一定程度的预测\n直接跳转类型的分支预测 (1)当分支指令不发生跳转时,\n目标地址 = 当前分支指令的PC值 + Sizeof(fetch group)\n(2)当发生跳转时\n目标指令 = 当前分支指令的PC值 + Sign_Eextend(offset)\nBTB 通过BTB(Branch Target Buffer)(相当于一个cache)使得多个PC值共用一个空间来存储目标地址,\nindex + tag ,\nBTA (Branch Target Address)分支目标地址\n可以使用组相联的BTA来提高分支预测的准确率\n如果已经被替换了,那该跳哪去 : 先跳再冲刷吗?\nimage-20241016185417711 partial-tag BTB 如果映射到BTB中的指令中只有一条,那可以简化tag的部分,只使用很小的一部分,\n这种方法实际上也是在赌,减少了tag的大小,万一出现了重合,那就会出现目标地址预测失败的情况,但实际上,如果出现了重合,即使不减少tag,仍然会导致预测失败.\nimage-20241016185852818 和之前类似,仍然可以采取一定运算,来降低tag的位数,比方说异或\n我比较好奇,如果tag没有对上,对于直接相连来说,本身也无法得到正确地址,那为什么不直接把tag删除了\n应该是组相联有用吧\nimage-20241016190929007 BTB缺失的处理 停止执行 暂停取指,直到目标地址被计算出来\n对于直接跳转指令,在解码阶段就可以分离出偏移值\n解码阶段分离指令 停止取指会造成气泡,其实就是导致流水线停滞\nimage-20241016192510520 继续执行 使用顺序的PC值去指令\n计算出的地址和原来PC不一致,就冲刷流水线,重新开始取指\n这么做会浪费功耗\n间接跳转类型的分支预测 CALL/Return 指令的分支预测 CALL的地址一般也是固定的,所以也可以通过BTB进行预测\nReturn的目标地址是不固定的,但是Return的目标地址总是等于最近一次执行的\n但是Return指令的目标地址,是按照CALL指令执行的相反顺序排列的\n所以可以做一个存储器,保存最近执行的CALL指令的下一条指令的地址,这个存储器是后进先出的(Last In First Out,LIFO),原理与堆栈类似,称为返回地址堆栈(Return Address Stack,RAS)\nCALL/Return 指令分支预测 RAS工作条件 (1)需要及时保存PC + 4的值, 指令类型只有在解码阶段才能获知,因此可以在BTB中多加一项来保存分支指令的类型,这样在后续取到这一条指令就可以获知分支指令类型\n(2)在对Return指令进行目标地址预测是,能够选择RAS的数据,而非BTB的数据,按照上面的方法就可以做到\n将指令类型存储到BTB中 RAS满了 如果函数层次过深,就会出现RAS无法继续存放的问题\n(1)不保存CALL了,这样下一次Return 就会出现分支预测失败,并且还要求RAS指针不发生改变\n(2)继续按照顺序向RAS写入,此时最旧的会被覆盖掉.最后一次return 可能会出现分支预测失败,但是也是可能性事件,比方说递归函数\n可以通过带计数器的RAS来扩展RAS的容量, 即对于相邻的CALL,如果是同一条指令,就存放在RAS的同一个地址,再用计数器进行标识\n其他指令的预测 case指令 image-20241016210205293 使用基于局部历史的分支预测方法,把PHT换成了Target Cache,\n每当分支指令执行一次,就将目标地址写到Target Cache 中\n小结 分支预测使用 BHR , GHR和饱和计数器配合进行分支指令方向的预测\n使用 BTB, RAS和 Target Cache对分支指令的目标地址进行预测\n完整的分支预测方法 , decoupled BTB : 将分支指令的方向预测独立于BTB ,本身不会被记录到BTB的分支指令也会被记录(不跳转的分支也会记录到BTB)\n预测为发生跳转,但是发生了BTB缺失,比发生分支预测失败的情况好,可以节省功耗\n完整的分支预测方法 分支预测失败的恢复 处在错误路径上的指令有可能已经将处理器中某个部位的内容进行了更改,例如寄存器重命名阶段的重命名映射表(mapping table),需要对操作进行撤销,即分支预测失败时的恢复\n分支预测检查 (1) 解码阶段可以检查直接跳转的正确性,可以得到分支指令的方向和目标地址,\n对于间接跳转,即使得知预测错误,也无法得到正确的地址,但是可以通过流水线暂停来避免抹掉指令造成的功耗浪费\n(2)在读取物理物理寄存器的阶段,读取到寄存器的值,就可以得到目标地址是否错误,进行重新取指令,\n还是需要对不必要的指令进行抹去,对于进入发射队列的指令,可能比较困难,需要选择性的进行抹去\n(3)在执行阶段,任何分支指令的结果都可以被计算出结果,可以进行检查,但是造成的惩罚(penalty)是最大的.需要清除在这条分支指令之后进入流水线的所有数据\n基于ROB的恢复 在乱序执行中,在这条分支指令之前的数据也会在发射队列或者执行中,可以采取重排序缓存(ROB)对处理器进行状态恢复 (ROB是顺序存储指令的)\n当发生分支指令预测失败时,将信息记录在ROB对应的表项(entry)中,并且暂停流水线的取指令,但是让流水线继续执行,当这条指令变为最旧的指令后,冲刷掉流水线中的所有数据,重新取指令. 缺点就是停滞时间会比较长.\n基于checkpoint的状态恢复 checkpoint, 发现分支指令,并且在分支指令之后的指令更改处理器的状态之前,将处理器的状态保存起来,包括寄存器重命名中使用的映射表(mapping table),预测跳转的分支指令对应的下一条指令的PC等.在寄存器重命名阶段进行.\n需要将流水线中所有处于分支预测失败路径上的指令抹去. 需要一种机制识别哪些指令处在错误的路径上,可以通过编号实现,(编号可以在顺序阶段就编号完成),编号之后就可以获知哪些指令位于分支指令后面\n分支指令的编号个数决定了最多可以在流水线中存在的分支指令个数:假设处理器中最多支持128条指令存在于流水线中,按照每五条指令存在一条分支,最多后128/5 = 26 条分支指令存在与流水线中,需要5位\n所有在流水线中的分支指令会被分配一个编号值,编号会被保存在FIFO中,称为编号列表(tag list)\n可以使用 (free tag list 和 tag list)来进行设计\n编号值不再被使用 : 分支指令成功retire , 分支预测失败 (分支预测失败之后就要根据编号来冲刷流水线了,所有编号可以回收了)\n流水线抹去 (1)发射之前的所有指令需要全部被抹去\n(2)流水线的发射阶段以及之后的流水段中,使用比寻找分支指令之后的指令全部抹去\ntag list 是顺序保存对应标号的 , 所以 比方说监测到分支指令3 预测失败,所以 0 ,1, 4 都需要被直接清除 , 因此通过广播编号值及将ROB中对应的指令置为无效\n一个周期内使用所有编号去抹去ROB的指令是不现实的,可以采取一个周期广播一个编号的方式 , 因为从取指到发射还是需要经过几个周期的,只要在这之前重排序缓存和发射队列指令被抹去了就行了\n编号值在解码阶段分配最合适 ,因为此时已经知道属于分支指令了\n对于多条分支指令,通过控制第二条分支指令及其后面的所有指令在本周期不能进入解码阶段,可以避免使用多端口的FIFO来进行赋值\nPTAB (Prediction Target Address Buffer) 通过将分支指令的预测值保存到一个缓存中,使得其在执行阶段进行分支预测是否正确的检查时能够正确调用,并且可以只保存方向预测为跳转的分支指令 PTAB , (Prediction Target Address Buffer)\n它不是本身就在BTB中吗,为啥还要一个buffer\n(1)valid , 表示PTAB中某个表项是否被占用, 当分支指令写入PATB时,置1,当完成检查之后,Reset\n(2)Predict Address,分支指令被预测的目标地址\n(3)Next PC, 分支指令的下一条PC , 如果预测错误,就直接使用其作为正确地址取指\n怎么去找PTAB对应的表项 ? 用 PC吗 ? 或者说用 Next PC吗\n写PTAB可以在取指阶段就完成\n自修改代码一般都会去清空分支预测器和I-Cache\n超标量处理器的分支预测 由于超标量取一个地址,会取出多条指令,所以如果只使用取指令时的地址进行分支预测,相当于只是对指令你个组中的第一条指令进行分支预测\n可以使用公共地址寻址分支预测器 (对于4-way超标量处理器[31:4]),因为多数情况下,实际只有一条分支指令 .在BTB中需要记录下分支指令在四条指令中的位置,避免错误使用它的结果 (为什么指令会出现非对齐存储?)\n目标地址的预测 要对指令组的所有指令进行分支预测,需要得到所有指令的PC值,需要使用3个加法器实现PC地址的获取,\n但是由于需要同时获取四个PC值对应的目标地址,需要BTB支持四个读端口,即使采用交疊避免真正的多端口,但是硬件利用率还是较低\n在分支指令的方向预测完毕之后,利用结果信息再进行目标地址的预测,可以避免对于BTB部件的多端口需求,,这种方法对于方向预测和目标地址预测是串行的\n对于RISC指令,大多数指令是直接跳转类型,目标地址无需预测,在取指之后实际就可以被计算出来.实现这样的功能需要进行预解码\n目标方向的预测 对于基于局部历史的分支预测方法来说,需要PHT和BHT支持多个读端口,可以通过交疊(interleaving)模拟实现多端口\n对于全局历史的分支预测,由于一个周期内进行分支预测的多条指令对应的GHR是不同的,需要进行特殊的处理\n交疊 : 7位地址Addr[6:0],通过Addr [1:0]进行寻址bank ,通过Addr[6:2]寻址bank对应的内容 ,就是使用多个单端口的存储器去组成多端口的功能\n附录 参考文献 超标量处理器设计\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-16T18:26:42+08:00","permalink":"https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B03/","title":"分支预测(目标地址预测)"},{"content":"概述 分支预测需要的内容 方向，决定跳转与否\n目标地址 决定跳转的目的地，riscv中有两种体现形式\nPC + 立即数，跳转范围受限。\n寄存器跳转，预测风险难度高，但是除了RETURN/CALL,一般建议不使用间接跳转。\n分支预测的解码 快速分辨出哪条指令是分支指令\nI-cache得出结果可能需要多个周期，这些周期无法得到准确的预测结果\n解码+分支预测放在一个周期 ， 严重影响周期时间\n快速解码 可以在指令从L2 cache 写入到I-cache时进行快速解码,(pre-decode),然后将指令否是分支的信息也写入I-cache.\n分支预测的最好时机是在当前周期得到去指令地址的时候\n可以直接通过PC值来进行分支预测，那就不需要进行解码了，但是只能够知道它是分支指令\npc分支预测 分支预测的方向预测 跳转 （taken)和不发生跳转（not token）\n一bit的跳转预测 image-20241015182744711 基于两位饱和计数器（2-bit saturating counter) 根据分支前两次的结果预测下一次的结果\n状态机 基于两位饱和计数器 （1）计数器处于饱和状态，分支指令本次被预测发生跳转\n（2） 计数器处于不饱和状态，分支指令预测发生跳转\n（3） 计数器处于不饱和状态，分支指令预测不发生跳转\n（4） 计数器处于饱和状态，分支指令被预测不发生跳转\n初始状态位于 strongly not taken 或者 weakly not taken\n状态机处于饱和状态，只有两次预测失败才会改变预测的结果\n对于以下的情况，该种方法能够有50%的成功预测率\nimage-20241015184801299 TTNTNTNTNT 对于这种情况，预测还是有问题，就是始终进入不了饱和，那还是相当于1bit\n另外两种预测方法 情况1是如果两次连续的跳转，就直接变成饱和的强跳转，那就需要两次不跳转才能预测为不跳转\n情况2是如果两次连续的不跳转，就直接变成饱和的不跳转，那就需要两次跳转才能预测为跳转\n利用格雷码降低功耗，减少出错的概率\n对于一般的for循环，TTTTTTTTTTTTTTN ,只会出现2次预测失败 ，开始时 weakly not taken , 当再次执行for循环，第一次就会预测成功\n存储方式 每一个PC需要一个两位的饱和计数器， 32 位 PC需要 2^30 * 2b 存储器 ， 使用如下方法存储（PHT（Pattern History Table））: 使用 PC的一部分进行存储\n别名 （aliasing) 不同PC有相同的饱和计数器，导致相互之间的干扰\n中立别名 ： 分支指令的方向一致\n破坏性别名 ： 分支指令的方向不一致\n使用PC值的一部分来寻址饱和计数器 image-20241015194600012 避免别名的方法 —— 哈希表 哈希表能够压缩32位PC到一个比较小的值\nimage-20241015194955893 更新时间点\n（1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新PHT 预测的结果更新PHT肯定不合理\n（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新PHT\n（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新PHT\n对于2,3，分支指令可能在PHT更新之前就被取过很多次了，会影响结果，但是影响的不多\n在乱序执行中，即使在执行阶段得到了一条分支指令的结果，也无法保证该结果是正确的，因为分支指令可能位于分支预测失败的路径上，所以（3）是最保险的\n顺序执行不会吗 ？ 不会 ，主要是乱序执行有可能前面的指令后于后面指令的执行 ，这样后面的指令不一定会执行\n基于局部历史的分支预测 BHR(Branch History Register):分支历史寄存器\n通过一个寄存器记录一条分支指令在过去的历史状态\nn位BHR记录n次结果\nBHR和PHT一一对应，BHR有多少种取值，PHT有多少表项（entry)\n结果从BHR右侧移入，对应的BHR值改变对应的PHT\n那就相当于把一个PC对应的表项有进行了细分 -\u0026gt; 一个BHR和多个PHT\n如果一个序列，连续相同的数有p位，则虚了的循环周期为p,只要BHR不小于p,就可以做完美预测\n寻址 如果进行全寻址的话 ， 1个PC值 需要 N位BTR + 2^N * 2 位PHT , 2^n 就需要 2^n（ N + 2^N * 2）\n所以需要PC部分值来寻址\nimage-20241016102002253 1个PHT\nPC部分值寻址PHT,PC通过hash处理寻址BHT\nimage-20241016104245339 异或（XOR)法\n位拼接法和异或法 基于全局历史的分支预测 对一条分支指令进行分支预测，考虑前面分支指令的执行结果\n需要一个全局历史寄存器（GHR(global history register)),记录最近执行的所有分支指令的结果、\n最理想的情况是对每条分支指令都使用一个PHT\n一个全局寄存器 + 每一条分支指令对应的PHT\nimage-20241016144951117 量变引起质变，当局部BHR少到只剩下一个的时候，就是全局GHR\nimage-20241016144931624 总结 两种分支预测方法\n局部历史分支预测：基于分支指令自身在过去的执行状况来进行分支预测，对每一条分支指令都使用分支历史寄存器（BHR),并使用了由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个BHR的规律，使用BHR和PHT配合进行分支预测\n全局历史分支预测：基于一条分支指令之前的一些分支指令的执行状况来进行分支预测，使用全局历史寄存器（GHR)记录所有分支指令的执行情况，由两位饱和计数器组成的PHT(Pattern History Table)来捕捉每一个GHR的规律,使用GHR和PHT配合进行分支预测\n竞争的分支预测 竞争的分支预测原理图 竞争的分支预测_更详细的原理图 理想情况下每一条分支指令都有一个CPHT(choice PHT)\nCPHT中的两位饱和计数器 当P1预测正确,P2预测错误时,计数器减1 当P1预测错误,P2预测正确时,计数器加1 当P1和P2预测结果一致时,不管预测正确与否,计数器保持不变 对于每一条指令,在GHR内容不同时,会导致使用不同的分支预测方法,所以将PC值与GHR进行相应运算再去寻址CPHT的地址.\n分支预测的更新 历史寄存器 （1）在流水线的取指令阶段，进行分支预测，根据预测的结果更新\n（2） 在流水线的执行阶段，当分支指令的方向被计算出来时，更新,分支指令可能在错误预测的路径上,造成错误\n（3） 在流水线的提交阶段，当分支指令要离开流水线是，更新 ,最保险的方法,但是浪费了性能\n一条分支指令b在时间t被分支预测,在时间 $t + \\Delta t$ 从流水线退休, 任何在 $ \\Delta t $内的时间被预测的分支指令都不会从分支指令的结果受益\nimage-20241016153738302 采取方法1更新 ,但是会出现分支预测失败的情况 ,即使后续的分支指令使用的错误的 GHR ,由于他们在预测失败的路径上,都会从流水线中被抹去\n修复GHR错误值的方法 提交(commit)阶段修复法 前端阶段Speculative GHR, 提交阶段放置一个 Ritired GHR, 在前端推测失败之后,需要等待分支指令退休的时候,将后端的GHR写到前端的GHR中,然后根据这条分支指令所指定的目标地址,重新取指令执行.\n该方法的缺点是会造成分支预测失败时惩罚的增大,(why?)\n利用提交阶段的GHR修复分支预测器的GHR checkpoint修复法 在取指令阶段更新GHR时,可以把旧的GHR值保存起来,保存的内容称为checkpoint GHR .一旦分支指令的结果在流水线中被计算出来,就可以对分支指令的分支预测是否正确进行检查.如果分支预测正确,说明GHR中的值是正确的,如果预测失败,将这条分支指令对于的checkpoint GHR恢复到前端的GHR中,并从这条分支指令正确的目标地址开始取指令执行\n我的理解是把原来的GHR和分支预测结果的反向结合然后放进fifo中,在预测失败时把这个值取出来\n如果是顺序执行,读取存储器的方式也可以用FIFO,\n方式二是对方式一的一种补充,使得能够在执行阶段也去实现恢复\n利用checkpoint的方法会GHR进行修复 修复BHR错误值的方法 方式和修复GHR基本是类似的,并且BHR很少出现一条分支指令在流水线的提交阶段更新BHR,流水线中又出现了这条分支指令使用BHR进行分支预测的情况,除非循环体很短\nimage-20241016181356130 两位饱和寄存器 由于饱和寄存器一般是处在饱和状态的,所以选择在分支指令退休的时候更新PHT的饱和计数器,也不会产生很大的负面影响\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-15T14:08:47+08:00","permalink":"https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B02/","title":"分支预测(概述+方向预测)"},{"content":"超标量处理器概览 超标量处理器的流水线 顺序执行 in-order pipline 假设流水线每周期可以从 I-Cache 中取出两条指令来执行，则称为2-way 的超标量处理器，在指令经过解码之后，需要根据自身的类型，将两条指令送到对应的 FU 中执行，这个过程称为发射(Issue)。在这个阶段，指令会读取寄存器而得到操作数，同时根据指令的类型，将指令送到对应的 FU 中进行执行。在执行阶段使用了三个 FU:第一个 FU 用来执行 ALU 类型的指令，第二个 FU 用来执行访问存储器类型的指令，第三个 FU 用来执行乘法操作，因为要保证流水线的写回(Write back)阶段是顺序执行的，因此所有 FU 都需要经历同样周期数的流水线，ScoreBoard 用来记录流水线中每条指令的执行情况，例如一条指令在哪个 FU 中执行，在什么时候这条指令可以将结果计算出来等， 一个典型的 ScoreBoard如下。\nscoreboard P: Pending,表示指令的结果还没有写回到逻辑寄存器中。\nF:一条指令在哪个 FU 中执行，在将指令结果进行旁路时会使用这个信息。\nResult Position:在这个部分记录了一条指令到达 FU 中流水段的哪个阶段，3 表示指令处于 FU 流水线的第一个流水段，1 表示指令到达 FU 流水段的最后一个阶段， 0 表示指令处于流水线的写回阶段，在流水线的发射阶段，会将指令的信息写到ScoreBoard 中，同时，这条指令会查询 ScoreBoard 来获知自己的源操作数是否都准备好了，在这条指令被送到 FU 中执行之后的每个周期，都会将这个值右移一位，这样使用这个值就可以表达出指令在 FU 中执行到哪个阶段，对于执行 ALU 类型指令的第一个 FU 来说，当指令到达 3 时，就可以将它的结果进行旁路了；而对于执行乘法指令的第三个 FU 来说，只有当指令到达 1 时，才可以将它的结果进行旁路。本书采取的应该是第二种。\nimage-20241014210458774 阻塞发生在译码级\n指令能够跳转到发射级的条件是scoreboard 对应处在级为2\n？一发就发两条，两条必须要同步吗 应该只是由于下条导致的等待\n指令D不能提前发射应该就是由于需要等待指令C发射\n指令C无法进入执行是由于前递的问题，需要等待指令A的前递\nimage-20241014212008795 乱序执行 乱序执行流水线 解码(Decode)阶段：为了在乱序执行时解决 WAW 和 WAR 这两种相关性，需要对寄存器进行重命名(register renaming),这个过程可以在流水线的解码(Decode)阶段完成，也可以单独使用一个流水段来完成，处理器中需要增加物理寄存器堆(Physical Register File, PRF)来配合对指令集中定义的寄存器( Architecture Register File,ARF)进行重命名，PRF 中寄存器的个数要多于 ARF。\n**Dispatch(分发):**在这个阶段，被重命名之后的指令会按照程序中规定的顺序，写到发射队列(Issue Queue)、重排序缓存(ROB)和 Store Buffer 等部件中，如果在这些部件中没有空闲的空间可以容纳当前的指令，那么这些指令就需要在流水线的重命名阶段进行等待，这就相当于暂停了寄存器重命名以及之前的所有流水线，直到这些部件中有空闲的空间为止。分发阶段可以和寄存器重命名阶段放在一起，在一些对周期时间要求比较紧的处理器中，也可以将这个部分单独使用一个流水段。\n发射(Issue)阶段：一旦指令的操作数准备好了，就可以从发射队列中离开，送到对应的 FU 中执行，因此发射阶段是流水线从顺序执行到乱序执行的分界点。每个 FU 都有自己的流水线级数，在这种流水线中，由于每个 FU 的执行周期数都不相同，所以指令在流水线的写回(Write Back)阶段是乱序的，在这个阶段，一条指令只要计算完毕， 就会将结果写到 PRF中，由于分支预测失败( mis-prediction)或者异常( exception)的存在，PRF 中的结果未必都会写到 ARF 中，因此也将 PRF 称为 Future File。\nRegister File Read(读取寄存器):被仲裁电路选中的指令需要从物理寄存器堆(Physical Register File,PRF)中读取操作数，一般情况下，被仲裁电路选中的指令可以从PRF 中得到源操作数，当然还有“不一般”的情况，那就是指令不能从 PRF 中得到操作数， 但是却可以在送到 FU 中执行之前，从旁路网络(bypassing network)中得到操作数，事实上很大一部分指令都是通过旁路网络获得操作数的，这也为减少 PRF 的读端口提供了可能。由于超标量处理器每周期需要执行好几条指令，PRF 所需要的端口个数也是比较多的，多端口寄存器堆的访问速度一般都不会很快，因此在现实世界的处理器中，这个阶段都会单独使用一个流水段。\n提交(Commit)阶段：为了保证程序的串行结果，指令需要按照程序中规定的顺序更新处理器的状态，这需要使用一个称为重排序缓存(ROB)的部件来配合，流水线中的所有指令都按照程序中规定的顺序存储在重排序缓存中，使用重排序缓存来实现程序对处理器状态的顺序更新，一条指令在这个阶段，会将它的结果从 PRF 搬移到 ARF 中，同时重排序缓存也会配合完成对异常(exception)的处理，如果不存在异常，那么这条指令就可以顺利地离开流水线， 并对处理器的状态进行更改，此时称这条指令退休(retire)了，一条指令一旦退休，它就再也不可能回到之前的状态了。\n因为 store 指令需要写存储器，如果在流水线的写回阶段就将 store 指令的结果写到存储器中，那么一旦由于分支预测失败或者异常等原因，需要将这条 store 指令从流水线中抹掉时，就没有办法将存储器的状态进行恢复了，因为存储器中原来的值已经被覆盖， Store Buffer(SB),来存储 store 指令没有退休之前的结果，store 指令在流水线的写回阶段，会将它的结果写到 Store Buffer 中，只有一条 store 指令真的从流水线中退休的时候，才可以将它的值从 Store Buffer 写到存储器中。使用了这个部件之后，Load 指令此时除了从 D-Cache 中寻找数据，还需要从 Store Buffer 中进行查找，这样在一定程度上增加了设计的复杂度。\n在重排序这里也会处理异常 ， 如果没有异常就会写入ARF, 并成功退休，但是无论有没有异常都会写入SB。退休了才可以去修改相应状态。\n发射阶段选择相应的指令并且送到FU,被选择的指令才会去读取物理寄存器\n写回阶段进行统一旁路，为什么我写的RISCV有这么多的旁路网络 ?\nimage-20241015131538323 image-20241014212008795 附录 参考文献 超标量处理器设计\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处\n","date":"2024-10-14T16:43:30+08:00","permalink":"https://VastCircle.github.io/2024/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","title":"超标量处理器概览"},{"content":"Tomasulo\u0026rsquo;s algorithm Tomasulo‘s algorithm创新 Tomasulo算法的主要创新包括硬件实现的寄存器重命名、为所有执行单元设计的保留站（reservation stations），以及一个公共数据总线（CDB），通过该总线计算出的值可以广播到所有可能需要它们的保留站。这些创新使得指令能够实现更好的并行执行，避免在使用记分板或其他早期算法时可能导致的停滞.\nTomasulo_Architechure CDB总线 公共数据总线（CDB）将保留站直接连接到功能单元。根据Tomasulo的设计，它“在保持优先顺序的同时促进并发执行” 。这带来了两个重要影响：\n功能单元可以直接访问任何操作的结果，而无需通过浮点寄存器。这使得多个等待同一结果的单元可以继续执行，而不必等待解决对寄存器文件读端口的争用问题。 危险检测和控制执行是分布式的。保留站负责控制指令何时可以执行，而不是依赖一个专门的危险单元来进行统一管理。 指令顺序 指令是按顺序发出的，因此即使它们是乱序执行的（即非顺序执行），指令序列的效果（如指令引发的异常）仍然会按照顺序执行处理器中的顺序发生。这确保了乱序执行不会影响程序的正确性和预期行为\n寄存器重命名 Tomasulo算法通过寄存器重命名来实现正确的乱序执行。所有的通用寄存器和保留站寄存器要么保存真实值，要么保存占位符值。如果在发射阶段某个目标寄存器的真实值不可用，则最初会使用占位符值。占位符值是一个标签，指示哪个保留站将生成真实值。当功能单元完成计算并在公共数据总线（CDB）上广播结果时，占位符将被真实值替换。\n每个功能单元都有一个保留站。保留站保存执行单条指令所需的信息，包括操作和操作数。当功能单元空闲且指令所需的所有源操作数均为真实值时，功能单元便开始处理指令。\n附录 参考文献 乱序执行CPU\nwikipedia Tomasulo\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-12T16:08:08+08:00","permalink":"https://VastCircle.github.io/2024/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8Ccpu/","title":"乱序执行CPU"},{"content":"Abstract 当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。\nintroduction 乱序执行处理器上的超前执行不会将长延迟操作“移开”（这需要在指令窗口中缓冲它及其后面的指令），而是将其扔出指令窗口。\n当指令窗口被一个长延迟操作阻塞时，架构寄存器文件(architectural register file)的状态会被checkpoint保存。然后处理器进入“超前运行模式”。它为阻塞操作分配一个虚假结果并将其扔出指令窗口。阻塞操作后的指令被**获取、执行，并以伪退休（pseudo-retired）**的方式从指令窗口中移除。当阻塞操作完成时，处理器重新进入“正常模式”。此时，它会恢复之前保存的检查点状态，并从阻塞操作开始重新获取和执行指令。 伪退出(pseudo-retire):指令按照传统意义上的方式执行和完成，只是它们不更新架构状态。\nimage-20241012153516456 Runahead 的好处来自于将被长延迟操作阻塞的小指令窗口转换为非阻塞窗口，从而使其具有大得多的窗口的性能。\n在这篇论文中，仅评估了runahead mode对于在二级缓存失效的内存操作的表现，尽管它也可以在任何阻塞指令窗口的长延迟操作上启动。基于英特尔奔腾4处理器的机器模型，该处理器拥有128个条目的指令窗口。 首先展示了当前的乱序执行引擎无法容忍长延迟的主存访问时间。接下来，展示了runahead mode如何更好地应对这些延迟，并且能够达到一个具有更大指令窗口的机器的性能。\nRelate work 暂无\nOut-of-order execution and memory latency tolerance(乱序执行和内存容忍度) Instruction and scheduling windows 乱序执行比顺序执行更能容忍缓存缺失，因为它能够调度与缓存缺失无关的操作。乱序执行的机器通过两个窗口实现这一点：指令窗口和调度窗口。 指令窗口保存所有已解码但尚未提交到架构状态的指令，其主要目的是保证指令按顺序退休，以支持精确异常。 调度窗口包含指令窗口中的一部分指令，其主要目的是每个周期搜索那些准备好执行的指令，并对它们进行调度执行。\n当一个长延迟操作发生时，它会阻塞指令窗口，直到操作完成。尽管后续的指令可能已经执行完成，但它们无法从指令窗口中退休。如果操作的延迟时间足够长，并且指令窗口不够大，指令会在窗口中堆积，最终导致指令窗口被填满。此时，机器会停顿并停止向前执行。\nMemory latency tolerance 取指理想 变 调度窗口 L2理想程度 指令窗口\n图 1 显示了七台不同机器的指令窗口停滞的周期百分比。每个栏顶部的数字是机器的IPC。该数据是所有模拟基准的平均值。\n具有完整指令窗口停顿的周期的百分比 Runahead 的性能优势来自于将指令提取到提取引擎的缓存中，并执行未命中一级或二级缓存的独立加载和存储。\nImplementation of runahead execution in an out-of-order processor 在本节中，我们描述了在乱序处理器上实现超前执行的情况，其中指令在被调度后并在执行之前访问寄存器文件。Intel Pentium 4 处理器 [13]、MIPS R10000 微处理器 [30] 和 Compaq Alpha 21264 处理器 [18] 是这种微架构的例子。在其他一些微架构中，例如 Intel Pentium Pro 处理器 [12]，指令在放入调度器之前访问寄存器文件。\nFrontend RAT(Register Alias Table)用于重命名传入指令，并包含架构寄存器到物理寄存器的推测映射。\nRetirement RAT 包含指向包含已提交架构值的物理寄存器的指针。它用于在分支错误预测和异常之后恢复状态。\nimage-20241010195821755 Entering runahead mode **当内存操作在二级缓存中未命中且该内存操作到达指令窗口的头部时，处理器进入超前执行模式。**导致进入超前执行模式的指令地址会被记录。为了在从超前运行模式退出时正确恢复架构状态，处理器对架构寄存器文件的状态进行检查点。出于性能原因，处理器还检查分支历史寄存器和返回地址堆栈的状态。\n架构寄存器文件的检查点可以通过复制提交寄存器别名表（RAT）指向的物理寄存器内容来完成，但这可能需要时间。为了避免因复制导致的性能损失，处理器可以在正常模式下不断更新检查点的架构寄存器文件。当非超前指令从指令窗口中提交时，它会将其结果更新到检查点寄存器文件中的架构目标寄存器。这样检查点操作不会浪费任何时钟周期。\n尽管Retirement RAT 在正常模式下指向架构寄存器状态，但在超前运行模式下它指向伪架构寄存器状态并反映伪退休指令更新的状态\nExecution in runahead mode 无效位和指令:每个物理寄存器都有一个与其关联的无效（INV）位，以指示它是否具有虚假值。任何源自设置了无效位的寄存器的指令都是无效指令。 INV 位用于防止使用虚假数据进行虚假预取和分支解析。 如果存储指令是无效的，它会在前置执行期间将一个 INV 值引入内存映像。为了处理前置模式下数据值（和 INV 值）通过内存的通信，我们使用一个小的“前置缓存”，它与一级数据缓存并行访问。\nINV 值的传播:引入 INV 值的第一条指令是导致处理器进入runahead mode的指令,如果这条指令是加载指令，它会将其物理目的寄存器标记为 INV。如果它是存储指令，则会在前置缓存中分配一行，并将其目标字节标记为 INV。任何无效的指令在调度或执行后写入寄存器时，会将该寄存器标记为 INV。任何有效的操作在写入寄存器时，会重置其目的寄存器的 INV 位。\nRunahead store operations and runahead cache 先行存储(store)指令不会将其结果写入任何地方。因此，依赖于有效先行存储的先行加载被视为无效指令并被丢弃。由于寄存器数量有限，因此将先行存储(store)的结果转发到先行加载(load)对于高性能至关重要。 如果存储及其相关加载都在指令窗口中，则此转发是通过当前乱序处理器中已存在的store buffer来完成的。 如果超前运行加载依赖于已经pseudo-retired的超前运行存储（这意味着该存储不再位于存储缓冲区中），则它应该从某个其他位置获取存储的结果。1是写入data cache ,2是弄一个大的fully-associative buffer。\n使用 runahead cache 来保存伪退休先行存储的结果和 INV 状态 ，提供指令之间的数据和INV状态的通信。为了支持存储和加载之间 INV 位的正确通信，存储缓冲区中的每个条目和runahead cache 中的每个字节都有一个相应的 INV 位。runahead cache 的每个字节还有另一个与其关联的位（STO 位），指示存储是否已写入该字节。仅当访问的字节由存储写入（设置了 STO 位）并且访问runahead cache 有效时，对超前运行高速缓存的访问才会导致命中。\n更新 INV 和 STO的规则:\n当有效的先行存储完成执行时，它将其数据写入其存储缓冲区条目（就像在普通处理器中一样）并重置该条目的关联 INV 位。同时，它查询数据缓存，如果数据缓存未命中，则向内存层次结构发送预取请求。（为什么store 要查 data cache） 当一个无效的先行存储被scheduled时，它会set其相关store buff条目的 INV 位。 当一个有效的先行存储离开指令窗口时，它会将其结果写入预运行缓存，并重置已写入字节的 INV 位。同时，它还会设置已写入字节的 STO 位。 当一个无效的先行存储离开指令窗口时，如果其地址有效，它会设置写入字节的 INV 位和 STO 位 先行存储从不将结果写入数据缓存。 当存储操作的地址无效时，存储操作会被简单地视为一个空操作（NOP）。由于加载操作无法识别与这些无效存储操作的依赖关系，它们可能会错误地从内存中加载一个陈旧的值。这个问题可以通过使用内存依赖预测器来缓解，**预测器可以识别无效地址存储操作与其依赖的加载操作之间的依赖关系。**一旦依赖关系被识别，如果存储操作的数据值是无效的，则加载操作会被标记为无效（INV）；如果存储操作的数据值是有效的，则可以将其forward给加载操作。\nRunahead load operations runahead load invalid :\n源自无效的物理寄存器\n依赖于store buffer中标记为无效（INV）的存储操作\n依赖于一个已经伪退休且是无效（INV）的存储操作(runahead cache)\n有效load会并行访问3个结构 ： data cache , runahead cache , store buffer .\n加载操作命中store buffer ，并且命中的条目被标记为有效，那么加载操作会从store buffer获取数据。 加载操作命中store buffer ，并且命中的条目被标记为无效（INV），那么加载操作会将其物理目标寄存器标记为无效（INV）。\n只有当加载指令访问的cache line有效且其访问的任何字节的 STO 位被set时，该加载才被视为在runahead cache 中命中。 如果load在store buffer未命中但在runahead cache 命中，则它会检查在runahead cache 访问的字节的 INV 位。如果没有INV 位set ，将使用runahead cache 中的数据。如果任意一个源数据字节被标记为 INV，则将其目标标记为INV。 如果load在store buffer和runahead cache 都未命中，但在data cache中命中，则它将使用data cache中的值，并被视为Valid。然而，由于以下两个原因，它实际上可能是无效的：1）它可能依赖于具有 INV 地址的store，或者 2）它可能依赖于一个 INV store，该store在runahead cache中将其目标字节标记为 INV，但由于冲突，相应的runahead cache被释放。然而，这两种情况都是罕见的，不会显著影响性能。\n如果加载在所有三个结构中都未命中，它会向L2 cache 发送请求以获取其数据。如果该请求在L2 cache 中命中，则数据将从L2 cache 传输到L1 cache ，加载完成其执行。如果请求在L2 cache 中未命中，加载会将其目标寄存器标记为 INV，并像导致进入runahead mode的加载那样(未命中L1 cache)从调度器中移除。该请求会发送到内存像一个未命中 L2 缓存的正常加载请求一样。\nstore buffer \u0026gt; runahead cache \u0026gt; data cache \u0026gt; L2 cache\nExecution and prediction of branches 在runahead mode中，分支的预测和解决方式与正常模式完全相同，唯一的区别是：具有 INV 源(寄存器标记为INV)的分支（与所有分支一样）被预测并以推测的方式更新全局分支历史寄存器，但与其他分支不同，它永远无法被解决。如果分支被正确预测，这不是问题。然而，如果分支预测错误，处理器在获取到该分支后将始终处于错误路径，直到遇到一个与控制流无关的点。我们将获取到错误预测的 INV 分支的程序中的点称为“分歧点”。分歧点的存在不一定对性能有害，但正如我们稍后将展示的，分歧点在runahead mode中出现得越晚，性能提升就越好。\n与分支预测相关的一个有趣问题是前置模式下分支预测器表的训练策略。一种选择——也是我们实现中采用的选项——是始终训练分支预测器表。如果一个分支首先在前置模式下执行，然后在正常模式下执行，这种策略将导致同一个分支对分支预测器进行两次训练。因此，预测器表的性能得到了增强，计数器可能会失去滞后效应。第二种选择是绝不在前置模式下训练分支预测器。这会导致前置模式下的分支预测准确率降低，从而降低性能，并使分歧点更接近前置入口点。第三种选择是始终在前置模式下训练分支预测器，但同时使用一个队列将前置模式下分支的结果传递给正常模式。在正常模式下，如果存在预测，则使用该队列中的预测来进行分支预测。如果一个分支使用来自队列的预测进行预测，则不会再次训练预测器表。第四种选择是为前置模式和正常模式使用两个独立的预测器表，并在进入前置模式时将正常模式的表信息复制到前置模式。这一选项在硬件实现上成本较高，但我们进行了模拟以确定第一种选项的双重训练策略有多重要。我们的结果显示，与第四种选择相比，二次训练分支预测器表条目并没有显著降低性能。\nInstruction pseudo-retirement during runahead mode. 在runahead mode下，指令按照程序顺序离开指令窗口。如果某条指令到达指令窗口的队头，它将被考虑进行pseudo-retire。 如果被考虑pseudo-retire的指令是无效的（INV），它会立即从窗口中移除。 如果指令是有效的，它需要等待执行完毕（此时它可能变为无效的），并将结果写入物理寄存器文件。在pseudo-retire时，一条指令会释放为其执行分配的所有资源。\n无论是有效还是无效的指令，在它们离开指令窗口时都会更新退休重命名表（Retirement RAT）。退休重命名表不需要存储与每个寄存器关联的无效（INV）位，因为物理寄存器已经各自关联了无效位。\nExiting runahead mode 任何时候可以退出 runahead mode , 所有在处理器中执行的指令都会被清除，它们的缓冲区会被释放。检查点保存的架构寄存器文件会复制到物理寄存器文件的预定部分。前端和退休的重命名表（RAT）也会被修复，以便它们指向保存架构寄存器值的物理寄存器。\n附录 知识点补充 store buffer 分支预测 Architectural Register 架构寄存器是指每个CPU独有的一组全局寄存器，这些寄存器不与其他CPU共享。它们可以存储任意类型的数据，并且能够在CPU内部的线程之间实现快速通信。\n参考文献 architectural register\n浅谈乱序执行CPU\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-10T14:23:54+08:00","permalink":"https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/","title":"Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors"},{"content":"chipyard 从下载到构建 git clone https://github.com/ucb-bar/chipyard.git cd chipyard git checkout 1.10.0 ## 为了使得clone顺利，把http都换成ssh ，使用命令 find . -name \u0026#34;.gitmodules\u0026#34; -type f -exec sed -i \u0026#39;s/https:\\/\\/github.com\\//git@github.com:/g\u0026#39; {} + ## 同步 git submodule sync ## 运行初始化脚本 ./build-setup.sh ## 导入conda环境 source ./env.sh ## 初始化software ，例如coremark ./scripts/init-software.sh 配置一个2核心soc chipyard 配置文件 chipyard的配置文件是在chipyard/generators/chipyard/src/main/scala/config中，\nclass MyCoreConfigs extends Config( new freechips.rocketchip.subsystem.WithNBigCores(2) ++ // single rocket-core new chipyard.config.AbstractConfig) 在sim/verilator界面去执行命令,可以生成文件 simulator-chipyard-MyCoreConfig\nmake CONFIG=MyCoreConfig 裸机编译riscv #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } $ riscv64-unknown-elf-gcc -fno-common -fno-builtin-printf -specs=htif_nano.specs -c hello.c $ riscv64-unknown-elf-gcc -static -specs=htif_nano.specs hello.o -o hello.riscv $ spike hello.riscv Hello, World! -fno-common ​ 默认情况下，C语言会将未初始化的全局变量放在一个“common”区域，可以被多个文件共享。-fno-common 禁止这种行为，要求每个未初始化的全局变量必须在一个文件中定义。\n-fno-builtin-printf ​ 禁用编译器内置的 printf 函数，强制使用标准库中的 printf 函数\n-specs=htif_nano.specs ​ htif_nano.specs 可能是为特定硬件平台（例如 RISC-V）的模拟环境或硬件接口（HTIF）准备的编译和链接配置，确保生成的代码可以在特定环境中运行\n-static\n强制使用静态链接库，而不是动态链接库。所有需要的库代码都会在编译时直接链接到生成的可执行文件中，而不是在运行时动态加载。\n生成波形 make run-binary-debug BINARY=test.riscv 应该是要重新编译前文生成的bin文件\n## 方法1 make run-binary-debug BINARY=test.riscv CONFIG=MyCoreConfig ## 方法2 ./simulator-chipyard-RocketConfig $RISCV/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-simple 在output/chipyard.harness.TestHarness.MyCoreConfig 可以看到hello.vcd\n使用 gtkwave可以打开hello.vcd 查看\nrocket chip tiles 每个Rocket核心都与一个页表遍历器、L1 指令缓存和 L1 数据缓存组合成一个RocketTile\n每个 CPU 块都有一个 L1 指令缓存和 L1 数据缓存。这些缓存的大小和关联性可以配置。默认RocketConfig 使用 16 KiB、4 路组关联指令和数据缓存\nMemory System 这些图块(Tiles)连接到SystemBus，后者将其连接到 L2 缓存组。然后，L2 缓存组连接到MemoryBus，后者通过 TileLink 到 AXI 转换器连接到 DRAM 控制器\nMMIO 对于 MMIO 外围设备，SystemBus连接到ControlBus和PeripheryBus\nControlBus连接标准外围设备，如 BootROM、平台级中断控制器 (PLIC)、核心本地中断 (CLINT) 和调试单元\nBootROM BootROM 包含第一阶段引导加载程序，即系统复位后运行的第一条指令。它还包含设备树，Linux 会使用它来确定连接了哪些其他外设，具体在 /generators/rocket-chip/bootrom\n#define DRAM_BASE 0x80000000 .section .text.start, \u0026#34;ax\u0026#34;, @progbits .globl _start _start: csrwi 0x7c1, 0 // disable chicken bits li s0, DRAM_BASE csrr a0, mhartid la a1, _dtb jr s0 .section .text.hang, \u0026#34;ax\u0026#34;, @progbits .globl _hang _hang: csrwi 0x7c1, 0 // disable chicken bits csrr a0, mhartid la a1, _dtb csrwi mie, 0 1: wfi j 1b .section .rodata.dtb, \u0026#34;a\u0026#34;, @progbits .globl _dtb .align 5, 0 _dtb: .ascii \u0026#34;DTB goes here\u0026#34; linker.ld\nSECTIONS { ROM_BASE = 0x10000; /* ... but actually position independent */ . = ROM_BASE; .text.start : { *(.text.start) } . = ROM_BASE + 0x40; .text.hang : { *(.text.hang) } . = ROM_BASE + 0x80; .rodata.dtb : { *(.rodata.dtb) } } 第一条指令应该是从0x10000开始\n附录 参考文献 chipyard手册\nhttps://www.cnblogs.com/hwzhao/p/17363380.html\n版权信息 本文原载于 vastcircle.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-07T16:15:07+08:00","permalink":"https://VastCircle.github.io/2024/chipyard-learning/","title":"Chipyard Learning"},{"content":"安装Hugo ubuntu 系统使用\nsudo apt install hugo 使用以下命令进行验证\nhugo version 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了。\nhugo new site robin-site 配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。\n官方主题网站: https://themes.gohugo.io/\n主题推荐:\nPure: https://themes.gohugo.io/hugo-theme-pure/ 关联主题仓库 https://github.com/reuixiy/hugo-theme-meme/blob/main/README.zh-cn.md\n我们可以将主题仓库直接 git clone 下来进行使用，例如在根目录robin-site下运行以下代码，即可下载pure主题.\ngit clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure 这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。官方更推荐使用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\ncd robin-site/ git init git submodule add https://github.com/pseudoyu/pure themes/pure 然后在根目录下的 config.toml文件中添加新的一行:\ntheme = \u0026#34;pure\u0026#34; 更新主题 如果是 clone 了其他人的博客项目进行修改，则需要用以下命令进行初始化：\ngit submodule update --init --recursive 如果需要同步主题仓库的最新修改，需要运行以下命令：\ngit submodule update --remote hugo-theme-meme主题配置 ## 安装meme git submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme ## 替换配置 rm config.toml \u0026amp;\u0026amp; cp themes/meme/config-examples/zh-cn/config.toml config.toml zozo 主题配置 git submodule add https://github.com/varkai/hugo-theme-zozo themes/zozo rm config.toml \u0026amp;\u0026amp; cp themes/zozo/config.toml config.toml https://gojun.me/posts/hello-hugo-blog/\nHugo-theme-stack主题配置 https://stack.jimmycai.com/guide/getting-started\n新建博文 完成后，可以通过 hugo new 命令发布新文章。\nhugo new posts/test.md --- title: \u0026#34;Test\u0026#34; date: 2022-10-21T19:00:43+08:00 draft: true --- 这个命令会在 content 目录下建立 post 目录，并在 post 下生成 test.md 文件，博文书写就在这个文件里使用 Markdown 语法完成。博文的 front matter 里draft 选项默认为 true，需要改为 false 才能发表博文，建议直接更改上面说的archetypes 目录下的 default 文件，把 draft: true 改为 draft: false，这样生成的博文就是默认可以发表的。\n生成网页 为了查看生成的博客的效果，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。在cmd中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。\nhugo server -D 但此时只能在本地访问，如果想发布到 Github Pages ， 还需要借助 GithubPages 工具。\n配置文件 打开配置config.toml可以看到很多的参数可以配置，这里只描述最基本的内容，不同的主题可能会支持不同的参数配置，具体请看对应主题的说明文档。baseURL是站点的域名。title是站点的名称。theme是站点的主题。还有关于评论和打赏的相关配置，这些配置都可以参考官网主题的说明。\n每次发布的时候，都需要先执行hugo，把新写的文档按照主题进行渲染，所有生成的文件默认都在当前pulic的子目录下，可以在config里面配置到其他目录。然后把所有新的文件提交到github。提交代码之后，要等一段时间才生效。\ngithub actions 部署 两个仓库 如果想使用 Github Actions 自动部署 hugo 博客，则最起码需要创建两个 Github 的仓库。\n第一个，便是存储博客 .md 源文件的地方，其实就是 hugo 系统； 第二个，则是部署 Github Pages 的仓库，仓库名必须是 \u0026lt;username\u0026gt;.github.io，这是 github 官方要求的。 最终版 主题 使用的是大佬美化后的版本 Mantyke/Hugo-stack-theme-mod。\n因为还是想用github工作流，不使用vercel,所以接下来结合前面的多篇文章操作,第一步是clone fork 之后的仓库，然后修改remote为一个创建好的私人仓库\ngit clone git@github.com:VastCircle/Hugo-stack.git git remote set-url origin git@github.com:VastCircle/hugostack.git 之后通过一系列的git操作将网页部署到gh-pages分支上\nrm -rf public git add . git commit -m \u0026#39;hugo project init\u0026#39; git push -u origin master ## create a new orphand branch (no commit history) named gh-pages git checkout --orphan gh-pages ## Unstage all files git rm -rf --cached $(git ls-files) ## Add and commit that file git add . git commit -m \u0026#34;INIT: initial commit on gh-pages branch\u0026#34; ## Push to remote gh-pages branch git push origin gh-pages ## Return to master branch git checkout master ## Add the gh-pages branch of the repository. It will look like a folder named public git subtree add --prefix=public git@github.com:VastCircle/hugostack.git gh-pages --squash ## Pull down the file we just committed. This helps avoid merge conflicts git subtree pull --prefix=public git@github.com:VastCircle/hugostack.git gh-pages ## Push the public subtree to the gh-pages branch git subtree push --prefix=public git@github.com:VastCircle/hugostack.git gh-pages 貌似失败了\n再来一次 这次把public作为一个独立的仓库，通过.gitignore去屏蔽public ,使得 主仓库不包括 public ,\nrm -rf public ## 主仓库 git add . git commit -m \u0026#39;hugo project init\u0026#39; git push -u origin master ## 推送仓库 hugo cd public git remote add origin https://github.com/VastCircle/VastCircle.github.io.git git add . git commit -m \u0026#34;INIT: initial commit on public\u0026#34; git push -u origin master shell 脚本\n#deploy.sh #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo # if using a theme, replace by `hugo -t \u0026lt;yourtheme\u0026gt;` # Go To Public folder cd public # Add changes to git. git add -A # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # Come Back cd .. 添加 github action .github/workflows/deploy-site.yaml\nname: deploy on: push: branches: [\u0026#34;master\u0026#34;] workflow_dispatch: # schedule: # # Runs everyday at 8:00 AM # - cron: \u0026#34;0 0 * * *\u0026#34; # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow one concurrent deployment concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: true # Default to bash defaults: run: shell: bash jobs: # BUild job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.134.0 TZ: America/Los_Angeles steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo id: pages uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.134.0\u0026#39; extended: true - name: Build Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: hugo --minify - name: Deploy Web id: deployment uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: VastCircle/VastCircle.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 如何编写博客 正如同其他的博客，使用 Markdown 语言来编写博客。Markdown 流行且极易上手，因此这里就不多介绍语法，如果不会的可以自己搜索了解。\n使用 Hugo 创建文章 在博客根目录下运行：\nhugo new post/untitled.md 为什么要用 hugo 来新建而不是创建一个 .md 文件呢？这是因为使用 hugo 创建会自动使用已填入 Front Matter的模板。\nFront Matter 用于标识文章的标题、时间等信息，hugo 就是据此来生成静态页面。关于属性的含义和用法可以参考 Hugo 中文文档。\n模板可以在 \\archetypes\\default.md 下找到：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; # 标题，创建时自动填充 description: # 文章简介 date: {{ .Date }} # 日期，创建时自动填充，格式同 2023-01-15T12:00:00+08:00 image: # 文章的封面，留空就是没有，填文章所在位置的相对地址，通常放在同目录下， math: # 是否启用 KaTex，填 true 启用 license: # 文章尾部显示的协议，false 为隐藏，其他作为内容，留空就是使用 config.yaml 里默认的 hidden: false # 是否隐藏，一般用不到 comments: true # 因为 bug 所以这个属性只要存在，不管是 true 还是 false 都会导致回复无法显示，需要删掉 draft: true # 是否为草稿，建议改为 false 或者删掉这个属性以防止忘记修改，毕竟我们一般都是写好了才部署到服务器上 --- 为了方便，我参考网络以及 stack-mod 的功能对模板进行了一些改造：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; slug: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; description: date: \u0026#34;{{ .Date }}\u0026#34; lastmod: \u0026#34;{{ .Date }}\u0026#34; image: cover.png math: license: hidden: false draft: false categories: [\u0026#34;\u0026#34;] tags: [\u0026#34;\u0026#34;] --- ## 附录 ### 参考文献 ### 版权信息 本文原载于 [reincarnatey.net](https://blog.reincarnatey.net)，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。 因此我们可以编写一个批处理程序来快速帮我们生成文章：\ncreate_post.sh：\n#!/bin/bash # 输出提示信息 echo \u0026#34;【创建文章】\u0026#34; # 读取用户输入的 Slug read -p \u0026#34;请输入Slug: \u0026#34; input # 获取当前日期 current_date=$(date +%Y%m%d) # 使用 Hugo 创建新文章 hugo new post/$current_date-$input/index.md # 暂停，提示用户操作完成 read -p \u0026#34;按任意键继续...\u0026#34; 用此批处理程序生成的文章会创建在 \\content\\post\\2023\\0115-test\\index.md，便于我们整理文章资料，同时后续在同目录下存放文章的封面也不会导致内容很乱。\n使用 Hugo 创建类别、标签 创建 Categories 和 Tag 也同理：\nhugo new categories/testcat.md hugo new tags/testtag.md hugo 会自动应用 \\archetypes\\categories.md 和 \\archetypes\\tags.md 的模板，但是这两个模板都不太好，建议都改为：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; slug: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; description: image: cover.png style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; --- create_Categories.sh：\n@echo off echo 【创建类别】 set /p input= 请输入类别名: hugo new categories/%input%/_index.md pause 生成的categories就是在改变如下图所示的界面\nimage1 create_tag.sh：\n@echo off echo 【创建标签】 set /p input= 请输入标签名: hugo new tags/%input%/_index.md pause 注意：如果创建多级文件夹时文章文件名不是 index.md 或者类别、标签文件名不是 _index.md 的话，设置封面图片会出现问题。\n引用 https://hk.v2ex.com/t/1009591\nhttps://jianzhnie.github.io/post/hugo_site/\nhttps://hyrtee.github.io/2023/start-blog/\nhttps://smc.im/post/deploy-hugo-blog-with-github-actions/\n建站技术 | 使用 Hugo + Stack 简单搭建一个博客\nhttps://kaichu.io/posts/my-first-post/\nstack 手册\n部署hugo 踩过的坑_\nhttps://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/\n","date":"2024-10-06T21:57:38+08:00","permalink":"https://VastCircle.github.io/2024/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"}]