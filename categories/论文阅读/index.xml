<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>论文阅读 on VastCircle's blog</title><link>https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</link><description>Recent content in 论文阅读 on VastCircle's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 07 Dec 2024 20:28:43 +0800</lastBuildDate><atom:link href="https://VastCircle.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>ParaVerser_Harnessing_Heterogeneous_Parallelism_For_Affordable_Fault_Detection_in_Data_Centers</title><link>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</link><pubDate>Sat, 07 Dec 2024 20:28:43 +0800</pubDate><guid>https://VastCircle.github.io/2024/paraverser_harnessing_heterogeneous_parallelism_for_affordable_fault_detection_in_data_centers/</guid><description>&lt;h1 id="paraverser利用异构并行性实现数据中心中经济实惠的故障检测">ParaVerser：利用异构并行性实现数据中心中经济实惠的故障检测&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>数据中心运营商已经意识到，由于有缺陷的硅计算单元导致的无声数据损坏是大规模流行的。已经部署了软件扫描仪来缓解该问题，但要么覆盖率低，要么需要数月时间，从而导致长时间不正确行为。相比之下，汽车中使用的冗余机制使所需的功率和面积增加了一倍，因此无法实际部署在服务器空间中。我们推出了 ParaVerser，这是一种高覆盖率、低开销的服务器硬件级错误检测解决方案。通过较小的架构修改，我们使异构服务器级处理器中的传统核心能够充当检查器核心，从而利用异构性、扩展频率和重复运行中固有的并行性来提供节能的错误检查。通过将 big.LITTLE 型无序超标量核心与有序超标量核心动态耦合，在相同保证的情况下，我们相对于典型锁步系统将能源开销降低了 70%，而性能仅下降 4.3%，每核心面积开销为 1064B 。&lt;/p></description></item><item><title>An_Event_Triggered_Programmable_Prefetcher_for_Irregular_Workloads</title><link>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</link><pubDate>Fri, 29 Nov 2024 23:39:07 +0800</pubDate><guid>https://VastCircle.github.io/2024/an_event_triggered_programmable_prefetcher_for_irregular_workloads/</guid><description>&lt;h1 id="针对不规则工作负载的事件触发可编程预取器">针对不规则工作负载的事件触发可编程预取器&lt;/h1>
&lt;h2 id="abstract">abstract&lt;/h2>
&lt;p>许多现代工作负载需要处理大量数据，通常伴随不规则的内存访问。现有架构在处理这些工作负载时表现不佳，因为现有的预取技术无法捕捉内存访问模式，导致这些应用程序严重依赖内存。尽管已经有一些技术可以通过显式配置预取器的遍历模式来显著提高性能，这些方法的适用性通常局限于特定的数据结构。&lt;/p></description></item><item><title>Scalar_runahead_execution</title><link>https://VastCircle.github.io/2024/scalar_runahead_execution/</link><pubDate>Thu, 31 Oct 2024 20:13:06 +0800</pubDate><guid>https://VastCircle.github.io/2024/scalar_runahead_execution/</guid><description>&lt;h3 id="introduction">introduction&lt;/h3>
&lt;p>(i) 一种适用于顺序执行核心的高性能、低开销的硬件预取技术，称为标量前推执行（𝑆𝑅𝐸）。𝑆𝑅𝐸在寄存器传输级有效预取复杂的内存访问模式，并实现了硬件优化策略，以尽量减少能量和面积的开销（如图1所示）。&lt;/p></description></item><item><title>Runahead_Execution_An_Alternative_to_Very_Large_Instruction_Windows_for_Out of Order_Processors</title><link>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</link><pubDate>Thu, 10 Oct 2024 14:23:54 +0800</pubDate><guid>https://VastCircle.github.io/2024/runahead_execution_an_alternative_to_very_large_instruction_windows_for_out-of-order_processors/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>当今的高性能处理器通过乱序执行来容忍长延迟操作。然而，随着延迟的增加，如果我们要继续容忍这些延迟，指令窗口的大小必须增加得更快。本文提出先行(runahead)执行是提高乱序处理器内存延迟容忍度(memory latency tolerance)的有效方法，而不需要不合理的大指令窗口。超前执行可解除因长延迟操作而阻塞的指令窗口的阻塞，从而使处理器能够在程序路径中提前执行,这会导致数据在需要之前就被预取到缓存中。&lt;/p></description></item></channel></rss>